cscope 15 $HOME/Desktop/kpimon/e2sm/lib               0000709974
	@AMF-UE-NGAP-ID.c

8 
	~"AMF-UE-NGAP-ID.h
"

11 
	$AMF_UE_NGAP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

14 
vue
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(
	`a_INTEGER2lg
(

, &
vue
)) {

24 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

26 
td
->
me
, 
__FILE__
, 
__LINE__
);

30 if((
vue
 >= 0 && value <= 1099511627775)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_AMF_UE_NGAP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_CONSTRAINED
, 40, -1, 0, 1099511627775 } ,

47 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

50 cڡ 
b_v_g_t
 
	ga_DEF_AMF_UE_NGAP_ID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_AMF_UE_NGAP_ID
 = {

56 &
a_OP_INTEGER
,

57 
a_DEF_AMF_UE_NGAP_ID_gs_1
,

58 (
a_DEF_AMF_UE_NGAP_ID_gs_1
)

59 /(
a_DEF_AMF_UE_NGAP_ID_gs_1
[0]),

60 
a_DEF_AMF_UE_NGAP_ID_gs_1
,

61 (
a_DEF_AMF_UE_NGAP_ID_gs_1
)

62 /(
a_DEF_AMF_UE_NGAP_ID_gs_1
[0]),

63 { 0, &
a_PER_ty_AMF_UE_NGAP_ID_cڡr_1
, 
AMF_UE_NGAP_ID_cڡt
 },

	@AMFPointer.c

8 
	~"AMFPor.h
"

11 
	$AMFPor_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 6)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_AMFPor_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

47 { 
APC_CONSTRAINED
, 0, 0, 6, 6 } ,

50 cڡ 
b_v_g_t
 
	ga_DEF_AMFPor_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_AMFPor
 = {

56 &
a_OP_BIT_STRING
,

57 
a_DEF_AMFPor_gs_1
,

58 (
a_DEF_AMFPor_gs_1
)

59 /(
a_DEF_AMFPor_gs_1
[0]),

60 
a_DEF_AMFPor_gs_1
,

61 (
a_DEF_AMFPor_gs_1
)

62 /(
a_DEF_AMFPor_gs_1
[0]),

63 { 0, &
a_PER_ty_AMFPor_cڡr_1
, 
AMFPor_cڡt
 },

65 &
a_SPC_BIT_STRING_ecs


	@AMFRegionID.c

8 
	~"AMFRegiID.h
"

11 
	$AMFRegiID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 8)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_AMFRegiID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

47 { 
APC_CONSTRAINED
, 0, 0, 8, 8 } ,

50 cڡ 
b_v_g_t
 
	ga_DEF_AMFRegiID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_AMFRegiID
 = {

56 &
a_OP_BIT_STRING
,

57 
a_DEF_AMFRegiID_gs_1
,

58 (
a_DEF_AMFRegiID_gs_1
)

59 /(
a_DEF_AMFRegiID_gs_1
[0]),

60 
a_DEF_AMFRegiID_gs_1
,

61 (
a_DEF_AMFRegiID_gs_1
)

62 /(
a_DEF_AMFRegiID_gs_1
[0]),

63 { 0, &
a_PER_ty_AMFRegiID_cڡr_1
, 
AMFRegiID_cڡt
 },

65 &
a_SPC_BIT_STRING_ecs


	@AMFSetID.c

8 
	~"AMFSID.h
"

11 
	$AMFSID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 10)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_AMFSID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

47 { 
APC_CONSTRAINED
, 0, 0, 10, 10 } ,

50 cڡ 
b_v_g_t
 
	ga_DEF_AMFSID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_AMFSID
 = {

56 &
a_OP_BIT_STRING
,

57 
a_DEF_AMFSID_gs_1
,

58 (
a_DEF_AMFSID_gs_1
)

59 /(
a_DEF_AMFSID_gs_1
[0]),

60 
a_DEF_AMFSID_gs_1
,

61 (
a_DEF_AMFSID_gs_1
)

62 /(
a_DEF_AMFSID_gs_1
[0]),

63 { 0, &
a_PER_ty_AMFSID_cڡr_1
, 
AMFSID_cڡt
 },

65 &
a_SPC_BIT_STRING_ecs


	@BIT_STRING.c

5 
	~<a_.h
>

6 
	~<BIT_STRING.h
>

7 
	~<a_.h
>

12 cڡ 
b_v_g_t
 
	ga_DEF_BIT_STRING_gs
[] = {

13 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

15 
a_OCTET_STRING_ecifics_t
 
	ga_SPC_BIT_STRING_ecs
 = {

16 (
BIT_STRING_t
),

17 
offtof
(
BIT_STRING_t
, 
_a_x
),

18 
ASN_OSUBV_BIT


20 
a_TYPE_ݔi_t
 
	ga_OP_BIT_STRING
 = {

21 
OCTET_STRING_
,

22 
BIT_STRING_t
,

23 
BIT_STRING_com
,

24 
OCTET_STRING_decode_b
,

25 
OCTET_STRING_code_d
,

26 
OCTET_STRING_decode_x_by
,

27 
BIT_STRING_code_x
,

28 #ifdef 
ASN_DISABLE_OER_SUPPORT


32 
BIT_STRING_decode_r
,

33 
BIT_STRING_code_r
,

35 #ifdef 
ASN_DISABLE_PER_SUPPORT


41 
BIT_STRING_decode_ur
,

42 
BIT_STRING_code_ur
,

43 
OCTET_STRING_decode_
,

44 
OCTET_STRING_code_
,

46 
BIT_STRING_ndom_fl
,

49 
a_TYPE_dest_t
 
	ga_DEF_BIT_STRING
 = {

52 &
a_OP_BIT_STRING
,

53 
a_DEF_BIT_STRING_gs
,

54 (
a_DEF_BIT_STRING_gs
)

55 / (
a_DEF_BIT_STRING_gs
[0]),

56 
a_DEF_BIT_STRING_gs
,

57 (
a_DEF_BIT_STRING_gs
)

58 / (
a_DEF_BIT_STRING_gs
[0]),

59 { 0, 0, 
BIT_STRING_cڡt
 },

61 &
a_SPC_BIT_STRING_ecs


68 
	$BIT_STRING_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

69 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

70 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

72 if(

 && st->
buf
) {

73 if((

->
size
 =0 && st->
bs_unud
)

74 || 

->
bs_unud
 < 0 || st->bits_unused > 7) {

75 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

77 
td
->
me
, 
__FILE__
, 
__LINE__
);

81 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

83 
td
->
me
, 
__FILE__
, 
__LINE__
);

88 
	}
}

90 cڡ *
	g_b_n
[16] = {

95 
a_c_rv_t


96 
	$BIT_STRING_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

97 
ev
, 
x_cod_ags_e
 
ags
,

98 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

99 
a_c_rv_t
 

 = {0, 0, 0};

100 
sch
[128];

101 *
p
 = 
sch
;

102 *
snd
 = 
sch
 + ((scratch) - 10);

103 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

104 
xn
 = (
ags
 & 
XER_F_CANONICAL
);

105 
ut8_t
 *
buf
;

106 
ut8_t
 *
d
;

108 if(!

 || !->
buf
)

109 
ASN__ENCODE_FAILED
;

111 

.
coded
 = 0;

113 
buf
 = 

->buf;

114 
d
 = 
buf
 + 

->
size
 - 1;

119 ; 
buf
 < 
d
; buf++) {

120 
v
 = *
buf
;

121 
ƚe
 = 
xn
?0:(((
buf
 - 

->buf) % 8) == 0);

122 if(
p
 >
snd
 || 
ƚe
) {

123 
	`ASN__CALLBACK
(
sch
, 
p
 - scratch);

124 
p
 = 
sch
;

125 if(
ƚe

	`ASN__TEXT_INDENT
(1, 
ev
);

127 
	`memy
(
p
 + 0, 
_b_n
[
v
 >> 4], 4);

128 
	`memy
(
p
 + 4, 
_b_n
[
v
 & 0x0f], 4);

129 
p
 += 8;

132 if(!
xn
 && ((
buf
 - 

->buf) % 8) == 0)

133 
	`ASN__TEXT_INDENT
(1, 
ev
);

134 
	`ASN__CALLBACK
(
sch
, 
p
 - scratch);

135 
p
 = 
sch
;

137 if(
buf
 =
d
) {

138 
v
 = *
buf
;

139 
ubs
 = 

->
bs_unud
;

140 
i
;

141 
i
 = 7; i >
ubs
; i--)

142 *
p
++ = (
v
 & (1 << 
i
)) ? 0x31 : 0x30;

143 
	`ASN__CALLBACK
(
sch
, 
p
 - scratch);

146 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
 - 1);

148 
	`ASN__ENCODED_OK
(

);

149 
cb_ed
:

150 
ASN__ENCODE_FAILED
;

151 
	}
}

158 
	$BIT_STRING_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

159 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

160 cڡ * cڡ 
h2c
 = "0123456789ABCDEF";

161 
sch
[64];

162 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

163 
ut8_t
 *
buf
;

164 
ut8_t
 *
d
;

165 *
p
 = 
sch
;

167 ()
td
;

169 if(!

 || !->
buf
)

170  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

172 
ev
++;

173 
buf
 = 

->buf;

174 
d
 = 
buf
 + 

->
size
;

179 ; 
buf
 < 
d
; buf++) {

180 if((
buf
 - 

->buf% 16 =0 && (->
size
 > 16)

181 && 
buf
 !

->buf) {

182 
	`_i_INDENT
(1);

184 if(
	`cb
(
sch
, 
p
 - sch, 
p_key
) < 0)  -1;

185 
p
 = 
sch
;

187 *
p
++ = 
h2c
[*
buf
 >> 4];

188 *
p
++ = 
h2c
[*
buf
 & 0x0F];

189 *
p
++ = 0x20;

192 if(
p
 > 
sch
) {

193 
p
--;

195 if((

->
size
 > 16)) {

196 
	`_i_INDENT
(1);

200 if(
	`cb
(
sch
, 
p
 - sch, 
p_key
) < 0)

204 if(

->
bs_unud
) {

205 
t
 = 
	`tf
(
sch
, (scratch), " (%d bit%s unused)",

206 

->
bs_unud
, st->bits_unused == 1 ? "" : "s");

207 
	`as
(
t
 > 0 && < (
ssize_t
)(
sch
));

208 if(
t
 > 0 && < (
ssize_t
)(
sch
)

209 && 
	`cb
(
sch
, 
t
, 
p_key
) < 0)

214 
	}
}

219 cڡ 
BIT_STRING_t
 *

220 
	$BIT_STRING__comify
(cڡ 
BIT_STRING_t
 *

, BIT_STRING_*
tmp
) {

221 cڡ 
ut8_t
 *
b
;

223 cڡ 
ut8_t
 *
c_buf
;

224 
ut8_t
 *
nc_buf
;

225 } 
uncڡ
;

227 if(

->
size
 == 0) {

228 
	`as
(

->
bs_unud
 == 0);

229  

;

231 
b
 = &

->
buf
[->
size
 - 1]; b > st->buf && *b == 0; b--) {

235 if(*
b
) {

236 
unud
 = 7;

237 
ut8_t
 
v
 = *
b
;

238 
v
 &-(
t8_t
)v;

239 if(
v
 & 0x0F
unud
 -= 4;

240 if(
v
 & 0x33
unud
 -= 2;

241 if(
v
 & 0x55
unud
 -= 1;

242 
tmp
->
size
 = 
b
-

->
buf
 + 1;

243 
tmp
->
bs_unud
 = 
unud
;

245 
tmp
->
size
 = 
b
-

->
buf
;

246 
tmp
->
bs_unud
 = 0;

249 
	`as
(
b
 >

->
buf
);

252 
uncڡ
.
c_buf
 = 

->
buf
;

253 
tmp
->
buf
 = 
uncڡ
.
nc_buf
;

254  
tmp
;

255 
	}
}

262 
	$BIT_STRING_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

263 cڡ *
br
) {

269 
BIT_STRING_t
 
com_a
, 
com_b
;

270 cڡ 
BIT_STRING_t
 *
a
 = 
	`BIT_STRING__comify
(

, &
com_a
);

271 cڡ 
BIT_STRING_t
 *
b
 = 
	`BIT_STRING__comify
(
br
, &
com_b
);

272 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics
;

274 
	`as
(
ecs
 && scs->
subv
 =
ASN_OSUBV_BIT
);

276 if(
a
 && 
b
) {

277 
size_t
 
comm_efix_size
 = 
a
->
size
 <
b
->size ?->size : b->size;

278 
t
 = 
	`memcmp
(
a
->
buf
, 
b
->buf, 
comm_efix_size
);

279 if(
t
 == 0) {

281 if(
a
->
size
 < 
b
->size) {

283 } if(
a
->
size
 > 
b
->size) {

287 if(
a
->
bs_unud
 > 
b
->bits_unused) {

289 } if(
a
->
bs_unud
 < 
b
->bits_unused) {

296  
t
;

298 } if(!
a
 && !
b
) {

300 } if(!
a
) {

305 
	}
}

307 #ide 
ASN_DISABLE_PER_SUPPORT


309 #unde
RETURN


310 
	#RETURN
(
_code
) \

312 
a_dec_rv_t
 
tmv
; \

313 
tmv
.
code
 = 
_code
; \

314 
tmv
.
csumed
 = 
csumed_mylf
; \

315  
tmv
; \

316 } 0)

	)

318 
a_r_cڡt_t
 
	ga_DEF_BIT_STRING_cڡt_size
 = {

319 
APC_SEMI_CONSTRAINED
, -1, -1, 0, 0};

321 
a_dec_rv_t


322 
	$BIT_STRING_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

323 cڡ 
a_TYPE_dest_t
 *
td
,

324 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

325 
a_r_da_t
 *
pd
) {

326 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


327 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


328 : &
a_SPC_BIT_STRING_ecs
;

329 cڡ 
a_r_cڡts_t
 *
pc
 =

330 
cڡts
 ? cڡt: 
td
->
codg_cڡts
.
r_cڡts
;

331 cڡ 
a_r_cڡt_t
 *
csiz
;

332 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

333 
BIT_STRING_t
 *

 = (BIT_STRING_*)*

;

334 
ssize_t
 
csumed_mylf
 = 0;

335 

;

337 ()
t_codec_x
;

339 if(
pc
) {

340 
csiz
 = &
pc
->
size
;

342 
csiz
 = &
a_DEF_BIT_STRING_cڡt_size
;

345 if(
ecs
->
subv
 !
ASN_OSUBV_BIT
) {

346 
	`ASN_DEBUG
("Subv %d in BIT OSUBV_BIT", 
ecs
->
subv
);

347 
	`RETURN
(
RC_FAIL
);

353 if(!

) {

354 

 = (
BIT_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

355 if(!


	`RETURN
(
RC_FAIL
);

358 
	`ASN_DEBUG
("PER Decoding %s size %ld .. %ld bits %d",

359 
csiz
->
ags
 & 
APC_EXTENSIBLE
 ? "extensible" : "non-extensible",

360 
csiz
->
low_bound
, csiz->
u_bound
, csiz->
efive_bs
);

362 if(
csiz
->
ags
 & 
APC_EXTENSIBLE
) {

363 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

364 if(
ext
 < 0
	`RETURN
(
RC_WMORE
);

365 if(
ext
) {

366 
csiz
 = &
a_DEF_BIT_STRING_cڡt_size
;

370 if(
csiz
->
efive_bs
 >= 0) {

371 
	`FREEMEM
(

->
buf
);

372 

->
size
 = (
csiz
->
u_bound
 + 7) >> 3;

373 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(->
size
 + 1);

374 if(!

->
buf
{ st->
size
 = 0; 
	`RETURN
(
RC_FAIL
); }

380 if(
csiz
->
efive_bs
 == 0) {

381 
t
;

382 
	`ASN_DEBUG
("Encodg BIT STRING siz%ld", 
csiz
->
u_bound
);

383 
t
 = 
	`r_g_my_bs
(
pd
, 

->
buf
, 0, 
csiz
->
u_bound
);

384 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

385 
csumed_mylf
 +
csiz
->
u_bound
;

386 

->
buf
[->
size
] = 0;

387 

->
bs_unud
 = (8 - (
csiz
->
u_bound
 & 0x7)) & 0x7;

388 
	`RETURN
(
RC_OK
);

391 

->
size
 = 0;

393 
ssize_t
 
w_n
;

394 
ssize_t
 
n_bys
;

395 
ssize_t
 
n_bs
;

396 *
p
;

397 
t
;

400 
w_n
 = 
	`ur_g_ngth
(
pd
, 
csiz
->
efive_bs
, csiz->
low_bound
,

401 &

);

402 if(
w_n
 < 0
	`RETURN
(
RC_WMORE
);

403 if(
w_n
 =0 && 

->
buf
) ;

405 
	`ASN_DEBUG
("Got PERengthb %ld,en %ld, %s (%s)",

406 ()
csiz
->
efive_bs
, ()
w_n
,

407 

 ? "" : "", 
td
->
me
);

408 
n_bs
 = 
w_n
;

409 
n_bys
 = (
n_bs
 + 7) >> 3;

410 if(
n_bs
 & 0x7

->
bs_unud
 = 8 - (len_bits & 0x7);

412 
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 
n_bys
 + 1);

413 if(!
p

	`RETURN
(
RC_FAIL
);

414 

->
buf
 = (
ut8_t
 *)
p
;

416 
t
 = 
	`r_g_my_bs
(
pd
, &

->
buf
[->
size
], 0, 
n_bs
);

417 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

418 

->
size
 +
n_bys
;

419 } 

);

420 

->
buf
[->
size
] = 0;

422  
rv
;

423 
	}
}

425 
a_c_rv_t


426 
	$BIT_STRING_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

427 cڡ 
a_r_cڡts_t
 *
cڡts
,

428 cڡ *

, 
a_r_ou_t
 *
po
) {

429 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 =

430 
td
->
ecifics
 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)td->specifics

431 : &
a_SPC_BIT_STRING_ecs
;

432 cڡ 
a_r_cڡts_t
 *
pc
 =

433 
cڡts
 ? cڡt: 
td
->
codg_cڡts
.
r_cڡts
;

434 cڡ 
a_r_cڡt_t
 *
csiz
;

435 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

436 
BIT_STRING_t
 
com_br
;

437 
a_c_rv_t
 

 = { 0, 0, 0 };

438 
ext
 = 0;

439 
size_t
 
size__bs
;

440 cڡ 
ut8_t
 *
buf
;

441 
t
;

442 
_exnsib
;

444 if(!

 || (!->
buf
 && st->
size
))

445 
ASN__ENCODE_FAILED
;

447 if(
ecs
->
subv
 =
ASN_OSUBV_BIT
) {

448 if((

->
size
 =0 && st->
bs_unud
) || (st->bits_unused & ~7))

449 
ASN__ENCODE_FAILED
;

451 
ASN__ENCODE_FAILED
;

454 if(
pc
) {

455 
csiz
 = &
pc
->
size
;

457 
csiz
 = &
a_DEF_BIT_STRING_cڡt_size
;

459 
_exnsib
 = 
csiz
->
ags
 & 
APC_EXTENSIBLE
;

462 

 = 
	`BIT_STRING__comify
(, &
com_br
);

463 
size__bs
 = 8 * 

->
size
 - st->
bs_unud
;

465 
	`ASN_DEBUG
(

466 "Encodg %t%" 
ASN_PRI_SIZE
 " bits"

468 
td
->
me
, 
size__bs
, 
csiz
->
low_bound
, csiz->
u_bound
,

469 
csiz
->
efive_bs
, 
_exnsib
 ? " EXT" : "");

473 if(
csiz
->
efive_bs
 >= 0) {

474 if((
ssize_t
)
size__bs
 > 
csiz
->
u_bound
) {

475 if(
_exnsib
) {

476 
csiz
 = &
a_DEF_BIT_STRING_cڡt_size
;

477 
ext
 = 1;

479 
ASN__ENCODE_FAILED
;

483 
ext
 = 0;

486 if(
_exnsib
) {

488 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

489 
ASN__ENCODE_FAILED
;

492 if(
csiz
->
efive_bs
 >0 && !
ext
) {

493 
add_a
 = (
ssize_t
)
size__bs
 < 
csiz
->
low_bound
;

494 
	`ASN_DEBUG
(

495 "Encodg %" 
ASN_PRI_SIZE
 " bytes (%ld),ength (in %d bits)railer %d;ctual "

496 "vu%" 
ASN_PRI_SSIZE
 "",

497 

->
size
, 
size__bs
 - 
csiz
->
low_bound
, csiz->
efive_bs
,

498 
add_a
,

499 
add_a
 ? 0 : (
ssize_t
)
size__bs
 - 
csiz
->
low_bound
);

500 
t
 = 
	`r_put_w_bs
(

501 
po
, 
add_a
 ? 0 : (
ssize_t
)
size__bs
 - 
csiz
->
low_bound
,

502 
csiz
->
efive_bs
);

503 if(
t

ASN__ENCODE_FAILED
;

504 
t
 = 
	`r_put_my_bs
(
po
, 

->
buf
, 
size__bs
);

505 if(
t

ASN__ENCODE_FAILED
;

506 if(
add_a
) {

507 cڡ 
ut8_t
 
zos
[16];

508 
size_t
 
ag_zo_bs
 = 
csiz
->
low_bound
 - 
size__bs
;

509 
ag_zo_bs
 > 0) {

510 if(
ag_zo_bs
 > 8 * (
zos
)) {

511 
t
 = 
	`r_put_my_bs
(
po
, 
zos
, 8 * (zeros));

512 
ag_zo_bs
 -8 * (
zos
);

514 
t
 = 
	`r_put_my_bs
(
po
, 
zos
, 
ag_zo_bs
);

515 
ag_zo_bs
 = 0;

517 if(
t

ASN__ENCODE_FAILED
;

520 
	`ASN__ENCODED_OK
(

);

523 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SIZE
 " bys", 

->
size
);

525 
buf
 = 

->buf;

527 
ed_eom
 = 0;

528 
ssize_t
 
maySave
 = 
	`ur_put_ngth
(
po
, 
size__bs
, &
ed_eom
);

529 if(
maySave
 < 0
ASN__ENCODE_FAILED
;

531 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SSIZE
 " o%" 
ASN_PRI_SIZE
 "", 
maySave
, 
size__bs
);

533 
t
 = 
	`r_put_my_bs
(
po
, 
buf
, 
maySave
);

534 if(
t

ASN__ENCODE_FAILED
;

536 
buf
 +
maySave
 >> 3;

537 
size__bs
 -
maySave
;

538 
	`as
(!(
maySave
 & 0x07|| !
size__bs
);

539 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0))

540 
ASN__ENCODE_FAILED
;

541 } 
size__bs
);

543 
	`ASN__ENCODED_OK
(

);

544 
	}
}

548 
a_ndom_fl_su_t


549 
	$BIT_STRING_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

550 cڡ 
a_codg_cڡts_t
 *
cڡts
,

551 
size_t
 
max_ngth
) {

552 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 =

553 
td
->
ecifics
 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)td->specifics

554 : &
a_SPC_BIT_STRING_ecs
;

555 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

556 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

557 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

558 
ngths
[] = {0, 1, 2, 3, 4, 8,

561 
ut8_t
 *
buf
;

562 
ut8_t
 *
bd
;

563 
ut8_t
 *
b
;

564 
size_t
 
d_bs
, 
d_n
;

565 
BIT_STRING_t
 *

;

567 if(
max_ngth
 =0 
su_skd
;

569 
ecs
->
subv
) {

570 
ASN_OSUBV_ANY
:

571  
su_ed
;

572 
ASN_OSUBV_BIT
:

579 
d_bs
 = 
ngths
[
	`a_ndom_bwn
(

580 0, (
ngths
) / (lengths[0]) - 1)];

581 if(!
cڡts
 || !cڡts->
r_cڡts
)

582 
cڡts
 = &
td
->
codg_cڡts
;

583 if(
cڡts
->
r_cڡts
) {

584 cڡ 
a_r_cڡt_t
 *
pc
 = &
cڡts
->
r_cڡts
->
size
;

585 if(
pc
->
ags
 & 
APC_CONSTRAINED
) {

586 
suggeed_u_bound
 = 
pc
->
u_bound
 < (
ssize_t
)
max_ngth


587 ? 
pc
->
u_bound


588 : (
ssize_t
)
max_ngth
;

589 if(
max_ngth
 < (
size_t
)
pc
->
low_bound
) {

590  
su_skd
;

592 if(
pc
->
ags
 & 
APC_EXTENSIBLE
) {

593 
	`a_ndom_bwn
(0, 5)) {

595 if(
pc
->
low_bound
 > 0) {

596 
d_bs
 = 
pc
->
low_bound
 - 1;

601 
d_bs
 = 
pc
->
u_bound
 + 1;

605 if(
d_bs
 < 
max_ngth
) {

610 
d_bs
 = 
	`a_ndom_bwn
(
pc
->
low_bound
,

611 
suggeed_u_bound
);

614 
d_bs
 =

615 
	`a_ndom_bwn
(
pc
->
low_bound
, 
suggeed_u_bound
);

618 
d_bs
 = 
	`a_ndom_bwn
(0, 
max_ngth
 - 1);

620 } if(
d_bs
 >
max_ngth
) {

621 
d_bs
 = 
	`a_ndom_bwn
(0, 
max_ngth
 - 1);

624 
d_n
 = (
d_bs
 + 7) / 8;

625 
buf
 = 
	`CALLOC
(1, 
d_n
 + 1);

626 if(!
buf
 
su_ed
;

628 
bd
 = &
buf
[
d_n
];

630 
b
 = 
buf
; b < 
bd
; b++) {

631 *(
ut8_t
 *)
b
 = 
	`a_ndom_bwn
(0, 255);

633 *
b
 = 0;

635 if(*

) {

636 

 = *

;

637 
	`FREEMEM
(

->
buf
);

639 

 = (
BIT_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

640 if(!

) {

641 
	`FREEMEM
(
buf
);

642  
su_ed
;

646 

->
buf
 = buf;

647 

->
size
 = 
d_n
;

648 

->
bs_unud
 = (8 - (
d_bs
 & 0x7)) & 0x7;

649 if(

->
bs_unud
) {

650 
	`as
(

->
size
 > 0);

651 

->
buf
[->
size
-1] &0xf<< st->
bs_unud
;

654 
su_ok
.
ngth
 = 

->
size
;

655  
su_ok
;

656 
	}
}

	@BOOLEAN.c

5 
	~<a_.h
>

6 
	~<a_codecs_im.h
>

7 
	~<BOOLEAN.h
>

12 cڡ 
b_v_g_t
 
	ga_DEF_BOOLEAN_gs
[] = {

13 (
ASN_TAG_CLASS_UNIVERSAL
 | (1 << 2))

15 
a_TYPE_ݔi_t
 
	ga_OP_BOOLEAN
 = {

16 
BOOLEAN_
,

17 
BOOLEAN_t
,

18 
BOOLEAN_com
,

19 
BOOLEAN_decode_b
,

20 
BOOLEAN_code_d
,

21 
BOOLEAN_decode_x
,

22 
BOOLEAN_code_x
,

23 #ifdef 
ASN_DISABLE_OER_SUPPORT


27 
BOOLEAN_decode_r
,

28 
BOOLEAN_code_r
,

30 #ifdef 
ASN_DISABLE_PER_SUPPORT


36 
BOOLEAN_decode_ur
,

37 
BOOLEAN_code_ur
,

38 
BOOLEAN_decode_
,

39 
BOOLEAN_code_
,

41 
BOOLEAN_ndom_fl
,

44 
a_TYPE_dest_t
 
	ga_DEF_BOOLEAN
 = {

47 &
a_OP_BOOLEAN
,

48 
a_DEF_BOOLEAN_gs
,

49 (
a_DEF_BOOLEAN_gs
) / (asn_DEF_BOOLEAN_tags[0]),

50 
a_DEF_BOOLEAN_gs
,

51 (
a_DEF_BOOLEAN_gs
) / (asn_DEF_BOOLEAN_tags[0]),

52 { 0, 0, 
a_gic_no_cڡt
 },

60 
a_dec_rv_t


61 
	$BOOLEAN_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

62 cڡ 
a_TYPE_dest_t
 *
td
, **
bo_vue
,

63 cڡ *
buf_r
, 
size_t
 
size
, 
g_mode
) {

64 
BOOLEAN_t
 *

 = (BOOLEAN_*)*
bo_vue
;

65 
a_dec_rv_t
 
rv
;

66 
b_v_n_t
 
ngth
;

67 
b_v_n_t
 
lidx
;

69 if(

 =
NULL
) {

70 

 = (
BOOLEAN_t
 *)(*
bo_vue
 = 
	`CALLOC
(1, (*st)));

71 if(

 =
NULL
) {

72 
rv
.
code
 = 
RC_FAIL
;

73 
rv
.
csumed
 = 0;

74  
rv
;

78 
	`ASN_DEBUG
("Decoding %ss BOOLEAN (tm=%d)",

79 
td
->
me
, 
g_mode
);

84 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 0, 
buf_r
, 
size
,

85 
g_mode
, 0, &
ngth
, 0);

86 if(
rv
.
code
 !
RC_OK
)

87  
rv
;

89 
	`ASN_DEBUG
("Boޗngth i%d bys", ()
ngth
);

91 
buf_r
 = ((cڡ *)buf_r+ 
rv
.
csumed
;

92 
size
 -
rv
.
csumed
;

93 if(
ngth
 > (
b_v_n_t
)
size
) {

94 
rv
.
code
 = 
RC_WMORE
;

95 
rv
.
csumed
 = 0;

96  
rv
;

102 *

 = 0, 
lidx
 = 0;

103 (
lidx
 < 
ngth
&& *

 == 0;idx++) {

109 *

 |((cڡ 
ut8_t
 *)
buf_r
)[
lidx
];

112 
rv
.
code
 = 
RC_OK
;

113 
rv
.
csumed
 +
ngth
;

115 
	`ASN_DEBUG
("Took %ld/%ld bytesoncode %s, value=%d",

116 ()
rv
.
csumed
, ()
ngth
,

117 
td
->
me
, *

);

119  
rv
;

120 
	}
}

122 
a_c_rv_t


123 
	$BOOLEAN_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

124 
g_mode
, 
b_v_g_t
 
g
, 
a_p_csume_bys_f
 *
cb
,

125 *
p_key
) {

126 
a_c_rv_t
 
v
 = {0,0,0};

127 cڡ 
BOOLEAN_t
 *

 = (cڡ BOOLEAN_*)

;

129 
v
.
coded
 = 
	`d_wre_gs
(
td
, 1, 
g_mode
, 0, 
g
, 
cb
, 
p_key
);

130 if(
v
.
coded
 == -1) {

131 
v
.
ed_ty
 = 
td
;

132 
v
.
ruu_r
 = 

;

133  
v
;

136 if(
cb
) {

137 
ut8_t
 
bo_vue
;

139 
bo_vue
 = *

 ? 0xff : 0;

141 if(
	`cb
(&
bo_vue
, 1, 
p_key
) < 0) {

142 
v
.
coded
 = -1;

143 
v
.
ed_ty
 = 
td
;

144 
v
.
ruu_r
 = 

;

145  
v
;

149 
v
.
coded
 += 1;

151 
	`ASN__ENCODED_OK
(
v
);

152 
	}
}

158 
x_pbd_rv


159 
	$BOOLEAN__x_body_decode
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

160 cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

161 
BOOLEAN_t
 *

 = (BOOLEAN_*)

;

162 cڡ *
p
 = (cڡ *)
chunk_buf
;

164 ()
td
;

166 if(
chunk_size
 && 
p
[0] == 0x3c ) {

167 
	`x_check_g
(
chunk_buf
, 
chunk_size
, "false")) {

168 
XCT_BOTH
:

170 *

 = 0;

172 
XCT_UNKNOWN_BO
:

173 if(
	`x_check_g
(
chunk_buf
, 
chunk_size
, "true")

174 !
XCT_BOTH
)

175  
XPBD_BROKEN_ENCODING
;

177 *

 = 1;

180  
XPBD_BROKEN_ENCODING
;

182  
XPBD_BODY_CONSUMED
;

184  
XPBD_BROKEN_ENCODING
;

186 
	}
}

189 
a_dec_rv_t


190 
	$BOOLEAN_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

191 cڡ 
a_TYPE_dest_t
 *
td
, **

,

192 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

193  
	`x_decode_imive
(
t_codec_x
, 
td
,

194 

, (
BOOLEAN_t
), 
t_mme
, 
buf_r
, 
size
,

195 
BOOLEAN__x_body_decode
);

196 
	}
}

198 
a_c_rv_t


199 
	$BOOLEAN_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

200 
ev
, 
x_cod_ags_e
 
ags
,

201 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

202 cڡ 
BOOLEAN_t
 *

 = (cڡ BOOLEAN_*)

;

203 
a_c_rv_t
 

 = {0, 0, 0};

205 ()
ev
;

206 ()
ags
;

208 if(!


ASN__ENCODE_FAILED
;

210 if(*

) {

211 
	`ASN__CALLBACK
("<true/>", 7);

213 
	`ASN__CALLBACK
("<false/>", 8);

216 
	`ASN__ENCODED_OK
(

);

217 
cb_ed
:

218 
ASN__ENCODE_FAILED
;

219 
	}
}

222 
	$BOOLEAN_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

223 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

224 cڡ 
BOOLEAN_t
 *

 = (cڡ BOOLEAN_*)

;

225 cڡ *
buf
;

226 
size_t
 
bu
;

228 ()
td
;

229 ()
ev
;

231 if(

) {

232 if(*

) {

233 
buf
 = "TRUE";

234 
bu
 = 4;

236 
buf
 = "FALSE";

237 
bu
 = 5;

240 
buf
 = "<absent>";

241 
bu
 = 8;

244  (
	`cb
(
buf
, 
bu
, 
p_key
) < 0) ? -1 : 0;

245 
	}
}

248 
	$BOOLEAN_
(cڡ 
a_TYPE_dest_t
 *
td
, *
r
,

249 
a_ru__mhod
 
mhod
) {

250 if(
td
 && 
r
) {

251 
mhod
) {

252 
ASFM_FREE_EVERYTHING
:

253 
	`FREEMEM
(
r
);

255 
ASFM_FREE_UNDERLYING
:

257 
ASFM_FREE_UNDERLYING_AND_RESET
:

258 
	`memt
(
r
, 0, (
BOOLEAN_t
));

262 
	}
}

264 #ide
ASN_DISABLE_PER_SUPPORT


266 
a_dec_rv_t


267 
	$BOOLEAN_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

268 cڡ 
a_TYPE_dest_t
 *
td
,

269 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

270 
a_r_da_t
 *
pd
) {

271 
a_dec_rv_t
 
rv
;

272 
BOOLEAN_t
 *

 = (BOOLEAN_*)*

;

274 ()
t_codec_x
;

275 ()
td
;

276 ()
cڡts
;

278 if(!

) {

279 

 = (
BOOLEAN_t
 *)(*

 = 
	`MALLOC
((*st)));

280 if(!


ASN__DECODE_FAILED
;

286 
	`r_g_w_bs
(
pd
, 1)) {

287 1: *

 = 1; ;

288 0: *

 = 0; ;

289 -1: : 
ASN__DECODE_STARVED
;

292 
	`ASN_DEBUG
("%decoded%s", 
td
->
me
, *

 ? "TRUE" : "FALSE");

294 
rv
.
code
 = 
RC_OK
;

295 
rv
.
csumed
 = 1;

296  
rv
;

297 
	}
}

300 
a_c_rv_t


301 
	$BOOLEAN_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

302 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

303 
a_r_ou_t
 *
po
) {

304 cڡ 
BOOLEAN_t
 *

 = (cڡ BOOLEAN_*)

;

305 
a_c_rv_t
 

 = { 0, 0, 0 };

307 ()
cڡts
;

309 if(!


ASN__ENCODE_FAILED
;

311 if(
	`r_put_w_bs
(
po
, *

 ? 1 : 0, 1))

312 
ASN__ENCODE_FAILED
;

314 
	`ASN__ENCODED_OK
(

);

315 
	}
}

317 
a_dec_rv_t


318 
	$BOOLEAN_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
, cڡ 
a_TYPE_dest_t
 *
td
,

319 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

320 
a_dec_rv_t
 
rv
;

321 
BOOLEAN_t
 *

 = (BOOLEAN_*)*

;

323 ()
t_codec_x
;

324 ()
cڡts
;

325 ()
td
;

327 if(!

) {

328 

 = (
BOOLEAN_t
 *)(*

 = 
	`MALLOC
((*st)));

329 if(!


ASN__DECODE_FAILED
;

335 
	`r_g_w_bs
(
pd
, 1)) {

337 *

 = 1;

340 *

 = 0;

344 
ASN__DECODE_STARVED
;

347 
	`ASN_DEBUG
("%decoded%s", 
td
->
me
, *

 ? "TRUE" : "FALSE");

349 
rv
.
code
 = 
RC_OK
;

350 
rv
.
csumed
 = 1;

351  
rv
;

352 
	}
}

354 
a_c_rv_t


355 
	$BOOLEAN_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

356 cڡ 
a_r_cڡts_t
 *
cڡts
,

357 cڡ *

, 
a_r_ou_t
 *
po
) {

358 cڡ 
BOOLEAN_t
 *

 = (cڡ BOOLEAN_*)

;

359 
a_c_rv_t
 

 = { 0, 0, 0 };

361 ()
cڡts
;

363 if(!


ASN__ENCODE_FAILED
;

365 if(
	`r_put_w_bs
(
po
, *

 ? 1 : 0, 1))

366 
ASN__ENCODE_FAILED
;

368 
	`ASN__ENCODED_OK
(

);

369 
	}
}

373 #ide 
ASN_DISABLE_OER_SUPPORT


378 
a_c_rv_t


379 
	$BOOLEAN_code_r
(cڡ 
a_TYPE_dest_t
 *
td
,

380 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

381 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

382 
a_c_rv_t
 

 = { 1, 0, 0 };

383 cڡ 
BOOLEAN_t
 *

 = 

;

384 
ut8_t
 
bo_vue
 = *

 ? 0xff : 0;

386 ()
td
;

387 ()
cڡts
;

389 if(
	`cb
(&
bo_vue
, 1, 
p_key
) < 0) {

390 
ASN__ENCODE_FAILED
;

392 
	`ASN__ENCODED_OK
(

);

394 
	}
}

396 
a_dec_rv_t


397 
	$BOOLEAN_decode_r
(cڡ 
a_codec_x_t
 *
t_codec_x
,

398 cڡ 
a_TYPE_dest_t
 *
td
,

399 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

400 cڡ *
r
, 
size_t
 
size
) {

401 
a_dec_rv_t
 
ok
 = {
RC_OK
, 1};

402 
BOOLEAN_t
 *

;

404 ()
t_codec_x
;

405 ()
td
;

406 ()
cڡts
;

408 if(
size
 < 1) {

409 
ASN__DECODE_STARVED
;

412 if(!(

 = *

)) {

413 

 = (
BOOLEAN_t
 *)(*

 = 
	`CALLOC
(1, (*st)));

414 if(!


ASN__DECODE_FAILED
;

417 *

 = *(cڡ 
ut8_t
 *)
r
;

419  
ok
;

420 
	}
}

427 
	$BOOLEAN_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

428 cڡ *
br
) {

429 cڡ 
BOOLEAN_t
 *
a
 = 

;

430 cڡ 
BOOLEAN_t
 *
b
 = 
br
;

432 ()
td
;

434 if(
a
 && 
b
) {

435 if(!*
a
 =!*
b
) {

437 } if(!*
a
) {

442 } if(!
a
) {

447 
	}
}

449 
a_ndom_fl_su_t


450 
	$BOOLEAN_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

451 cڡ 
a_codg_cڡts_t
 *
cڡts
,

452 
size_t
 
max_ngth
) {

453 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

454 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

455 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

456 
BOOLEAN_t
 *

 = *

;

458 if(
max_ngth
 =0 
su_skd
;

460 if(

 =
NULL
) {

461 

 = (
BOOLEAN_t
 *)(*

 = 
	`CALLOC
(1, (*st)));

462 if(

 =
NULL
) {

463  
su_ed
;

467 if(!
cڡts
 || !cڡts->
r_cڡts
)

468 
cڡts
 = &
td
->
codg_cڡts
;

469 if(
cڡts
->
r_cڡts
) {

470 cڡ 
a_r_cڡt_t
 *
pc
 = &
cڡts
->
r_cڡts
->
vue
;

471 if(
pc
->
ags
 & 
APC_CONSTRAINED
) {

472 *

 = 
	`a_ndom_bwn
(
pc
->
low_bound
,c->
u_bound
);

473  
su_ok
;

478 
	`a_ndom_bwn
(0, 7)) {

482 *

 = 0; ;

483 3: *

 = -1; ;

484 4: *

 = 1; ;

485 5: *

 = 
INT_MIN
; ;

486 6: *

 = 
INT_MAX
; ;

488 *

 = 
	`a_ndom_bwn
(
INT_MIN
, 
INT_MAX
);

491  
su_ok
;

492 
	}
}

	@CGI.c

8 
	~"CGI.h
"

10 
	~"NR-CGI.h
"

11 
	~"EUTRA-CGI.h
"

12 
a_r_cڡts_t
 
a_PER_ty_CGI_cڡr_1
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_CGI_1
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
CGI
, 
choi
.
nR_CGI
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_NR_CGI
,

27 { 
ATF_POINTER
, 0, 
offtof
(
CGI
, 
choi
.
eUTRA_CGI
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_EUTRA_CGI
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_CGI_g2_1
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_CGI_ecs_1
 = {

42 (
CGI
),

43 
offtof
(
CGI
, 
_a_x
),

44 
offtof
(
CGI
, 
e
),

45 (((
CGI
 *)0)->
e
),

46 
a_MAP_CGI_g2_1
,

51 
a_TYPE_dest_t
 
	ga_DEF_CGI
 = {

54 &
a_OP_CHOICE
,

59 { 0, &
a_PER_ty_CGI_cڡr_1
, 
CHOICE_cڡt
 },

60 
a_MBR_CGI_1
,

62 &
a_SPC_CGI_ecs_1


	@CoreCPID.c

8 
	~"CeCPID.h
"

10 
	~"GUAMI.h
"

11 
	~"GUMMEI.h
"

12 
a_r_cڡts_t
 
a_PER_ty_CeCPID_cڡr_1
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_CeCPID_1
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
CeCPID
, 
choi
.
fiveGC
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_GUAMI
,

27 { 
ATF_POINTER
, 0, 
offtof
(
CeCPID
, 
choi
.
ePC
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_GUMMEI
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_CeCPID_g2_1
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_CeCPID_ecs_1
 = {

42 (
CeCPID
),

43 
offtof
(
CeCPID
, 
_a_x
),

44 
offtof
(
CeCPID
, 
e
),

45 (((
CeCPID
 *)0)->
e
),

46 
a_MAP_CeCPID_g2_1
,

51 
a_TYPE_dest_t
 
	ga_DEF_CeCPID
 = {

54 &
a_OP_CHOICE
,

59 { 0, &
a_PER_ty_CeCPID_cڡr_1
, 
CHOICE_cڡt
 },

60 
a_MBR_CeCPID_1
,

62 &
a_SPC_CeCPID_ecs_1


	@E-UTRA-ARFCN.c

8 
	~"E-UTRA-ARFCN.h
"

11 
	$E_UTRA_ARFCN_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 65535)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_E_UTRA_ARFCN_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 16, 16, 0, 65535 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_E_UTRA_ARFCN_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_E_UTRA_ARFCN
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_E_UTRA_ARFCN_gs_1
,

52 (
a_DEF_E_UTRA_ARFCN_gs_1
)

53 /(
a_DEF_E_UTRA_ARFCN_gs_1
[0]),

54 
a_DEF_E_UTRA_ARFCN_gs_1
,

55 (
a_DEF_E_UTRA_ARFCN_gs_1
)

56 /(
a_DEF_E_UTRA_ARFCN_gs_1
[0]),

57 { 0, &
a_PER_ty_E_UTRA_ARFCN_cڡr_1
, 
E_UTRA_ARFCN_cڡt
 },

	@E-UTRA-PCI.c

8 
	~"E-UTRA-PCI.h
"

11 
	$E_UTRA_PCI_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 503)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_E_UTRA_PCI_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 9, 9, 0, 503 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_E_UTRA_PCI_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_E_UTRA_PCI
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_E_UTRA_PCI_gs_1
,

52 (
a_DEF_E_UTRA_PCI_gs_1
)

53 /(
a_DEF_E_UTRA_PCI_gs_1
[0]),

54 
a_DEF_E_UTRA_PCI_gs_1
,

55 (
a_DEF_E_UTRA_PCI_gs_1
)

56 /(
a_DEF_E_UTRA_PCI_gs_1
[0]),

57 { 0, &
a_PER_ty_E_UTRA_PCI_cڡr_1
, 
E_UTRA_PCI_cڡt
 },

	@E-UTRA-TAC.c

8 
	~"E-UTRA-TAC.h
"

11 
	$E_UTRA_TAC_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 2)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_E_UTRA_TAC_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 2, 2 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_E_UTRA_TAC_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_E_UTRA_TAC
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_E_UTRA_TAC_gs_1
,

53 (
a_DEF_E_UTRA_TAC_gs_1
)

54 /(
a_DEF_E_UTRA_TAC_gs_1
[0]),

55 
a_DEF_E_UTRA_TAC_gs_1
,

56 (
a_DEF_E_UTRA_TAC_gs_1
)

57 /(
a_DEF_E_UTRA_TAC_gs_1
[0]),

58 { 0, &
a_PER_ty_E_UTRA_TAC_cڡr_1
, 
E_UTRA_TAC_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@E2SM-KPM-ActionDefinition-Format1.c

8 
	~"E2SM-KPM-AiDefi-Fm1.h
"

10 
	~"CGI.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_AiDefi_Fm1_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm1
, 
msInfoLi
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_MsumtInfoLi
,

21 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm1
, 
gnulPiod
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_GnuryPiod
,

30 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_AiDefi_Fm1
, 
GlobID
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_CGI
,

40 cڡ 
	ga_MAP_E2SM_KPM_AiDefi_Fm1_oms_1
[] = { 2 };

41 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
[] = {

42 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

44 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_AiDefi_Fm1_g2_1
[] = {

45 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

47 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

49 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_AiDefi_Fm1_ecs_1
 = {

50 (
E2SM_KPM_AiDefi_Fm1
),

51 
offtof
(
E2SM_KPM_AiDefi_Fm1
, 
_a_x
),

52 
a_MAP_E2SM_KPM_AiDefi_Fm1_g2_1
,

54 
a_MAP_E2SM_KPM_AiDefi_Fm1_oms_1
,

58 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm1
 = {

61 &
a_OP_SEQUENCE
,

62 
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
,

63 (
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
)

64 /(
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
[0]),

65 
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
,

66 (
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
)

67 /(
a_DEF_E2SM_KPM_AiDefi_Fm1_gs_1
[0]),

68 { 0, 0, 
SEQUENCE_cڡt
 },

69 
a_MBR_E2SM_KPM_AiDefi_Fm1_1
,

71 &
a_SPC_E2SM_KPM_AiDefi_Fm1_ecs_1


	@E2SM-KPM-ActionDefinition-Format2.c

8 
	~"E2SM-KPM-AiDefi-Fm2.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_AiDefi_Fm2_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm2
, 
ueID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_UEID
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm2
, 
substInfo
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_E2SM_KPM_AiDefi_Fm1
,

30 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_AiDefi_Fm2_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_AiDefi_Fm2_ecs_1
 = {

38 (
E2SM_KPM_AiDefi_Fm2
),

39 
offtof
(
E2SM_KPM_AiDefi_Fm2
, 
_a_x
),

40 
a_MAP_E2SM_KPM_AiDefi_Fm2_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm2
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
,

50 (
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
)

51 /(
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
[0]),

52 
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
,

53 (
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
)

54 /(
a_DEF_E2SM_KPM_AiDefi_Fm2_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_E2SM_KPM_AiDefi_Fm2_1
,

58 &
a_SPC_E2SM_KPM_AiDefi_Fm2_ecs_1


	@E2SM-KPM-ActionDefinition-Format3.c

8 
	~"E2SM-KPM-AiDefi-Fm3.h
"

10 
	~"CGI.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_AiDefi_Fm3_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm3
, 
msCdLi
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_MsumtCdLi
,

21 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi_Fm3
, 
gnulPiod
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_GnuryPiod
,

30 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_AiDefi_Fm3
, 
GlobID
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_CGI
,

40 cڡ 
	ga_MAP_E2SM_KPM_AiDefi_Fm3_oms_1
[] = { 2 };

41 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
[] = {

42 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

44 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_AiDefi_Fm3_g2_1
[] = {

45 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

47 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

49 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_AiDefi_Fm3_ecs_1
 = {

50 (
E2SM_KPM_AiDefi_Fm3
),

51 
offtof
(
E2SM_KPM_AiDefi_Fm3
, 
_a_x
),

52 
a_MAP_E2SM_KPM_AiDefi_Fm3_g2_1
,

54 
a_MAP_E2SM_KPM_AiDefi_Fm3_oms_1
,

58 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_AiDefi_Fm3
 = {

61 &
a_OP_SEQUENCE
,

62 
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
,

63 (
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
)

64 /(
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
[0]),

65 
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
,

66 (
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
)

67 /(
a_DEF_E2SM_KPM_AiDefi_Fm3_gs_1
[0]),

68 { 0, 0, 
SEQUENCE_cڡt
 },

69 
a_MBR_E2SM_KPM_AiDefi_Fm3_1
,

71 &
a_SPC_E2SM_KPM_AiDefi_Fm3_ecs_1


	@E2SM-KPM-ActionDefinition.c

8 
	~"E2SM-KPM-AiDefi.h
"

10 
	~"E2SM-KPM-AiDefi-Fm1.h
"

11 
	~"E2SM-KPM-AiDefi-Fm2.h
"

12 
	~"E2SM-KPM-AiDefi-Fm3.h
"

13 
a_r_cڡts_t
 
a_PER_ty_aiDefi_fms_cڡr_3
 
	gCC_NOTUSED
 = {

14 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 2, 2, 0, 2 } ,

15 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

18 
a_TYPE_memb_t
 
	ga_MBR_aiDefi_fms_3
[] = {

19 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_AiDefi__aiDefi_fms
, 
choi
.
aiDefi_Fm1
),

20 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

22 &
a_DEF_E2SM_KPM_AiDefi_Fm1
,

28 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_AiDefi__aiDefi_fms
, 
choi
.
aiDefi_Fm2
),

29 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

31 &
a_DEF_E2SM_KPM_AiDefi_Fm2
,

37 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_AiDefi__aiDefi_fms
, 
choi
.
aiDefi_Fm3
),

38 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

40 &
a_DEF_E2SM_KPM_AiDefi_Fm3
,

47 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_aiDefi_fms_g2_3
[] = {

48 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

49 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

50 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

52 
a_CHOICE_ecifics_t
 
	ga_SPC_aiDefi_fms_ecs_3
 = {

53 (
E2SM_KPM_AiDefi__aiDefi_fms
),

54 
offtof
(
E2SM_KPM_AiDefi__aiDefi_fms
, 
_a_x
),

55 
offtof
(
E2SM_KPM_AiDefi__aiDefi_fms
, 
e
),

56 (((
E2SM_KPM_AiDefi__aiDefi_fms
 *)0)->
e
),

57 
a_MAP_aiDefi_fms_g2_3
,

63 
a_TYPE_dest_t
 
	ga_DEF_aiDefi_fms_3
 = {

66 &
a_OP_CHOICE
,

71 { 0, &
a_PER_ty_aiDefi_fms_cڡr_3
, 
CHOICE_cڡt
 },

72 
a_MBR_aiDefi_fms_3
,

74 &
a_SPC_aiDefi_fms_ecs_3


77 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_AiDefi_1
[] = {

78 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi
, 
ric_Sty_Ty
),

79 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

81 &
a_DEF_RIC_Sty_Ty
,

87 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_AiDefi
, 
aiDefi_fms
),

88 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

90 &
a_DEF_aiDefi_fms_3
,

97 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_AiDefi_gs_1
[] = {

98 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

100 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_AiDefi_g2_1
[] = {

101 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

102 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

104 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_AiDefi_ecs_1
 = {

105 (
E2SM_KPM_AiDefi
),

106 
offtof
(
E2SM_KPM_AiDefi
, 
_a_x
),

107 
a_MAP_E2SM_KPM_AiDefi_g2_1
,

112 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_AiDefi
 = {

115 &
a_OP_SEQUENCE
,

116 
a_DEF_E2SM_KPM_AiDefi_gs_1
,

117 (
a_DEF_E2SM_KPM_AiDefi_gs_1
)

118 /(
a_DEF_E2SM_KPM_AiDefi_gs_1
[0]),

119 
a_DEF_E2SM_KPM_AiDefi_gs_1
,

120 (
a_DEF_E2SM_KPM_AiDefi_gs_1
)

121 /(
a_DEF_E2SM_KPM_AiDefi_gs_1
[0]),

122 { 0, 0, 
SEQUENCE_cڡt
 },

123 
a_MBR_E2SM_KPM_AiDefi_1
,

125 &
a_SPC_E2SM_KPM_AiDefi_ecs_1


	@E2SM-KPM-EventTriggerDefinition-Format1.c

8 
	~"E2SM-KPM-EvtTriggDefi-Fm1.h
"

11 
	$ptgPiod_2_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 4294967295)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

40 
	$memb_ptgPiod_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

41 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

42 
vue
;

44 if(!

) {

45 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

47 
td
->
me
, 
__FILE__
, 
__LINE__
);

51 
vue
 = *(cڡ *)

;

53 if((
vue
 >= 1 && value <= 4294967295)) {

57 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

59 
td
->
me
, 
__FILE__
, 
__LINE__
);

62 
	}
}

64 
a_r_cڡts_t
 
a_PER_ty_ptgPiod_cڡr_2
 
	gCC_NOTUSED
 = {

65 { 
APC_CONSTRAINED
, 32, -1, 1, 4294967295 } ,

66 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

69 
a_r_cڡts_t
 
a_PER_memb_ptgPiod_cڡr_2
 
	gCC_NOTUSED
 = {

70 { 
APC_CONSTRAINED
, 32, -1, 1, 4294967295 } ,

71 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

74 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_ptgPiod_ecs_2
 = {

79 cڡ 
b_v_g_t
 
	ga_DEF_ptgPiod_gs_2
[] = {

80 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

81 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

84 
a_TYPE_dest_t
 
	ga_DEF_ptgPiod_2
 = {

87 &
a_OP_NiveIeg
,

88 
a_DEF_ptgPiod_gs_2
,

89 (
a_DEF_ptgPiod_gs_2
)

90 /(
a_DEF_ptgPiod_gs_2
[0]) - 1,

91 
a_DEF_ptgPiod_gs_2
,

92 (
a_DEF_ptgPiod_gs_2
)

93 /(
a_DEF_ptgPiod_gs_2
[0]),

94 { 0, &
a_PER_ty_ptgPiod_cڡr_2
, 
ptgPiod_2_cڡt
 },

96 &
a_SPC_ptgPiod_ecs_2


99 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_EvtTriggDefi_Fm1_1
[] = {

100 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_EvtTriggDefi_Fm1
, 
ptgPiod
),

101 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

103 &
a_DEF_ptgPiod_2
,

105 { 0, &
a_PER_memb_ptgPiod_cڡr_2
, 
memb_ptgPiod_cڡt_1
 },

110 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
[] = {

111 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

113 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_EvtTriggDefi_Fm1_g2_1
[] = {

114 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

116 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_EvtTriggDefi_Fm1_ecs_1
 = {

117 (
E2SM_KPM_EvtTriggDefi_Fm1
),

118 
offtof
(
E2SM_KPM_EvtTriggDefi_Fm1
, 
_a_x
),

119 
a_MAP_E2SM_KPM_EvtTriggDefi_Fm1_g2_1
,

124 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_EvtTriggDefi_Fm1
 = {

127 &
a_OP_SEQUENCE
,

128 
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
,

129 (
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
)

130 /(
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
[0]),

131 
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
,

132 (
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
)

133 /(
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1_gs_1
[0]),

134 { 0, 0, 
SEQUENCE_cڡt
 },

135 
a_MBR_E2SM_KPM_EvtTriggDefi_Fm1_1
,

137 &
a_SPC_E2SM_KPM_EvtTriggDefi_Fm1_ecs_1


	@E2SM-KPM-EventTriggerDefinition.c

8 
	~"E2SM-KPM-EvtTriggDefi.h
"

10 
	~"E2SM-KPM-EvtTriggDefi-Fm1.h
"

11 
a_r_cڡts_t
 
a_PER_ty_evtDefi_fms_cڡr_2
 
	gCC_NOTUSED
 = {

12 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

13 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

16 
a_TYPE_memb_t
 
	ga_MBR_evtDefi_fms_2
[] = {

17 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_EvtTriggDefi__evtDefi_fms
, 
choi
.
evtDefi_Fm1
),

18 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

20 &
a_DEF_E2SM_KPM_EvtTriggDefi_Fm1
,

27 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_evtDefi_fms_g2_2
[] = {

28 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

30 
a_CHOICE_ecifics_t
 
	ga_SPC_evtDefi_fms_ecs_2
 = {

31 (
E2SM_KPM_EvtTriggDefi__evtDefi_fms
),

32 
offtof
(
E2SM_KPM_EvtTriggDefi__evtDefi_fms
, 
_a_x
),

33 
offtof
(
E2SM_KPM_EvtTriggDefi__evtDefi_fms
, 
e
),

34 (((
E2SM_KPM_EvtTriggDefi__evtDefi_fms
 *)0)->
e
),

35 
a_MAP_evtDefi_fms_g2_2
,

41 
a_TYPE_dest_t
 
	ga_DEF_evtDefi_fms_2
 = {

44 &
a_OP_CHOICE
,

49 { 0, &
a_PER_ty_evtDefi_fms_cڡr_2
, 
CHOICE_cڡt
 },

50 
a_MBR_evtDefi_fms_2
,

52 &
a_SPC_evtDefi_fms_ecs_2


55 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_EvtTriggDefi_1
[] = {

56 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_EvtTriggDefi
, 
evtDefi_fms
),

57 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

59 &
a_DEF_evtDefi_fms_2
,

66 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_EvtTriggDefi_gs_1
[] = {

67 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

69 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_EvtTriggDefi_g2_1
[] = {

70 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

72 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_EvtTriggDefi_ecs_1
 = {

73 (
E2SM_KPM_EvtTriggDefi
),

74 
offtof
(
E2SM_KPM_EvtTriggDefi
, 
_a_x
),

75 
a_MAP_E2SM_KPM_EvtTriggDefi_g2_1
,

80 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_EvtTriggDefi
 = {

83 &
a_OP_SEQUENCE
,

84 
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
,

85 (
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
)

86 /(
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
[0]),

87 
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
,

88 (
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
)

89 /(
a_DEF_E2SM_KPM_EvtTriggDefi_gs_1
[0]),

90 { 0, 0, 
SEQUENCE_cڡt
 },

91 
a_MBR_E2SM_KPM_EvtTriggDefi_1
,

93 &
a_SPC_E2SM_KPM_EvtTriggDefi_ecs_1


	@E2SM-KPM-IndicationHeader-Format1.c

8 
	~"E2SM-KPM-InditiHd-Fm1.h
"

10 cڡ 
	grmd_phab_b_3
[256] = {

20 cڡ 
	grmd_phab_code2vue_3
[74] = {

28 
	$check_rmd_phab_3
(cڡ *

) {

29 cڡ *
b
 = 
rmd_phab_b_3
;

31 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

32 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

33 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

35 ; 
ch
 < 
d
; ch++) {

36 
ut8_t
 
cv
 = *
ch
;

37 if(!
b
[
cv
])  -1;

40 
	}
}

42 cڡ 
	grmd_phab_b_4
[256] = {

52 cڡ 
	grmd_phab_code2vue_4
[74] = {

60 
	$check_rmd_phab_4
(cڡ *

) {

61 cڡ *
b
 = 
rmd_phab_b_4
;

63 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

64 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

65 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

67 ; 
ch
 < 
d
; ch++) {

68 
ut8_t
 
cv
 = *
ch
;

69 if(!
b
[
cv
])  -1;

72 
	}
}

74 cڡ 
	grmd_phab_b_5
[256] = {

84 cڡ 
	grmd_phab_code2vue_5
[74] = {

92 
	$check_rmd_phab_5
(cڡ *

) {

93 cڡ *
b
 = 
rmd_phab_b_5
;

95 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

96 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

97 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

99 ; 
ch
 < 
d
; ch++) {

100 
ut8_t
 
cv
 = *
ch
;

101 if(!
b
[
cv
])  -1;

104 
	}
}

106 cڡ 
	grmd_phab_b_6
[256] = {

116 cڡ 
	grmd_phab_code2vue_6
[74] = {

124 
	$check_rmd_phab_6
(cڡ *

) {

125 cڡ *
b
 = 
rmd_phab_b_6
;

127 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

128 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

129 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

131 ; 
ch
 < 
d
; ch++) {

132 
ut8_t
 
cv
 = *
ch
;

133 if(!
b
[
cv
])  -1;

136 
	}
}

139 
	$memb_feFmvsi_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

140 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

141 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

142 
size_t
 
size
;

144 if(!

) {

145 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

147 
td
->
me
, 
__FILE__
, 
__LINE__
);

151 
size
 = 

->size;

153 if((
size
 <= 15)

154 && !
	`check_rmd_phab_3
(

)) {

158 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

160 
td
->
me
, 
__FILE__
, 
__LINE__
);

163 
	}
}

165 
	$a_PER_MAP_feFmvsi_3_v2c
(
vue
) {

166 if(
vue
 >(
rmd_phab_b_3
)/(permitted_alphabet_table_3[0]))

168  
rmd_phab_b_3
[
vue
] - 1;

169 
	}
}

170 
	$a_PER_MAP_feFmvsi_3_c2v
(
code
) {

171 if(
code
 >(
rmd_phab_code2vue_3
)/(permitted_alphabet_code2value_3[0]))

173  
rmd_phab_code2vue_3
[
code
];

174 
	}
}

176 
	$memb_ndName_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

177 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

178 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

179 
size_t
 
size
;

181 if(!

) {

182 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

184 
td
->
me
, 
__FILE__
, 
__LINE__
);

188 
size
 = 

->size;

190 if((
size
 <= 400)

191 && !
	`check_rmd_phab_4
(

)) {

195 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

197 
td
->
me
, 
__FILE__
, 
__LINE__
);

200 
	}
}

202 
	$a_PER_MAP_ndName_4_v2c
(
vue
) {

203 if(
vue
 >(
rmd_phab_b_4
)/(permitted_alphabet_table_4[0]))

205  
rmd_phab_b_4
[
vue
] - 1;

206 
	}
}

207 
	$a_PER_MAP_ndName_4_c2v
(
code
) {

208 if(
code
 >(
rmd_phab_code2vue_4
)/(permitted_alphabet_code2value_4[0]))

210  
rmd_phab_code2vue_4
[
code
];

211 
	}
}

213 
	$memb_ndTy_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

214 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

215 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

216 
size_t
 
size
;

218 if(!

) {

219 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

221 
td
->
me
, 
__FILE__
, 
__LINE__
);

225 
size
 = 

->size;

227 if((
size
 <= 8)

228 && !
	`check_rmd_phab_5
(

)) {

232 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

234 
td
->
me
, 
__FILE__
, 
__LINE__
);

237 
	}
}

239 
	$a_PER_MAP_ndTy_5_v2c
(
vue
) {

240 if(
vue
 >(
rmd_phab_b_5
)/(permitted_alphabet_table_5[0]))

242  
rmd_phab_b_5
[
vue
] - 1;

243 
	}
}

244 
	$a_PER_MAP_ndTy_5_c2v
(
code
) {

245 if(
code
 >(
rmd_phab_code2vue_5
)/(permitted_alphabet_code2value_5[0]))

247  
rmd_phab_code2vue_5
[
code
];

248 
	}
}

250 
	$memb_vdName_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

251 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

252 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

253 
size_t
 
size
;

255 if(!

) {

256 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

258 
td
->
me
, 
__FILE__
, 
__LINE__
);

262 
size
 = 

->size;

264 if((
size
 <= 32)

265 && !
	`check_rmd_phab_6
(

)) {

269 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

271 
td
->
me
, 
__FILE__
, 
__LINE__
);

274 
	}
}

276 
	$a_PER_MAP_vdName_6_v2c
(
vue
) {

277 if(
vue
 >(
rmd_phab_b_6
)/(permitted_alphabet_table_6[0]))

279  
rmd_phab_b_6
[
vue
] - 1;

280 
	}
}

281 
	$a_PER_MAP_vdName_6_c2v
(
code
) {

282 if(
code
 >(
rmd_phab_code2vue_6
)/(permitted_alphabet_code2value_6[0]))

284  
rmd_phab_code2vue_6
[
code
];

285 
	}
}

286 
a_r_cڡts_t
 
a_PER_memb_feFmvsi_cڡr_3
 
	gCC_NOTUSED
 = {

287 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

288 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 4, 4, 0, 15 } ,

289 
a_PER_MAP_feFmvsi_3_v2c
,

290 
a_PER_MAP_feFmvsi_3_c2v


292 
a_r_cڡts_t
 
a_PER_memb_ndName_cڡr_4
 
	gCC_NOTUSED
 = {

293 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

294 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 9, 9, 0, 400 } ,

295 
a_PER_MAP_ndName_4_v2c
,

296 
a_PER_MAP_ndName_4_c2v


298 
a_r_cڡts_t
 
a_PER_memb_ndTy_cڡr_5
 
	gCC_NOTUSED
 = {

299 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

300 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 4, 4, 0, 8 } ,

301 
a_PER_MAP_ndTy_5_v2c
,

302 
a_PER_MAP_ndTy_5_c2v


304 
a_r_cڡts_t
 
a_PER_memb_vdName_cڡr_6
 
	gCC_NOTUSED
 = {

305 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

306 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 6, 6, 0, 32 } ,

307 
a_PER_MAP_vdName_6_v2c
,

308 
a_PER_MAP_vdName_6_c2v


310 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_InditiHd_Fm1_1
[] = {

311 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
ctSTime
),

312 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

314 &
a_DEF_TimeSmp
,

320 { 
ATF_POINTER
, 4, 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
feFmvsi
),

321 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

323 &
a_DEF_PrbSg
,

325 { 0, &
a_PER_memb_feFmvsi_cڡr_3
, 
memb_feFmvsi_cڡt_1
 },

329 { 
ATF_POINTER
, 3, 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
ndName
),

330 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

332 &
a_DEF_PrbSg
,

334 { 0, &
a_PER_memb_ndName_cڡr_4
, 
memb_ndName_cڡt_1
 },

338 { 
ATF_POINTER
, 2, 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
ndTy
),

339 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

341 &
a_DEF_PrbSg
,

343 { 0, &
a_PER_memb_ndTy_cڡr_5
, 
memb_ndTy_cڡt_1
 },

347 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
vdName
),

348 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

350 &
a_DEF_PrbSg
,

352 { 0, &
a_PER_memb_vdName_cڡr_6
, 
memb_vdName_cڡt_1
 },

357 cڡ 
	ga_MAP_E2SM_KPM_InditiHd_Fm1_oms_1
[] = { 1, 2, 3, 4 };

358 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
[] = {

359 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

361 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_InditiHd_Fm1_g2_1
[] = {

362 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

363 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

364 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

365 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

366 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 }

368 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_InditiHd_Fm1_ecs_1
 = {

369 (
E2SM_KPM_InditiHd_Fm1
),

370 
offtof
(
E2SM_KPM_InditiHd_Fm1
, 
_a_x
),

371 
a_MAP_E2SM_KPM_InditiHd_Fm1_g2_1
,

373 
a_MAP_E2SM_KPM_InditiHd_Fm1_oms_1
,

377 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_InditiHd_Fm1
 = {

380 &
a_OP_SEQUENCE
,

381 
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
,

382 (
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
)

383 /(
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
[0]),

384 
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
,

385 (
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
)

386 /(
a_DEF_E2SM_KPM_InditiHd_Fm1_gs_1
[0]),

387 { 0, 0, 
SEQUENCE_cڡt
 },

388 
a_MBR_E2SM_KPM_InditiHd_Fm1_1
,

390 &
a_SPC_E2SM_KPM_InditiHd_Fm1_ecs_1


	@E2SM-KPM-IndicationHeader.c

8 
	~"E2SM-KPM-InditiHd.h
"

10 
	~"E2SM-KPM-InditiHd-Fm1.h
"

11 
a_r_cڡts_t
 
a_PER_ty_ditiHd_fms_cڡr_2
 
	gCC_NOTUSED
 = {

12 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

13 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

16 
a_TYPE_memb_t
 
	ga_MBR_ditiHd_fms_2
[] = {

17 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_InditiHd__ditiHd_fms
, 
choi
.
ditiHd_Fm1
),

18 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

20 &
a_DEF_E2SM_KPM_InditiHd_Fm1
,

27 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_ditiHd_fms_g2_2
[] = {

28 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

30 
a_CHOICE_ecifics_t
 
	ga_SPC_ditiHd_fms_ecs_2
 = {

31 (
E2SM_KPM_InditiHd__ditiHd_fms
),

32 
offtof
(
E2SM_KPM_InditiHd__ditiHd_fms
, 
_a_x
),

33 
offtof
(
E2SM_KPM_InditiHd__ditiHd_fms
, 
e
),

34 (((
E2SM_KPM_InditiHd__ditiHd_fms
 *)0)->
e
),

35 
a_MAP_ditiHd_fms_g2_2
,

41 
a_TYPE_dest_t
 
	ga_DEF_ditiHd_fms_2
 = {

44 &
a_OP_CHOICE
,

49 { 0, &
a_PER_ty_ditiHd_fms_cڡr_2
, 
CHOICE_cڡt
 },

50 
a_MBR_ditiHd_fms_2
,

52 &
a_SPC_ditiHd_fms_ecs_2


55 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_InditiHd_1
[] = {

56 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiHd
, 
ditiHd_fms
),

57 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

59 &
a_DEF_ditiHd_fms_2
,

66 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_InditiHd_gs_1
[] = {

67 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

69 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_InditiHd_g2_1
[] = {

70 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

72 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_InditiHd_ecs_1
 = {

73 (
E2SM_KPM_InditiHd
),

74 
offtof
(
E2SM_KPM_InditiHd
, 
_a_x
),

75 
a_MAP_E2SM_KPM_InditiHd_g2_1
,

80 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_InditiHd
 = {

83 &
a_OP_SEQUENCE
,

84 
a_DEF_E2SM_KPM_InditiHd_gs_1
,

85 (
a_DEF_E2SM_KPM_InditiHd_gs_1
)

86 /(
a_DEF_E2SM_KPM_InditiHd_gs_1
[0]),

87 
a_DEF_E2SM_KPM_InditiHd_gs_1
,

88 (
a_DEF_E2SM_KPM_InditiHd_gs_1
)

89 /(
a_DEF_E2SM_KPM_InditiHd_gs_1
[0]),

90 { 0, 0, 
SEQUENCE_cڡt
 },

91 
a_MBR_E2SM_KPM_InditiHd_1
,

93 &
a_SPC_E2SM_KPM_InditiHd_ecs_1


	@E2SM-KPM-IndicationMessage-Format1.c

8 
	~"E2SM-KPM-InditiMesge-Fm1.h
"

10 
	~"MsumtInfoLi.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_InditiMesge_Fm1_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiMesge_Fm1
, 
msDa
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_MsumtDa
,

21 { 
ATF_POINTER
, 2, 
offtof
(
E2SM_KPM_InditiMesge_Fm1
, 
msInfoLi
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_MsumtInfoLi
,

30 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_InditiMesge_Fm1
, 
gnulPiod
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_GnuryPiod
,

40 cڡ 
	ga_MAP_E2SM_KPM_InditiMesge_Fm1_oms_1
[] = { 1, 2 };

41 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
[] = {

42 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

44 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_InditiMesge_Fm1_g2_1
[] = {

45 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

47 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

49 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_InditiMesge_Fm1_ecs_1
 = {

50 (
E2SM_KPM_InditiMesge_Fm1
),

51 
offtof
(
E2SM_KPM_InditiMesge_Fm1
, 
_a_x
),

52 
a_MAP_E2SM_KPM_InditiMesge_Fm1_g2_1
,

54 
a_MAP_E2SM_KPM_InditiMesge_Fm1_oms_1
,

58 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_InditiMesge_Fm1
 = {

61 &
a_OP_SEQUENCE
,

62 
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
,

63 (
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
)

64 /(
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
[0]),

65 
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
,

66 (
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
)

67 /(
a_DEF_E2SM_KPM_InditiMesge_Fm1_gs_1
[0]),

68 { 0, 0, 
SEQUENCE_cڡt
 },

69 
a_MBR_E2SM_KPM_InditiMesge_Fm1_1
,

71 &
a_SPC_E2SM_KPM_InditiMesge_Fm1_ecs_1


	@E2SM-KPM-IndicationMessage-Format2.c

8 
	~"E2SM-KPM-InditiMesge-Fm2.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_InditiMesge_Fm2_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiMesge_Fm2
, 
msDa
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_MsumtDa
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiMesge_Fm2
, 
msCdUEidLi
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_MsumtCdUEidLi
,

29 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_InditiMesge_Fm2
, 
gnulPiod
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_GnuryPiod
,

39 cڡ 
	ga_MAP_E2SM_KPM_InditiMesge_Fm2_oms_1
[] = { 2 };

40 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

43 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_InditiMesge_Fm2_g2_1
[] = {

44 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

45 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

48 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_InditiMesge_Fm2_ecs_1
 = {

49 (
E2SM_KPM_InditiMesge_Fm2
),

50 
offtof
(
E2SM_KPM_InditiMesge_Fm2
, 
_a_x
),

51 
a_MAP_E2SM_KPM_InditiMesge_Fm2_g2_1
,

53 
a_MAP_E2SM_KPM_InditiMesge_Fm2_oms_1
,

57 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_InditiMesge_Fm2
 = {

60 &
a_OP_SEQUENCE
,

61 
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
,

62 (
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
)

63 /(
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
[0]),

64 
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
,

65 (
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
)

66 /(
a_DEF_E2SM_KPM_InditiMesge_Fm2_gs_1
[0]),

67 { 0, 0, 
SEQUENCE_cڡt
 },

68 
a_MBR_E2SM_KPM_InditiMesge_Fm2_1
,

70 &
a_SPC_E2SM_KPM_InditiMesge_Fm2_ecs_1


	@E2SM-KPM-IndicationMessage.c

8 
	~"E2SM-KPM-InditiMesge.h
"

10 
	~"E2SM-KPM-InditiMesge-Fm1.h
"

11 
	~"E2SM-KPM-InditiMesge-Fm2.h
"

12 
a_r_cڡts_t
 
a_PER_ty_ditiMesge_fms_cڡr_2
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_ditiMesge_fms_2
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_InditiMesge__ditiMesge_fms
, 
choi
.
ditiMesge_Fm1
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_E2SM_KPM_InditiMesge_Fm1
,

27 { 
ATF_POINTER
, 0, 
offtof
(
E2SM_KPM_InditiMesge__ditiMesge_fms
, 
choi
.
ditiMesge_Fm2
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_E2SM_KPM_InditiMesge_Fm2
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_ditiMesge_fms_g2_2
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_ditiMesge_fms_ecs_2
 = {

42 (
E2SM_KPM_InditiMesge__ditiMesge_fms
),

43 
offtof
(
E2SM_KPM_InditiMesge__ditiMesge_fms
, 
_a_x
),

44 
offtof
(
E2SM_KPM_InditiMesge__ditiMesge_fms
, 
e
),

45 (((
E2SM_KPM_InditiMesge__ditiMesge_fms
 *)0)->
e
),

46 
a_MAP_ditiMesge_fms_g2_2
,

52 
a_TYPE_dest_t
 
	ga_DEF_ditiMesge_fms_2
 = {

55 &
a_OP_CHOICE
,

60 { 0, &
a_PER_ty_ditiMesge_fms_cڡr_2
, 
CHOICE_cڡt
 },

61 
a_MBR_ditiMesge_fms_2
,

63 &
a_SPC_ditiMesge_fms_ecs_2


66 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_InditiMesge_1
[] = {

67 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_InditiMesge
, 
ditiMesge_fms
),

68 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

70 &
a_DEF_ditiMesge_fms_2
,

77 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_InditiMesge_gs_1
[] = {

78 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

80 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_InditiMesge_g2_1
[] = {

81 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

83 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_InditiMesge_ecs_1
 = {

84 (
E2SM_KPM_InditiMesge
),

85 
offtof
(
E2SM_KPM_InditiMesge
, 
_a_x
),

86 
a_MAP_E2SM_KPM_InditiMesge_g2_1
,

91 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_InditiMesge
 = {

94 &
a_OP_SEQUENCE
,

95 
a_DEF_E2SM_KPM_InditiMesge_gs_1
,

96 (
a_DEF_E2SM_KPM_InditiMesge_gs_1
)

97 /(
a_DEF_E2SM_KPM_InditiMesge_gs_1
[0]),

98 
a_DEF_E2SM_KPM_InditiMesge_gs_1
,

99 (
a_DEF_E2SM_KPM_InditiMesge_gs_1
)

100 /(
a_DEF_E2SM_KPM_InditiMesge_gs_1
[0]),

101 { 0, 0, 
SEQUENCE_cڡt
 },

102 
a_MBR_E2SM_KPM_InditiMesge_1
,

104 &
a_SPC_E2SM_KPM_InditiMesge_ecs_1


	@E2SM-KPM-RANfunction-Description.c

8 
	~"E2SM-KPM-RANfuni-Desti.h
"

10 
	~"RIC-EvtTriggSty-Im.h
"

11 
	~"RIC-RtSty-Im.h
"

13 
	$memb_ric_EvtTriggSty_Li_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

14 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

15 
size_t
 
size
;

17 if(!

) {

18 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

20 
td
->
me
, 
__FILE__
, 
__LINE__
);

25 
size
 = 
	`_A_CSEQUENCE_FROM_VOID
(

)->
cou
;

27 if((
size
 >= 1 && size <= 63)) {

29  
td
->
codg_cڡts
.
	`g_cڡts
d, 

, 
cb
, 
p_key
);

31 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

33 
td
->
me
, 
__FILE__
, 
__LINE__
);

36 
	}
}

39 
	$memb_ric_RtSty_Li_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

40 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

41 
size_t
 
size
;

43 if(!

) {

44 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

46 
td
->
me
, 
__FILE__
, 
__LINE__
);

51 
size
 = 
	`_A_CSEQUENCE_FROM_VOID
(

)->
cou
;

53 if((
size
 >= 1 && size <= 63)) {

55  
td
->
codg_cڡts
.
	`g_cڡts
d, 

, 
cb
, 
p_key
);

57 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

59 
td
->
me
, 
__FILE__
, 
__LINE__
);

62 
	}
}

64 
a_r_cڡts_t
 
a_PER_ty_ric_EvtTriggSty_Li_cڡr_3
 
	gCC_NOTUSED
 = {

65 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

66 { 
APC_CONSTRAINED
, 6, 6, 1, 63 } ,

69 
a_r_cڡts_t
 
a_PER_ty_ric_RtSty_Li_cڡr_5
 
	gCC_NOTUSED
 = {

70 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

71 { 
APC_CONSTRAINED
, 6, 6, 1, 63 } ,

74 
a_r_cڡts_t
 
a_PER_memb_ric_EvtTriggSty_Li_cڡr_3
 
	gCC_NOTUSED
 = {

75 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

76 { 
APC_CONSTRAINED
, 6, 6, 1, 63 } ,

79 
a_r_cڡts_t
 
a_PER_memb_ric_RtSty_Li_cڡr_5
 
	gCC_NOTUSED
 = {

80 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

81 { 
APC_CONSTRAINED
, 6, 6, 1, 63 } ,

84 
a_TYPE_memb_t
 
	ga_MBR_ric_EvtTriggSty_Li_3
[] = {

85 { 
ATF_POINTER
, 0, 0,

86 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

88 &
a_DEF_RIC_EvtTriggSty_Im
,

95 cڡ 
b_v_g_t
 
	ga_DEF_ric_EvtTriggSty_Li_gs_3
[] = {

96 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

97 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

99 
a_SET_OF_ecifics_t
 
	ga_SPC_ric_EvtTriggSty_Li_ecs_3
 = {

100 (
E2SM_KPM_RANfuni_Desti__ric_EvtTriggSty_Li
),

101 
offtof
(
E2SM_KPM_RANfuni_Desti__ric_EvtTriggSty_Li
, 
_a_x
),

105 
a_TYPE_dest_t
 
	ga_DEF_ric_EvtTriggSty_Li_3
 = {

108 &
a_OP_SEQUENCE_OF
,

109 
a_DEF_ric_EvtTriggSty_Li_gs_3
,

110 (
a_DEF_ric_EvtTriggSty_Li_gs_3
)

111 /(
a_DEF_ric_EvtTriggSty_Li_gs_3
[0]) - 1,

112 
a_DEF_ric_EvtTriggSty_Li_gs_3
,

113 (
a_DEF_ric_EvtTriggSty_Li_gs_3
)

114 /(
a_DEF_ric_EvtTriggSty_Li_gs_3
[0]),

115 { 0, &
a_PER_ty_ric_EvtTriggSty_Li_cڡr_3
, 
SEQUENCE_OF_cڡt
 },

116 
a_MBR_ric_EvtTriggSty_Li_3
,

118 &
a_SPC_ric_EvtTriggSty_Li_ecs_3


121 
a_TYPE_memb_t
 
	ga_MBR_ric_RtSty_Li_5
[] = {

122 { 
ATF_POINTER
, 0, 0,

123 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

125 &
a_DEF_RIC_RtSty_Im
,

132 cڡ 
b_v_g_t
 
	ga_DEF_ric_RtSty_Li_gs_5
[] = {

133 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

134 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

136 
a_SET_OF_ecifics_t
 
	ga_SPC_ric_RtSty_Li_ecs_5
 = {

137 (
E2SM_KPM_RANfuni_Desti__ric_RtSty_Li
),

138 
offtof
(
E2SM_KPM_RANfuni_Desti__ric_RtSty_Li
, 
_a_x
),

142 
a_TYPE_dest_t
 
	ga_DEF_ric_RtSty_Li_5
 = {

145 &
a_OP_SEQUENCE_OF
,

146 
a_DEF_ric_RtSty_Li_gs_5
,

147 (
a_DEF_ric_RtSty_Li_gs_5
)

148 /(
a_DEF_ric_RtSty_Li_gs_5
[0]) - 1,

149 
a_DEF_ric_RtSty_Li_gs_5
,

150 (
a_DEF_ric_RtSty_Li_gs_5
)

151 /(
a_DEF_ric_RtSty_Li_gs_5
[0]),

152 { 0, &
a_PER_ty_ric_RtSty_Li_cڡr_5
, 
SEQUENCE_OF_cڡt
 },

153 
a_MBR_ric_RtSty_Li_5
,

155 &
a_SPC_ric_RtSty_Li_ecs_5


158 
a_TYPE_memb_t
 
	ga_MBR_E2SM_KPM_RANfuni_Desti_1
[] = {

159 { 
ATF_NOFLAGS
, 0, 
offtof
(
E2SM_KPM_RANfuni_Desti
, 
nFuni_Name
),

160 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

162 &
a_DEF_RANfuni_Name
,

168 { 
ATF_POINTER
, 2, 
offtof
(
E2SM_KPM_RANfuni_Desti
, 
ric_EvtTriggSty_Li
),

169 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

171 &
a_DEF_ric_EvtTriggSty_Li_3
,

173 { 0, &
a_PER_memb_ric_EvtTriggSty_Li_cڡr_3
, 
memb_ric_EvtTriggSty_Li_cڡt_1
 },

177 { 
ATF_POINTER
, 1, 
offtof
(
E2SM_KPM_RANfuni_Desti
, 
ric_RtSty_Li
),

178 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

180 &
a_DEF_ric_RtSty_Li_5
,

182 { 0, &
a_PER_memb_ric_RtSty_Li_cڡr_5
, 
memb_ric_RtSty_Li_cڡt_1
 },

187 cڡ 
	ga_MAP_E2SM_KPM_RANfuni_Desti_oms_1
[] = { 1, 2 };

188 cڡ 
b_v_g_t
 
	ga_DEF_E2SM_KPM_RANfuni_Desti_gs_1
[] = {

189 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

191 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_E2SM_KPM_RANfuni_Desti_g2_1
[] = {

192 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

193 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

194 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

196 
a_SEQUENCE_ecifics_t
 
	ga_SPC_E2SM_KPM_RANfuni_Desti_ecs_1
 = {

197 (
E2SM_KPM_RANfuni_Desti
),

198 
offtof
(
E2SM_KPM_RANfuni_Desti
, 
_a_x
),

199 
a_MAP_E2SM_KPM_RANfuni_Desti_g2_1
,

201 
a_MAP_E2SM_KPM_RANfuni_Desti_oms_1
,

205 
a_TYPE_dest_t
 
	ga_DEF_E2SM_KPM_RANfuni_Desti
 = {

208 &
a_OP_SEQUENCE
,

209 
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
,

210 (
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
)

211 /(
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
[0]),

212 
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
,

213 (
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
)

214 /(
a_DEF_E2SM_KPM_RANfuni_Desti_gs_1
[0]),

215 { 0, 0, 
SEQUENCE_cڡt
 },

216 
a_MBR_E2SM_KPM_RANfuni_Desti_1
,

218 &
a_SPC_E2SM_KPM_RANfuni_Desti_ecs_1


	@EN-GNB-ID.c

8 
	~"EN-GNB-ID.h
"

11 
	$memb__gNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 >= 22 && size <= 32)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

41 
a_r_cڡts_t
 
a_PER_memb__gNB_ID_cڡr_2
 
	gCC_NOTUSED
 = {

42 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

43 { 
APC_CONSTRAINED
, 4, 4, 22, 32 } ,

46 
a_r_cڡts_t
 
a_PER_ty_EN_GNB_ID_cڡr_1
 
	gCC_NOTUSED
 = {

47 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

48 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

51 
a_TYPE_memb_t
 
	ga_MBR_EN_GNB_ID_1
[] = {

52 { 
ATF_NOFLAGS
, 0, 
offtof
(
EN_GNB_ID
, 
choi
.
_gNB_ID
),

53 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

55 &
a_DEF_BIT_STRING
,

57 { 0, &
a_PER_memb__gNB_ID_cڡr_2
, 
memb__gNB_ID_cڡt_1
 },

62 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_EN_GNB_ID_g2_1
[] = {

63 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

65 
a_CHOICE_ecifics_t
 
	ga_SPC_EN_GNB_ID_ecs_1
 = {

66 (
EN_GNB_ID
),

67 
offtof
(
EN_GNB_ID
, 
_a_x
),

68 
offtof
(
EN_GNB_ID
, 
e
),

69 (((
EN_GNB_ID
 *)0)->
e
),

70 
a_MAP_EN_GNB_ID_g2_1
,

75 
a_TYPE_dest_t
 
	ga_DEF_EN_GNB_ID
 = {

78 &
a_OP_CHOICE
,

83 { 0, &
a_PER_ty_EN_GNB_ID_cڡr_1
, 
CHOICE_cڡt
 },

84 
a_MBR_EN_GNB_ID_1
,

86 &
a_SPC_EN_GNB_ID_ecs_1


	@ENB-ID.c

8 
	~"ENB-ID.h
"

11 
	$memb_mao_eNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 20)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

42 
	$memb_home_eNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

43 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

44 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

45 
size_t
 
size
;

47 if(!

) {

48 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

50 
td
->
me
, 
__FILE__
, 
__LINE__
);

54 if(

->
size
 > 0) {

56 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

58 
size
 = 0;

61 if((
size
 == 28)) {

65 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

67 
td
->
me
, 
__FILE__
, 
__LINE__
);

70 
	}
}

73 
	$memb_sht_Mao_eNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

74 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

75 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

76 
size_t
 
size
;

78 if(!

) {

79 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

81 
td
->
me
, 
__FILE__
, 
__LINE__
);

85 if(

->
size
 > 0) {

87 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

89 
size
 = 0;

92 if((
size
 == 18)) {

96 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

98 
td
->
me
, 
__FILE__
, 
__LINE__
);

101 
	}
}

104 
	$memb_lg_Mao_eNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

105 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

106 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

107 
size_t
 
size
;

109 if(!

) {

110 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

112 
td
->
me
, 
__FILE__
, 
__LINE__
);

116 if(

->
size
 > 0) {

118 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

120 
size
 = 0;

123 if((
size
 == 21)) {

127 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

129 
td
->
me
, 
__FILE__
, 
__LINE__
);

132 
	}
}

134 
a_r_cڡts_t
 
a_PER_memb_mao_eNB_ID_cڡr_2
 
	gCC_NOTUSED
 = {

135 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

136 { 
APC_CONSTRAINED
, 0, 0, 20, 20 } ,

139 
a_r_cڡts_t
 
a_PER_memb_home_eNB_ID_cڡr_3
 
	gCC_NOTUSED
 = {

140 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

141 { 
APC_CONSTRAINED
, 0, 0, 28, 28 } ,

144 
a_r_cڡts_t
 
a_PER_memb_sht_Mao_eNB_ID_cڡr_5
 
	gCC_NOTUSED
 = {

145 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

146 { 
APC_CONSTRAINED
, 0, 0, 18, 18 } ,

149 
a_r_cڡts_t
 
a_PER_memb_lg_Mao_eNB_ID_cڡr_6
 
	gCC_NOTUSED
 = {

150 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

151 { 
APC_CONSTRAINED
, 0, 0, 21, 21 } ,

154 
a_r_cڡts_t
 
a_PER_ty_ENB_ID_cڡr_1
 
	gCC_NOTUSED
 = {

155 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

156 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

159 
a_TYPE_memb_t
 
	ga_MBR_ENB_ID_1
[] = {

160 { 
ATF_NOFLAGS
, 0, 
offtof
(
ENB_ID
, 
choi
.
mao_eNB_ID
),

161 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

163 &
a_DEF_BIT_STRING
,

165 { 0, &
a_PER_memb_mao_eNB_ID_cڡr_2
, 
memb_mao_eNB_ID_cڡt_1
 },

169 { 
ATF_NOFLAGS
, 0, 
offtof
(
ENB_ID
, 
choi
.
home_eNB_ID
),

170 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

172 &
a_DEF_BIT_STRING
,

174 { 0, &
a_PER_memb_home_eNB_ID_cڡr_3
, 
memb_home_eNB_ID_cڡt_1
 },

178 { 
ATF_NOFLAGS
, 0, 
offtof
(
ENB_ID
, 
choi
.
sht_Mao_eNB_ID
),

179 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

181 &
a_DEF_BIT_STRING
,

183 { 0, &
a_PER_memb_sht_Mao_eNB_ID_cڡr_5
, 
memb_sht_Mao_eNB_ID_cڡt_1
 },

187 { 
ATF_NOFLAGS
, 0, 
offtof
(
ENB_ID
, 
choi
.
lg_Mao_eNB_ID
),

188 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

190 &
a_DEF_BIT_STRING
,

192 { 0, &
a_PER_memb_lg_Mao_eNB_ID_cڡr_6
, 
memb_lg_Mao_eNB_ID_cڡt_1
 },

197 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_ENB_ID_g2_1
[] = {

198 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

199 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

200 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

201 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 }

203 
a_CHOICE_ecifics_t
 
	ga_SPC_ENB_ID_ecs_1
 = {

204 (
ENB_ID
),

205 
offtof
(
ENB_ID
, 
_a_x
),

206 
offtof
(
ENB_ID
, 
e
),

207 (((
ENB_ID
 *)0)->
e
),

208 
a_MAP_ENB_ID_g2_1
,

213 
a_TYPE_dest_t
 
	ga_DEF_ENB_ID
 = {

216 &
a_OP_CHOICE
,

221 { 0, &
a_PER_ty_ENB_ID_cڡr_1
, 
CHOICE_cڡt
 },

222 
a_MBR_ENB_ID_1
,

224 &
a_SPC_ENB_ID_ecs_1


	@ENB-UE-X2AP-ID-Extension.c

8 
	~"ENB-UE-X2AP-ID-Exnsi.h
"

11 
	$ENB_UE_X2AP_ID_Exnsi_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 4095)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_ENB_UE_X2AP_ID_Exnsi_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 12, 12, 0, 4095 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_ENB_UE_X2AP_ID_Exnsi
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
,

52 (
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
)

53 /(
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
[0]),

54 
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
,

55 (
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
)

56 /(
a_DEF_ENB_UE_X2AP_ID_Exnsi_gs_1
[0]),

57 { 0, &
a_PER_ty_ENB_UE_X2AP_ID_Exnsi_cڡr_1
, 
ENB_UE_X2AP_ID_Exnsi_cڡt
 },

	@ENB-UE-X2AP-ID.c

8 
	~"ENB-UE-X2AP-ID.h
"

11 
	$ENB_UE_X2AP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 4095)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_ENB_UE_X2AP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 12, 12, 0, 4095 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_ENB_UE_X2AP_ID_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_ENB_UE_X2AP_ID
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_ENB_UE_X2AP_ID_gs_1
,

52 (
a_DEF_ENB_UE_X2AP_ID_gs_1
)

53 /(
a_DEF_ENB_UE_X2AP_ID_gs_1
[0]),

54 
a_DEF_ENB_UE_X2AP_ID_gs_1
,

55 (
a_DEF_ENB_UE_X2AP_ID_gs_1
)

56 /(
a_DEF_ENB_UE_X2AP_ID_gs_1
[0]),

57 { 0, &
a_PER_ty_ENB_UE_X2AP_ID_cڡr_1
, 
ENB_UE_X2AP_ID_cڡt
 },

	@EUTRA-CGI.c

8 
	~"EUTRA-CGI.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_EUTRA_CGI_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
EUTRA_CGI
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
EUTRA_CGI
, 
eUTRAClIdty
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_EUTRAClIdty
,

30 cڡ 
b_v_g_t
 
	ga_DEF_EUTRA_CGI_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_EUTRA_CGI_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_EUTRA_CGI_ecs_1
 = {

38 (
EUTRA_CGI
),

39 
offtof
(
EUTRA_CGI
, 
_a_x
),

40 
a_MAP_EUTRA_CGI_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_EUTRA_CGI
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_EUTRA_CGI_gs_1
,

50 (
a_DEF_EUTRA_CGI_gs_1
)

51 /(
a_DEF_EUTRA_CGI_gs_1
[0]),

52 
a_DEF_EUTRA_CGI_gs_1
,

53 (
a_DEF_EUTRA_CGI_gs_1
)

54 /(
a_DEF_EUTRA_CGI_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_EUTRA_CGI_1
,

58 &
a_SPC_EUTRA_CGI_ecs_1


	@EUTRACellIdentity.c

8 
	~"EUTRAClIdty.h
"

11 
	$EUTRAClIdty_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 28)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_EUTRAClIdty_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

47 { 
APC_CONSTRAINED
, 0, 0, 28, 28 } ,

50 cڡ 
b_v_g_t
 
	ga_DEF_EUTRAClIdty_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_EUTRAClIdty
 = {

56 &
a_OP_BIT_STRING
,

57 
a_DEF_EUTRAClIdty_gs_1
,

58 (
a_DEF_EUTRAClIdty_gs_1
)

59 /(
a_DEF_EUTRAClIdty_gs_1
[0]),

60 
a_DEF_EUTRAClIdty_gs_1
,

61 (
a_DEF_EUTRAClIdty_gs_1
)

62 /(
a_DEF_EUTRAClIdty_gs_1
[0]),

63 { 0, &
a_PER_ty_EUTRAClIdty_cڡr_1
, 
EUTRAClIdty_cڡt
 },

65 &
a_SPC_BIT_STRING_ecs


	@FiveGS-TAC.c

8 
	~"FiveGS-TAC.h
"

11 
	$FiveGS_TAC_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 3)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_FiveGS_TAC_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 3, 3 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_FiveGS_TAC_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_FiveGS_TAC
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_FiveGS_TAC_gs_1
,

53 (
a_DEF_FiveGS_TAC_gs_1
)

54 /(
a_DEF_FiveGS_TAC_gs_1
[0]),

55 
a_DEF_FiveGS_TAC_gs_1
,

56 (
a_DEF_FiveGS_TAC_gs_1
)

57 /(
a_DEF_FiveGS_TAC_gs_1
[0]),

58 { 0, &
a_PER_ty_FiveGS_TAC_cڡr_1
, 
FiveGS_TAC_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@FiveQI.c

8 
	~"FiveQI.h
"

11 
	$FiveQI_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 255)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_FiveQI_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 0, 255 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_FiveQI_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_FiveQI
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_FiveQI_gs_1
,

52 (
a_DEF_FiveQI_gs_1
)

53 /(
a_DEF_FiveQI_gs_1
[0]),

54 
a_DEF_FiveQI_gs_1
,

55 (
a_DEF_FiveQI_gs_1
)

56 /(
a_DEF_FiveQI_gs_1
[0]),

57 { 0, &
a_PER_ty_FiveQI_cڡr_1
, 
FiveQI_cڡt
 },

	@FreqBandNrItem.c

8 
	~"FqBdNrIm.h
"

11 
	$memb_eqBdInditNr_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 1024)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

35 
a_r_cڡts_t
 
a_PER_memb_eqBdInditNr_cڡr_2
 
	gCC_NOTUSED
 = {

36 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 10, 10, 1, 1024 } ,

37 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

40 
a_TYPE_memb_t
 
	ga_MBR_FqBdNrIm_1
[] = {

41 { 
ATF_NOFLAGS
, 0, 
offtof
(
FqBdNrIm
, 
eqBdInditNr
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

44 &
a_DEF_NiveIeg
,

46 { 0, &
a_PER_memb_eqBdInditNr_cڡr_2
, 
memb_eqBdInditNr_cڡt_1
 },

51 cڡ 
b_v_g_t
 
	ga_DEF_FqBdNrIm_gs_1
[] = {

52 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

54 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_FqBdNrIm_g2_1
[] = {

55 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

57 
a_SEQUENCE_ecifics_t
 
	ga_SPC_FqBdNrIm_ecs_1
 = {

58 (
FqBdNrIm
),

59 
offtof
(
FqBdNrIm
, 
_a_x
),

60 
a_MAP_FqBdNrIm_g2_1
,

65 
a_TYPE_dest_t
 
	ga_DEF_FqBdNrIm
 = {

68 &
a_OP_SEQUENCE
,

69 
a_DEF_FqBdNrIm_gs_1
,

70 (
a_DEF_FqBdNrIm_gs_1
)

71 /(
a_DEF_FqBdNrIm_gs_1
[0]),

72 
a_DEF_FqBdNrIm_gs_1
,

73 (
a_DEF_FqBdNrIm_gs_1
)

74 /(
a_DEF_FqBdNrIm_gs_1
[0]),

75 { 0, 0, 
SEQUENCE_cڡt
 },

76 
a_MBR_FqBdNrIm_1
,

78 &
a_SPC_FqBdNrIm_ecs_1


	@GNB-CU-CP-UE-E1AP-ID.c

8 
	~"GNB-CU-CP-UE-E1AP-ID.h
"

11 
	$GNB_CU_CP_UE_E1AP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

30 
a_r_cڡts_t
 
a_PER_ty_GNB_CU_CP_UE_E1AP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

31 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

32 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_GNB_CU_CP_UE_E1AP_ID_ecs_1
 = {

40 cڡ 
b_v_g_t
 
	ga_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

43 
a_TYPE_dest_t
 
	ga_DEF_GNB_CU_CP_UE_E1AP_ID
 = {

46 &
a_OP_NiveIeg
,

47 
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
,

48 (
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
)

49 /(
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
[0]),

50 
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
,

51 (
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
)

52 /(
a_DEF_GNB_CU_CP_UE_E1AP_ID_gs_1
[0]),

53 { 0, &
a_PER_ty_GNB_CU_CP_UE_E1AP_ID_cڡr_1
, 
GNB_CU_CP_UE_E1AP_ID_cڡt
 },

55 &
a_SPC_GNB_CU_CP_UE_E1AP_ID_ecs_1


	@GNB-CU-UE-F1AP-ID.c

8 
	~"GNB-CU-UE-F1AP-ID.h
"

11 
	$GNB_CU_UE_F1AP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

30 
a_r_cڡts_t
 
a_PER_ty_GNB_CU_UE_F1AP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

31 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

32 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_GNB_CU_UE_F1AP_ID_ecs_1
 = {

40 cڡ 
b_v_g_t
 
	ga_DEF_GNB_CU_UE_F1AP_ID_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

43 
a_TYPE_dest_t
 
	ga_DEF_GNB_CU_UE_F1AP_ID
 = {

46 &
a_OP_NiveIeg
,

47 
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
,

48 (
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
)

49 /(
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
[0]),

50 
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
,

51 (
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
)

52 /(
a_DEF_GNB_CU_UE_F1AP_ID_gs_1
[0]),

53 { 0, &
a_PER_ty_GNB_CU_UE_F1AP_ID_cڡr_1
, 
GNB_CU_UE_F1AP_ID_cڡt
 },

55 &
a_SPC_GNB_CU_UE_F1AP_ID_ecs_1


	@GNB-CU-UP-ID.c

8 
	~"GNB-CU-UP-ID.h
"

11 
	$GNB_CU_UP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

14 
vue
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(
	`a_INTEGER2lg
(

, &
vue
)) {

24 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

26 
td
->
me
, 
__FILE__
, 
__LINE__
);

30 if((
vue
 >= 0 && value <= 68719476735)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_GNB_CU_UP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_CONSTRAINED
, 36, -1, 0, 68719476735 } ,

47 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

50 cڡ 
b_v_g_t
 
	ga_DEF_GNB_CU_UP_ID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_GNB_CU_UP_ID
 = {

56 &
a_OP_INTEGER
,

57 
a_DEF_GNB_CU_UP_ID_gs_1
,

58 (
a_DEF_GNB_CU_UP_ID_gs_1
)

59 /(
a_DEF_GNB_CU_UP_ID_gs_1
[0]),

60 
a_DEF_GNB_CU_UP_ID_gs_1
,

61 (
a_DEF_GNB_CU_UP_ID_gs_1
)

62 /(
a_DEF_GNB_CU_UP_ID_gs_1
[0]),

63 { 0, &
a_PER_ty_GNB_CU_UP_ID_cڡr_1
, 
GNB_CU_UP_ID_cڡt
 },

	@GNB-DU-ID.c

8 
	~"GNB-DU-ID.h
"

11 
	$GNB_DU_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

14 
vue
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(
	`a_INTEGER2lg
(

, &
vue
)) {

24 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

26 
td
->
me
, 
__FILE__
, 
__LINE__
);

30 if((
vue
 >= 0 && value <= 68719476735)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_GNB_DU_ID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_CONSTRAINED
, 36, -1, 0, 68719476735 } ,

47 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

50 cڡ 
b_v_g_t
 
	ga_DEF_GNB_DU_ID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_GNB_DU_ID
 = {

56 &
a_OP_INTEGER
,

57 
a_DEF_GNB_DU_ID_gs_1
,

58 (
a_DEF_GNB_DU_ID_gs_1
)

59 /(
a_DEF_GNB_DU_ID_gs_1
[0]),

60 
a_DEF_GNB_DU_ID_gs_1
,

61 (
a_DEF_GNB_DU_ID_gs_1
)

62 /(
a_DEF_GNB_DU_ID_gs_1
[0]),

63 { 0, &
a_PER_ty_GNB_DU_ID_cڡr_1
, 
GNB_DU_ID_cڡt
 },

	@GNB-ID.c

8 
	~"GNB-ID.h
"

11 
	$memb_gNB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 >= 22 && size <= 32)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

41 
a_r_cڡts_t
 
a_PER_memb_gNB_ID_cڡr_2
 
	gCC_NOTUSED
 = {

42 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

43 { 
APC_CONSTRAINED
, 4, 4, 22, 32 } ,

46 
a_r_cڡts_t
 
a_PER_ty_GNB_ID_cڡr_1
 
	gCC_NOTUSED
 = {

47 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

48 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

51 
a_TYPE_memb_t
 
	ga_MBR_GNB_ID_1
[] = {

52 { 
ATF_NOFLAGS
, 0, 
offtof
(
GNB_ID
, 
choi
.
gNB_ID
),

53 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

55 &
a_DEF_BIT_STRING
,

57 { 0, &
a_PER_memb_gNB_ID_cڡr_2
, 
memb_gNB_ID_cڡt_1
 },

62 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GNB_ID_g2_1
[] = {

63 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

65 
a_CHOICE_ecifics_t
 
	ga_SPC_GNB_ID_ecs_1
 = {

66 (
GNB_ID
),

67 
offtof
(
GNB_ID
, 
_a_x
),

68 
offtof
(
GNB_ID
, 
e
),

69 (((
GNB_ID
 *)0)->
e
),

70 
a_MAP_GNB_ID_g2_1
,

75 
a_TYPE_dest_t
 
	ga_DEF_GNB_ID
 = {

78 &
a_OP_CHOICE
,

83 { 0, &
a_PER_ty_GNB_ID_cڡr_1
, 
CHOICE_cڡt
 },

84 
a_MBR_GNB_ID_1
,

86 &
a_SPC_GNB_ID_ecs_1


	@GUAMI.c

8 
	~"GUAMI.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GUAMI_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUAMI
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUAMI
, 
aMFRegiID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_AMFRegiID
,

29 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUAMI
, 
aMFSID
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_AMFSID
,

38 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUAMI
, 
aMFPor
),

39 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

41 &
a_DEF_AMFPor
,

48 cڡ 
b_v_g_t
 
	ga_DEF_GUAMI_gs_1
[] = {

49 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

51 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GUAMI_g2_1
[] = {

52 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

53 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

54 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

55 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 }

57 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GUAMI_ecs_1
 = {

58 (
GUAMI
),

59 
offtof
(
GUAMI
, 
_a_x
),

60 
a_MAP_GUAMI_g2_1
,

65 
a_TYPE_dest_t
 
	ga_DEF_GUAMI
 = {

68 &
a_OP_SEQUENCE
,

69 
a_DEF_GUAMI_gs_1
,

70 (
a_DEF_GUAMI_gs_1
)

71 /(
a_DEF_GUAMI_gs_1
[0]),

72 
a_DEF_GUAMI_gs_1
,

73 (
a_DEF_GUAMI_gs_1
)

74 /(
a_DEF_GUAMI_gs_1
[0]),

75 { 0, 0, 
SEQUENCE_cڡt
 },

76 
a_MBR_GUAMI_1
,

78 &
a_SPC_GUAMI_ecs_1


	@GUMMEI.c

8 
	~"GUMMEI.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GUMMEI_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUMMEI
, 
pLMN_Idty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUMMEI
, 
mME_Group_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_MME_Group_ID
,

29 { 
ATF_NOFLAGS
, 0, 
offtof
(
GUMMEI
, 
mME_Code
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_MME_Code
,

39 cڡ 
b_v_g_t
 
	ga_DEF_GUMMEI_gs_1
[] = {

40 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

42 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GUMMEI_g2_1
[] = {

43 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

44 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

45 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

47 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GUMMEI_ecs_1
 = {

48 (
GUMMEI
),

49 
offtof
(
GUMMEI
, 
_a_x
),

50 
a_MAP_GUMMEI_g2_1
,

55 
a_TYPE_dest_t
 
	ga_DEF_GUMMEI
 = {

58 &
a_OP_SEQUENCE
,

59 
a_DEF_GUMMEI_gs_1
,

60 (
a_DEF_GUMMEI_gs_1
)

61 /(
a_DEF_GUMMEI_gs_1
[0]),

62 
a_DEF_GUMMEI_gs_1
,

63 (
a_DEF_GUMMEI_gs_1
)

64 /(
a_DEF_GUMMEI_gs_1
[0]),

65 { 0, 0, 
SEQUENCE_cڡt
 },

66 
a_MBR_GUMMEI_1
,

68 &
a_SPC_GUMMEI_ecs_1


	@GlobalENB-ID.c

8 
	~"GlobENB-ID.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GlobENB_ID_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobENB_ID
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobENB_ID
, 
eNB_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_ENB_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_GlobENB_ID_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GlobENB_ID_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GlobENB_ID_ecs_1
 = {

38 (
GlobENB_ID
),

39 
offtof
(
GlobENB_ID
, 
_a_x
),

40 
a_MAP_GlobENB_ID_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_GlobENB_ID
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_GlobENB_ID_gs_1
,

50 (
a_DEF_GlobENB_ID_gs_1
)

51 /(
a_DEF_GlobENB_ID_gs_1
[0]),

52 
a_DEF_GlobENB_ID_gs_1
,

53 (
a_DEF_GlobENB_ID_gs_1
)

54 /(
a_DEF_GlobENB_ID_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_GlobENB_ID_1
,

58 &
a_SPC_GlobENB_ID_ecs_1


	@GlobalGNB-ID.c

8 
	~"GlobGNB-ID.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GlobGNB_ID_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobGNB_ID
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobGNB_ID
, 
gNB_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_GNB_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_GlobGNB_ID_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GlobGNB_ID_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GlobGNB_ID_ecs_1
 = {

38 (
GlobGNB_ID
),

39 
offtof
(
GlobGNB_ID
, 
_a_x
),

40 
a_MAP_GlobGNB_ID_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_GlobGNB_ID
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_GlobGNB_ID_gs_1
,

50 (
a_DEF_GlobGNB_ID_gs_1
)

51 /(
a_DEF_GlobGNB_ID_gs_1
[0]),

52 
a_DEF_GlobGNB_ID_gs_1
,

53 (
a_DEF_GlobGNB_ID_gs_1
)

54 /(
a_DEF_GlobGNB_ID_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_GlobGNB_ID_1
,

58 &
a_SPC_GlobGNB_ID_ecs_1


	@GlobalNGRANNodeID.c

8 
	~"GlobNGRANNodeID.h
"

10 
	~"GlobGNB-ID.h
"

11 
	~"GlobNgENB-ID.h
"

12 
a_r_cڡts_t
 
a_PER_ty_GlobNGRANNodeID_cڡr_1
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_GlobNGRANNodeID_1
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
GlobNGRANNodeID
, 
choi
.
gNB
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_GlobGNB_ID
,

27 { 
ATF_POINTER
, 0, 
offtof
(
GlobNGRANNodeID
, 
choi
.
ng_eNB
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_GlobNgENB_ID
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GlobNGRANNodeID_g2_1
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_GlobNGRANNodeID_ecs_1
 = {

42 (
GlobNGRANNodeID
),

43 
offtof
(
GlobNGRANNodeID
, 
_a_x
),

44 
offtof
(
GlobNGRANNodeID
, 
e
),

45 (((
GlobNGRANNodeID
 *)0)->
e
),

46 
a_MAP_GlobNGRANNodeID_g2_1
,

51 
a_TYPE_dest_t
 
	ga_DEF_GlobNGRANNodeID
 = {

54 &
a_OP_CHOICE
,

59 { 0, &
a_PER_ty_GlobNGRANNodeID_cڡr_1
, 
CHOICE_cڡt
 },

60 
a_MBR_GlobNGRANNodeID_1
,

62 &
a_SPC_GlobNGRANNodeID_ecs_1


	@GlobalNgENB-ID.c

8 
	~"GlobNgENB-ID.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GlobNgENB_ID_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobNgENB_ID
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobNgENB_ID
, 
ngENB_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_NgENB_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_GlobNgENB_ID_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GlobNgENB_ID_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GlobNgENB_ID_ecs_1
 = {

38 (
GlobNgENB_ID
),

39 
offtof
(
GlobNgENB_ID
, 
_a_x
),

40 
a_MAP_GlobNgENB_ID_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_GlobNgENB_ID
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_GlobNgENB_ID_gs_1
,

50 (
a_DEF_GlobNgENB_ID_gs_1
)

51 /(
a_DEF_GlobNgENB_ID_gs_1
[0]),

52 
a_DEF_GlobNgENB_ID_gs_1
,

53 (
a_DEF_GlobNgENB_ID_gs_1
)

54 /(
a_DEF_GlobNgENB_ID_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_GlobNgENB_ID_1
,

58 &
a_SPC_GlobNgENB_ID_ecs_1


	@GlobalenGNB-ID.c

8 
	~"GlobGNB-ID.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_GlobGNB_ID_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobGNB_ID
, 
pLMN_Idty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
GlobGNB_ID
, 
_gNB_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_EN_GNB_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_GlobGNB_ID_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GlobGNB_ID_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_GlobGNB_ID_ecs_1
 = {

38 (
GlobGNB_ID
),

39 
offtof
(
GlobGNB_ID
, 
_a_x
),

40 
a_MAP_GlobGNB_ID_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_GlobGNB_ID
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_GlobGNB_ID_gs_1
,

50 (
a_DEF_GlobGNB_ID_gs_1
)

51 /(
a_DEF_GlobGNB_ID_gs_1
[0]),

52 
a_DEF_GlobGNB_ID_gs_1
,

53 (
a_DEF_GlobGNB_ID_gs_1
)

54 /(
a_DEF_GlobGNB_ID_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_GlobGNB_ID_1
,

58 &
a_SPC_GlobGNB_ID_ecs_1


	@GranularityPeriod.c

8 
	~"GnuryPiod.h
"

11 
	$GnuryPiod_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 4294967295)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_GnuryPiod_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 32, -1, 1, 4294967295 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_GnuryPiod_ecs_1
 = {

49 cڡ 
b_v_g_t
 
	ga_DEF_GnuryPiod_gs_1
[] = {

50 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

52 
a_TYPE_dest_t
 
	ga_DEF_GnuryPiod
 = {

55 &
a_OP_NiveIeg
,

56 
a_DEF_GnuryPiod_gs_1
,

57 (
a_DEF_GnuryPiod_gs_1
)

58 /(
a_DEF_GnuryPiod_gs_1
[0]),

59 
a_DEF_GnuryPiod_gs_1
,

60 (
a_DEF_GnuryPiod_gs_1
)

61 /(
a_DEF_GnuryPiod_gs_1
[0]),

62 { 0, &
a_PER_ty_GnuryPiod_cڡr_1
, 
GnuryPiod_cڡt
 },

64 &
a_SPC_GnuryPiod_ecs_1


	@GroupID.c

8 
	~"GroupID.h
"

10 
a_r_cڡts_t
 
a_PER_ty_GroupID_cڡr_1
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_GroupID_1
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
GroupID
, 
choi
.
fiveGC
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_FiveQI
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
GroupID
, 
choi
.
ePC
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_QCI
,

35 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_GroupID_g2_1
[] = {

36 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

37 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

39 
a_CHOICE_ecifics_t
 
	ga_SPC_GroupID_ecs_1
 = {

40 (
GroupID
),

41 
offtof
(
GroupID
, 
_a_x
),

42 
offtof
(
GroupID
, 
e
),

43 (((
GroupID
 *)0)->
e
),

44 
a_MAP_GroupID_g2_1
,

49 
a_TYPE_dest_t
 
	ga_DEF_GroupID
 = {

52 &
a_OP_CHOICE
,

57 { 0, &
a_PER_ty_GroupID_cڡr_1
, 
CHOICE_cڡt
 },

58 
a_MBR_GroupID_1
,

60 &
a_SPC_GroupID_ecs_1


	@INTEGER.c

6 
	~<a_.h
>

7 
	~<INTEGER.h
>

8 
	~<a_codecs_im.h
>

9 
	~<o.h
>

14 cڡ 
b_v_g_t
 
	ga_DEF_INTEGER_gs
[] = {

15 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

17 
a_TYPE_ݔi_t
 
	ga_OP_INTEGER
 = {

18 
INTEGER_
,

19 
INTEGER_t
,

20 
INTEGER_com
,

21 
b_decode_imive
,

22 
INTEGER_code_d
,

23 
INTEGER_decode_x
,

24 
INTEGER_code_x
,

25 #ifde 
ASN_DISABLE_OER_SUPPORT


29 
INTEGER_decode_r
,

30 
INTEGER_code_r
,

32 #ifdef 
ASN_DISABLE_PER_SUPPORT


38 
INTEGER_decode_ur
,

39 
INTEGER_code_ur
,

40 
INTEGER_decode_
,

41 
INTEGER_code_
,

43 
INTEGER_ndom_fl
,

46 
a_TYPE_dest_t
 
	ga_DEF_INTEGER
 = {

49 &
a_OP_INTEGER
,

50 
a_DEF_INTEGER_gs
,

51 (
a_DEF_INTEGER_gs
) / (asn_DEF_INTEGER_tags[0]),

52 
a_DEF_INTEGER_gs
,

53 (
a_DEF_INTEGER_gs
) / (asn_DEF_INTEGER_tags[0]),

54 { 0, 0, 
a_gic_no_cڡt
 },

62 
a_c_rv_t


63 
	$INTEGER_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

64 
g_mode
, 
b_v_g_t
 
g
, 
a_p_csume_bys_f
 *
cb
,

65 *
p_key
) {

66 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

67 
a_c_rv_t
 
rv
;

68 
INTEGER_t
 
efive_g
;

70 
	`ASN_DEBUG
("%s %ss INTEGER (tm=%d)",

71 
cb
?"Encodg":"Eimg", 
td
->
me
, 
g_mode
);

77 if(

->
buf
) {

78 
ut8_t
 *
buf
 = 

->buf;

79 
ut8_t
 *
d1
 = 
buf
 + 

->
size
 - 1;

80 
shi
;

83 ; 
buf
 < 
d1
; buf++) {

91 *
buf
) {

92 0x00: if((
buf
[1] & 0x80) == 0)

95 0xff: if((
buf
[1] & 0x80))

103 
shi
 = 
buf
 - 

->buf;

104 if(
shi
) {

106 cڡ 
ut8_t
 *
c_buf
;

107 
ut8_t
 *
nc_buf
;

108 } 
uncڡ
;

109 
uncڡ
.
c_buf
 = 

->
buf
;

110 
efive_g
.
buf
 = 
uncڡ
.
nc_buf
 + 
shi
;

111 
efive_g
.
size
 = 

->siz- 
shi
;

113 

 = &
efive_g
;

117 
rv
 = 
	`d_code_imive
(
td
, 

, 
g_mode
, 
g
, 
cb
, 
p_key
);

118 if(
rv
.
ruu_r
 =&
efive_g
) {

119 
rv
.
ruu_r
 = 

;

121  
rv
;

122 
	}
}

124 cڡ 
a_INTEGER_um_m_t
 *
INTEGER_m_um2vue
(

125 cڡ 
a_INTEGER_ecifics_t
 *
ecs
, cڡ *
lt
,

126 cڡ *
l
);

131 
ssize_t


132 
	$INTEGER__dump
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ 
INTEGER_t
 *

, 
a_p_csume_bys_f
 *
cb
, *
p_key
, 
aOrXER
) {

133 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

134 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

135 
sch
[32];

136 
ut8_t
 *
buf
 = 

->buf;

137 
ut8_t
 *
buf_d
 = 

->
buf
 + st->
size
;

138 
tmax_t
 
vue
;

139 
ssize_t
 
wre
 = 0;

140 *
p
;

141 
t
;

143 if(
ecs
 && scs->
fld_unsigd
)

144 
t
 = 
	`a_INTEGER2umax
(

, (
utmax_t
 *)&
vue
);

146 
t
 = 
	`a_INTEGER2imax
(

, &
vue
);

149 if(
t
 == 0) {

150 cڡ 
a_INTEGER_um_m_t
 *

;

151 

 = (
vue
 >0 || !
ecs
 || !ecs->
fld_unsigd
)

152 ? 
	`INTEGER_m_vue2um
(
ecs
, 
vue
) : 0;

153 if(

) {

154 if(
aOrXER
 == 0)

155  
	`a__fm_to_back
(
cb
, 
p_key
,

156 "%" 
ASN_PRIdMAX
 " (%s)", 
vue
, 

->
um_me
);

158  
	`a__fm_to_back
(
cb
, 
p_key
,

159 "<%s/>", 

->
um_me
);

160 } if(
aOrXER
 && 
ecs
 && scs->
ri_umi
) {

161 
	`ASN_DEBUG
("ASN.1 forbids dealing with "

163 
o
 = 
EPERM
;

166  
	`a__fm_to_back
(
cb
, 
p_key
,

167 (
ecs
 && scs->
fld_unsigd
)

168 ? "%" 
ASN_PRIuMAX


169 : "%" 
ASN_PRIdMAX
,

170 
vue
);

172 } if(
aOrXER
 && 
ecs
 && scs->
ri_umi
) {

177 
	`ASN_DEBUG
("ASN.1 forbids dealing with "

179 
o
 = 
EPERM
;

185 
p
 = 
sch
; 
buf
 < 
buf_d
; buf++) {

186 cڡ * cڡ 
h2c
 = "0123456789ABCDEF";

187 if((
p
 - 
sch
>(
ssize_t
)((scratch) - 4)) {

189 if(
	`cb
(
sch
, 
p
 - sch, 
p_key
) < 0)

191 
wre
 +
p
 - 
sch
;

192 
p
 = 
sch
;

194 *
p
++ = 
h2c
[*
buf
 >> 4];

195 *
p
++ = 
h2c
[*
buf
 & 0x0F];

196 *
p
++ = 0x3a;

198 if(
p
 !
sch
)

199 
p
--;

201 
wre
 +
p
 - 
sch
;

202  (
	`cb
(
sch
, 
p
 - sch, 
p_key
< 0? -1 : 
wre
;

203 
	}
}

209 
	$INTEGER_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

210 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

211 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

212 
ssize_t
 
t
;

214 ()
ev
;

216 if(!

 || !->
buf
)

217 
t
 = 
	`cb
("<ab>", 8, 
p_key
);

219 
t
 = 
	`INTEGER__dump
(
td
, 

, 
cb
, 
p_key
, 0);

221  (
t
 < 0) ? -1 : 0;

222 
	}
}

224 
	se2v_key
 {

225 cڡ *
	mt
;

226 cڡ *
	m
;

227 cڡ 
a_INTEGER_um_m_t
 *
	mvem
;

228 cڡ *
	mevm
;

231 
	$INTEGER__comr_um2vue
(cڡ *
kp
, cڡ *
am
) {

232 cڡ 
e2v_key
 *
key
 = (cڡ e2v_key *)
kp
;

233 cڡ 
a_INTEGER_um_m_t
 *

 = (cڡ_INTEGER_um_m_*)
am
;

234 cڡ *
r
, *
d
, *
me
;

237 

 = 
key
->
vem
 + key->
evm
[el - key->vemap];

240 
r
 = 
key
->
t
, 
d
 = key->

, 
me
 = 

->
um_me
;

241 
r
 < 
d
;++, 
me
++) {

242 if(*
r
 !*
me
 || !*name)

243  *(cڡ *)
r


244 - *(cڡ *)
me
;

246  
me
[0] ? -1 : 0;

247 
	}
}

249 cڡ 
a_INTEGER_um_m_t
 *

250 
	$INTEGER_m_um2vue
(cڡ 
a_INTEGER_ecifics_t
 *
ecs
, cڡ *
lt
,

251 cڡ *
l
) {

252 cڡ 
a_INTEGER_um_m_t
 *
_found
;

253 
cou
 = 
ecs
 ? scs->
m_cou
 : 0;

254 
e2v_key
 
key
;

255 cڡ *

;

257 if(!
cou
 
NULL
;

261 
lt
++, 

 =t;< 
l
;p++) {

262 *

) {

271 if(

 =
l
 
NULL
;

272 
l
 = 

;

274 
key
.
t
 = 
lt
;

275 
key
.

 = 
l
;

276 
key
.
vem
 = 
ecs
->
vue2um
;

277 
key
.
evm
 = 
ecs
->
um2vue
;

278 
_found
 = (
a_INTEGER_um_m_t
 *)
	`bch
(&
key
,

279 
ecs
->
vue2um
, 
cou
, (specs->value2enum[0]),

280 
INTEGER__comr_um2vue
);

281 if(
_found
) {

283 
_found
 = 
key
.
vem
 + key.
evm
[el_found - key.vemap];

285  
_found
;

286 
	}
}

289 
	$INTEGER__comr_vue2um
(cڡ *
kp
, cڡ *
am
) {

290 
a
 = *(cڡ *)
kp
;

291 cڡ 
a_INTEGER_um_m_t
 *

 = (cڡ_INTEGER_um_m_*)
am
;

292 
b
 = 

->
t_vue
;

293 if(
a
 < 
b
)  -1;

294 if(
a
 =
b
)  0;

296 
	}
}

298 cڡ 
a_INTEGER_um_m_t
 *

299 
	$INTEGER_m_vue2um
(cڡ 
a_INTEGER_ecifics_t
 *
ecs
, 
vue
) {

300 
cou
 = 
ecs
 ? scs->
m_cou
 : 0;

301 if(!
cou
)  0;

302  (
a_INTEGER_um_m_t
 *)
	`bch
(&
vue
, 
ecs
->
vue2um
,

303 
cou
, (
ecs
->
vue2um
[0]),

304 
INTEGER__comr_vue2um
);

305 
	}
}

308 
	$INTEGER__oc
(
INTEGER_t
 *

, 
m_size
) {

309 *
p
 = 
	`MALLOC
(
m_size
 + 1);

310 if(
p
) {

311 *
b
 = 

->
buf
;

312 

->
size
 = 0;

313 

->
buf
 = 
p
;

314 
	`FREEMEM
(
b
);

319 
	}
}

324 
x_pbd_rv


325 
	$INTEGER__x_body_decode
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

326 cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

327 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

328 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

329 
INTEGER_t
 *

 = (INTEGER_*)

;

330 
tmax_t
 
dec_vue
;

331 
tmax_t
 
hex_vue
 = 0;

332 cڡ *

;

333 cڡ *
lt
 = (cڡ *)
chunk_buf
;

334 cڡ *
l
 = 
lt
 + 
chunk_size
;

336 
ST_LEADSPACE
,

337 
ST_SKIPSPHEX
,

338 
ST_WAITDIGITS
,

339 
ST_DIGITS
,

340 
ST_DIGITS_TRAILSPACE
,

341 
ST_HEXDIGIT1
,

342 
ST_HEXDIGIT2
,

343 
ST_HEXDIGITS_TRAILSPACE
,

344 
ST_HEXCOLON
,

345 
ST_END_ENUM
,

346 
ST_UNEXPECTED


347 } 
e
 = 
ST_LEADSPACE
;

348 cڡ *
dec_vue_t
 = 0;

349 cڡ *
dec_vue_d
 = 0;

351 if(
chunk_size
)

352 
	`ASN_DEBUG
("INTEGER body %ld 0x%2x..0x%2x",

353 ()
chunk_size
, *
lt
, 
l
[-1]);

355 if(
	`INTEGER__oc
(

, (
chunk_size
/3) + 1))

356  
XPBD_SYSTEM_FAILURE
;

362 

 = 
lt
;< 
l
;p++) {

363 
lv
 = *

;

364 
lv
) {

366 
e
) {

367 
ST_LEADSPACE
:

368 
ST_DIGITS_TRAILSPACE
:

369 
ST_HEXDIGITS_TRAILSPACE
:

370 
ST_SKIPSPHEX
:

372 
ST_DIGITS
:

373 
dec_vue_d
 = 

;

374 
e
 = 
ST_DIGITS_TRAILSPACE
;

376 
ST_HEXCOLON
:

377 
e
 = 
ST_HEXDIGITS_TRAILSPACE
;

384 if(
e
 =
ST_LEADSPACE
) {

385 
dec_vue
 = 0;

386 
dec_vue_t
 = 

;

387 
e
 = 
ST_WAITDIGITS
;

392 if(
e
 =
ST_LEADSPACE
) {

393 
dec_vue
 = 0;

394 
dec_vue_t
 = 

;

395 
e
 = 
ST_WAITDIGITS
;

401 
e
) {

402 
ST_DIGITS
: ;

403 
ST_SKIPSPHEX
:

404 
ST_HEXDIGIT1
:

405 
hex_vue
 = (
lv
 - 0x30) << 4;

406 
e
 = 
ST_HEXDIGIT2
;

408 
ST_HEXDIGIT2
:

409 
hex_vue
 +(
lv
 - 0x30);

410 
e
 = 
ST_HEXCOLON
;

411 

->
buf
[->
size
++] = (
ut8_t
)
hex_vue
;

413 
ST_HEXCOLON
:

414  
XPBD_BROKEN_ENCODING
;

415 
ST_LEADSPACE
:

416 
dec_vue
 = 0;

417 
dec_vue_t
 = 

;

419 
ST_WAITDIGITS
:

420 
e
 = 
ST_DIGITS
;

427 if(
e
 =
ST_LEADSPACE
) {

428 cڡ 
a_INTEGER_um_m_t
 *

;

429 

 = 
	`INTEGER_m_um2vue
(

430 (cڡ 
a_INTEGER_ecifics_t
 *)

431 
td
->
ecifics
, 
lt
, 
l
);

432 if(

) {

433 
	`ASN_DEBUG
("Found \"%s\" => %ld",

434 

->
um_me
,l->
t_vue
);

435 
dec_vue
 = 

->
t_vue
;

436 
e
 = 
ST_END_ENUM
;

437 

 = 
l
 - 1;

440 
	`ASN_DEBUG
("Unknown identifier for INTEGER");

442  
XPBD_BROKEN_ENCODING
;

444 if(
e
 =
ST_HEXCOLON
) {

446 
e
 = 
ST_HEXDIGIT1
;

448 } if(
e
 =
ST_DIGITS
) {

453 
	`ASN_DEBUG
("INTEGERe-evaluates hex form");

454 
e
 = 
ST_SKIPSPHEX
;

455 
dec_vue_t
 = 0;

456 

 = 
lt
 - 1;

459 
	`ASN_DEBUG
("%d%ld", 
e
, ()(

 - 
lt
));

465 
e
) {

466 
ST_SKIPSPHEX
:

467 
ST_LEADSPACE
:

468 
ST_HEXDIGIT1
:

469 
hex_vue
 = 
lv
 - ((lv < 0x61) ? 0x41 : 0x61);

470 
hex_vue
 += 10;

471 
hex_vue
 <<= 4;

472 
e
 = 
ST_HEXDIGIT2
;

474 
ST_HEXDIGIT2
:

475 
hex_vue
 +
lv
 - ((lv < 0x61) ? 0x41 : 0x61);

476 
hex_vue
 += 10;

477 

->
buf
[->
size
++] = (
ut8_t
)
hex_vue
;

478 
e
 = 
ST_HEXCOLON
;

480 
ST_DIGITS
:

481 
	`ASN_DEBUG
("INTEGERe-evaluates hex form");

482 
e
 = 
ST_SKIPSPHEX
;

483 
dec_vue_t
 = 0;

484 

 = 
lt
 - 1;

493 
	`ASN_DEBUG
("INTEGER :: Foundon-numeric 0x%2xt %ld",

494 
lv
, ()(

 - 
lt
));

495 
e
 = 
ST_UNEXPECTED
;

499 
e
) {

500 
ST_END_ENUM
:

503 
ST_DIGITS
:

504 
dec_vue_d
 = 
l
;

506 
ST_DIGITS_TRAILSPACE
:

508 
	`a_oimax_lim
(
dec_vue_t
, &
dec_vue_d
, &
dec_vue
)) {

509 
ASN_STRTOX_OK
:

510 if(
ecs
 && scs->
fld_unsigd
 && (
utmax_t

dec_vue
 <
ULONG_MAX
) {

512 } if(
dec_vue
 >
LONG_MIN
 && dec_vu<
LONG_MAX
) {

519 
	`ASN_DEBUG
("INTEGERxceedsongange");

522 
ASN_STRTOX_ERROR_RANGE
:

523 
	`ASN_DEBUG
("INTEGER decod%hglim", 
td
->
me
);

524  
XPBD_DECODER_LIMIT
;

525 
ASN_STRTOX_ERROR_INVAL
:

526 
ASN_STRTOX_EXPECT_MORE
:

527 
ASN_STRTOX_EXTRA_DATA
:

528  
XPBD_BROKEN_ENCODING
;

531 
ST_HEXCOLON
:

532 
ST_HEXDIGITS_TRAILSPACE
:

533 

->
buf
[->
size
] = 0;

534  
XPBD_BODY_CONSUMED
;

535 
ST_HEXDIGIT1
:

536 
ST_HEXDIGIT2
:

537 
ST_SKIPSPHEX
:

538  
XPBD_BROKEN_ENCODING
;

539 
ST_LEADSPACE
:

541  
XPBD_NOT_BODY_IGNORE
;

542 
ST_WAITDIGITS
:

543 
ST_UNEXPECTED
:

544 
	`ASN_DEBUG
("INTEGER: Nufudig(%d)", 
e
);

545  
XPBD_BROKEN_ENCODING
;

552 if(
	`a_imax2INTEGER
(

, 
dec_vue
)) {

553 
	`ASN_DEBUG
("INTEGER decod%cvsi faed", 
td
->
me
);

554  
XPBD_SYSTEM_FAILURE
;

557  
XPBD_BODY_CONSUMED
;

558 
	}
}

560 
a_dec_rv_t


561 
	$INTEGER_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

562 cڡ 
a_TYPE_dest_t
 *
td
, **

,

563 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

564  
	`x_decode_imive
(
t_codec_x
, 
td
,

565 

, (
INTEGER_t
), 
t_mme
,

566 
buf_r
, 
size
, 
INTEGER__x_body_decode
);

567 
	}
}

569 
a_c_rv_t


570 
	$INTEGER_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

571 
ev
, 
x_cod_ags_e
 
ags
,

572 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

573 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

574 
a_c_rv_t
 

 = {0,0,0};

576 ()
ev
;

577 ()
ags
;

579 if(!

 || !->
buf
)

580 
ASN__ENCODE_FAILED
;

582 

.
coded
 = 
	`INTEGER__dump
(
td
, 

, 
cb
, 
p_key
, 1);

583 if(

.
coded
 < 0
ASN__ENCODE_FAILED
;

585 
	`ASN__ENCODED_OK
(

);

586 
	}
}

588 #idef 
ASN_DISABLE_PER_SUPPORT


590 
a_dec_rv_t


591 
	$INTEGER_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

592 cڡ 
a_TYPE_dest_t
 *
td
,

593 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

594 
a_r_da_t
 *
pd
) {

595 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

596 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

597 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

598 
INTEGER_t
 *

 = (INTEGER_*)*

;

599 cڡ 
a_r_cڡt_t
 *

;

600 

;

602 ()
t_codec_x
;

604 if(!

) {

605 

 = (
INTEGER_t
 *)(*

 = 
	`CALLOC
(1, (*st)));

606 if(!


ASN__DECODE_FAILED
;

609 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

610 

 = 
cڡts
 ? &cڡts->
vue
 : 0;

612 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

613 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

614 if(
ext
 < 0
ASN__DECODE_STARVED
;

615 if(
ext


 = 0;

618 
	`FREEMEM
(

->
buf
);

619 

->
buf
 = 0;

620 

->
size
 = 0;

621 if(

) {

622 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

623 

->
buf
 = (
ut8_t
 *)
	`CALLOC
(1, 2);

624 if(!

->
buf

ASN__DECODE_FAILED
;

625 

->
size
 = 1;

626 } if(

->
ags
 & 
APC_CONSTRAINED
 && ct->
nge_bs
 >= 0) {

627 
size_t
 
size
 = (

->
nge_bs
 + 7) >> 3;

628 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(1 + 
size
 + 1);

629 if(!

->
buf

ASN__DECODE_FAILED
;

630 

->
size
 = size;

635 if(

 && ct->
ags
 !
APC_UNCONSTRAINED
) {

637 
	`ASN_DEBUG
("Ieg whg%d bs", 

->
nge_bs
);

638 if(

->
nge_bs
 >= 0) {

639 if((
size_t
)

->
nge_bs
 > 8 * ())

640 
ASN__DECODE_FAILED
;

642 if(
ecs
 && scs->
fld_unsigd
) {

643 
uvue
 = 0;

644 if(
	`ur_g_cڡed_whe_numb
(
pd
,

645 &
uvue
, 

->
nge_bs
))

646 
ASN__DECODE_STARVED
;

647 
	`ASN_DEBUG
("Got value %lu +ow %ld",

648 
uvue
, 

->
low_bound
);

649 
uvue
 +

->
low_bound
;

650 if(
	`a_ulg2INTEGER
(

, 
uvue
))

651 
ASN__DECODE_FAILED
;

653 
uvue
 = 0;

654 
svue
;

655 if(
	`ur_g_cڡed_whe_numb
(
pd
,

656 &
uvue
, 

->
nge_bs
))

657 
ASN__DECODE_STARVED
;

658 
	`ASN_DEBUG
("Got value %lu +ow %ld",

659 
uvue
, 

->
low_bound
);

660 if(
	`r_lg_nge_ueba
(
uvue
, 

->
low_bound
,

661 

->
u_bound
, &
svue
)

662 || 
	`a_lg2INTEGER
(

, 
svue
)) {

663 
ASN__DECODE_FAILED
;

666  
rv
;

669 
	`ASN_DEBUG
("Decodg uncڡed ieg %s", 
td
->
me
);

674 
ssize_t
 
n
 = 0;

675 *
p
 = 
NULL
;

676 
t
 = 0;

679 
n
 = 
	`ur_g_ngth
(
pd
, -1, 0, &

);

680 if(
n
 < 0
ASN__DECODE_STARVED
;

682 
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 
n
 + 1);

683 if(!
p

ASN__DECODE_FAILED
;

684 

->
buf
 = (
ut8_t
 *)
p
;

686 
t
 = 
	`r_g_my_bs
(
pd
, &

->
buf
[->
size
], 0, 8 * 
n
);

687 if(
t
 < 0
ASN__DECODE_STARVED
;

688 

->
size
 +
n
;

689 } 

);

690 

->
buf
[->
size
] = 0;

693 if(

 && ct->
low_bound
) {

697 
vue
 = 0;

698 if(
	`a_INTEGER2lg
(

, &
vue
))

699 
ASN__DECODE_FAILED
;

700 if(
	`a_imax2INTEGER
(

, 
vue
 + 

->
low_bound
))

701 
ASN__DECODE_FAILED
;

704  
rv
;

705 
	}
}

707 
a_c_rv_t


708 
	$INTEGER_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

709 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

710 
a_r_ou_t
 *
po
) {

711 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

712 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

713 
a_c_rv_t
 

 = {0,0,0};

714 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

715 cڡ 
ut8_t
 *
buf
;

716 cڡ 
ut8_t
 *
d
;

717 cڡ 
a_r_cڡt_t
 *

;

718 
vue
 = 0;

720 if(!

 || st->
size
 =0
ASN__ENCODE_FAILED
;

722 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

723 

 = 
cڡts
 ? &cڡts->
vue
 : 0;

725 

.
coded
 = 0;

727 if(

) {

728 
ext
 = 0;

729 if(
ecs
 && scs->
fld_unsigd
) {

730 
uv
;

731 if(
	`a_INTEGER2ulg
(

, &
uv
))

732 
ASN__ENCODE_FAILED
;

734 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

735 if(
uv
 < ()

->
low_bound
)

736 
ext
 = 1;

737 } if(

->
nge_bs
 >= 0) {

738 if(
uv
 < ()

->
low_bound


739 || 
uv
 > ()

->
u_bound
)

740 
ext
 = 1;

742 
	`ASN_DEBUG
("Vu%lu (%02x/%" 
ASN_PRI_SIZE
 ")b %lu ub %lu %s",

743 
uv
, 

->
buf
[0], st->
size
,

744 

->
low_bound
, ct->
u_bound
,

745 
ext
 ? "ext" : "fix");

746 
vue
 = 
uv
;

748 if(
	`a_INTEGER2lg
(

, &
vue
))

749 
ASN__ENCODE_FAILED
;

751 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

752 if(
vue
 < 

->
low_bound
)

753 
ext
 = 1;

754 } if(

->
nge_bs
 >= 0) {

755 if(
vue
 < 

->
low_bound


756 || 
vue
 > 

->
u_bound
)

757 
ext
 = 1;

759 
	`ASN_DEBUG
("Vu%ld (%02x/%" 
ASN_PRI_SIZE
 ")b %ld ub %ld %s",

760 
vue
, 

->
buf
[0], st->
size
,

761 

->
low_bound
, ct->
u_bound
,

762 
ext
 ? "ext" : "fix");

764 if(

->
ags
 & 
APC_EXTENSIBLE
) {

765 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

766 
ASN__ENCODE_FAILED
;

767 if(
ext


 = 0;

768 } if(
ext
) {

769 
ASN__ENCODE_FAILED
;

775 if(

 && ct->
nge_bs
 >= 0) {

776 
v
;

778 
	`ASN_DEBUG
("Encoding integer %ld (%lu) withange %d bits",

779 
vue
, vu- 

->
low_bound
, ct->
nge_bs
);

780 if(
ecs
 && scs->
fld_unsigd
) {

781 i(()

->
low_bound
 > ()(->
u_bound
)

782 || (()
vue
 < ()

->
low_bound
))

783 || (()
vue
 > ()

->
u_bound
)

785 
	`ASN_DEBUG
("Value %luo-be-encoded is outsidehe bounds [%lu, %lu]!",

786 
vue
, 

->
low_bound
, ct->
u_bound
);

787 
ASN__ENCODE_FAILED
;

789 
v
 = ()
vue
 - ()

->
low_bound
;

791 if(
	`r_lg_nge_ba
(
vue
, 

->
low_bound
, ct->
u_bound
, &
v
)) {

792 
ASN__ENCODE_FAILED
;

795 if(
	`ur_put_cڡed_whe_numb_u
(
po
, 
v
, 

->
nge_bs
))

796 
ASN__ENCODE_FAILED
;

797 
	`ASN__ENCODED_OK
(

);

800 if(

 && ct->
low_bound
) {

801 
	`ASN_DEBUG
("Adjuow bound%ld", 

->
low_bound
);

803 
ASN__ENCODE_FAILED
;

806 
buf
 = 

->buf, 
d
 = st->bu+ st->
size
; buf <nd;) {

807 
ed_eom
 = 0;

808 
ssize_t
 
mayEncode
 = 
	`ur_put_ngth
(
po
, 
d
 - 
buf
, &
ed_eom
);

809 if(
mayEncode
 < 0)

810 
ASN__ENCODE_FAILED
;

811 if(
	`r_put_my_bs
(
po
, 
buf
, 8 * 
mayEncode
))

812 
ASN__ENCODE_FAILED
;

813 
buf
 +
mayEncode
;

814 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0)
ASN__ENCODE_FAILED
;

817 
	`ASN__ENCODED_OK
(

);

818 
	}
}

820 
a_dec_rv_t


821 
	$INTEGER_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

822 cڡ 
a_TYPE_dest_t
 *
td
,

823 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

824 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

825 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

826 
INTEGER_t
 *

 = (INTEGER_*)*

;

827 cڡ 
a_r_cڡt_t
 *

;

828 

;

830 ()
t_codec_x
;

832 if(!

) {

833 

 = (
INTEGER_t
 *)(*

 = 
	`CALLOC
(1, (*st)));

834 if(!


ASN__DECODE_FAILED
;

837 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

838 

 = 
cڡts
 ? &cڡts->
vue
 : 0;

840 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

841 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

842 if(
ext
 < 0
ASN__DECODE_STARVED
;

843 if(
ext


 = 0;

846 
	`FREEMEM
(

->
buf
);

847 

->
buf
 = 0;

848 

->
size
 = 0;

849 if(

) {

850 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

851 

->
buf
 = (
ut8_t
 *)
	`CALLOC
(1, 2);

852 if(!

->
buf

ASN__DECODE_FAILED
;

853 

->
size
 = 1;

854 } if(

->
ags
 & 
APC_CONSTRAINED
 && ct->
nge_bs
 >= 0) {

855 
size_t
 
size
 = (

->
nge_bs
 + 7) >> 3;

856 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(1 + 
size
 + 1);

857 if(!

->
buf

ASN__DECODE_FAILED
;

858 

->
size
 = size;

863 if(

 && ct->
ags
 !
APC_UNCONSTRAINED
) {

865 
	`ASN_DEBUG
("Ieg whg%d bs", 

->
nge_bs
);

866 if(

->
nge_bs
 >= 0) {

867 i(

->
nge_bs
 > 16) {

868 
max_nge_bys
 = (

->
nge_bs
 >> 3) +

869 (((

->
nge_bs
 % 8) > 0) ? 1 : 0);

870 
ngth
 = 0, 
i
;

871 
vue
 = 0;

873 
i
 = 1; ; i++) {

874 
u
 = 1 << 
i
;

875 i(
u
 >
max_nge_bys
)

878 
	`ASN_DEBUG
("Cncod%d (%d bys %d bs", 

->
nge_bs
,

879 
max_nge_bys
, 
i
);

881 i((
ngth
 = 
	`r_g_w_bs
(
pd
, 
i
)) < 0)

882 
ASN__DECODE_FAILED
;

885 
ngth
 += 1;

886 
	`ASN_DEBUG
("Gنgth %d", 
ngth
);

887 i(
	`_g_ign
(
pd
) != 0)

888 
ASN__DECODE_FAILED
;

889 
ngth
--) {

890 
buf
 = 
	`r_g_w_bs
(
pd
, 8);

891 i(
buf
 < 0)

892 
ASN__DECODE_FAILED
;

893 
vue
 +((()
buf
<< (8 * 
ngth
));

896 
vue
 +

->
low_bound
;

897 if((
ecs
 && scs->
fld_unsigd
)

898 ? 
	`a_ut642INTEGER
(

, ()
vue
)

899 : 
	`a_t642INTEGER
(

, 
vue
))

900 
ASN__DECODE_FAILED
;

901 
	`ASN_DEBUG
("Got value %ld +ow %ld",

902 
vue
, 

->
low_bound
);

904 
vue
 = 0;

905 i(

->
nge_bs
 < 8) {

906 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

907 if(
vue
 < 0
ASN__DECODE_STARVED
;

908 } i(

->
nge_bs
 == 8) {

909 i(
	`_g_ign
(
pd
) < 0)

910 
ASN__DECODE_FAILED
;

911 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

912 if(
vue
 < 0
ASN__DECODE_STARVED
;

915 i(
	`_g_ign
(
pd
) < 0)

916 
ASN__DECODE_FAILED
;

917 
vue
 = 
	`r_g_w_bs
(
pd
, 16);

918 if(
vue
 < 0
ASN__DECODE_STARVED
;

920 
vue
 +

->
low_bound
;

921 if((
ecs
 && scs->
fld_unsigd
)

922 ? 
	`a_ulg2INTEGER
(

, 
vue
)

923 : 
	`a_lg2INTEGER
(

, 
vue
))

924 
ASN__DECODE_FAILED
;

925 
	`ASN_DEBUG
("Got value %ld +ow %ld",

926 
vue
, 

->
low_bound
);

928  
rv
;

930 
ASN__DECODE_FAILED
;

933 
	`ASN_DEBUG
("Decodg uncڡed ieg %s", 
td
->
me
);

938 
ssize_t
 
n
;

939 *
p
;

940 
t
;

943 
n
 = 
	`_g_ngth
(
pd
, -1, -1, &

);

944 if(
n
 < 0
ASN__DECODE_STARVED
;

946 
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 
n
 + 1);

947 if(!
p

ASN__DECODE_FAILED
;

948 

->
buf
 = (
ut8_t
 *)
p
;

950 
t
 = 
	`r_g_my_bs
(
pd
, &

->
buf
[->
size
], 0, 8 * 
n
);

951 if(
t
 < 0
ASN__DECODE_STARVED
;

952 

->
size
 +
n
;

953 } 

);

954 

->
buf
[->
size
] = 0;

957 if(

 && ct->
low_bound
) {

961 
vue
;

962 if(
	`a_INTEGER2lg
(

, &
vue
))

963 
ASN__DECODE_FAILED
;

964 if(
	`a_lg2INTEGER
(

, 
vue
 + 

->
low_bound
))

965 
ASN__DECODE_FAILED
;

968  
rv
;

969 
	}
}

971 
a_c_rv_t


972 
	$INTEGER_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

973 cڡ 
a_r_cڡts_t
 *
cڡts
,

974 cڡ *

, 
a_r_ou_t
 *
po
) {

975 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

976 
a_c_rv_t
 

 = {0,0,0};

977 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

978 cڡ 
ut8_t
 *
buf
;

979 cڡ 
ut8_t
 *
d
;

980 cڡ 
a_r_cڡt_t
 *

;

981 
vue
 = 0;

983 if(!

 || st->
size
 =0
ASN__ENCODE_FAILED
;

985 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

986 

 = 
cڡts
 ? &cڡts->
vue
 : 0;

988 

.
coded
 = 0;

990 if(

) {

991 
ext
 = 0;

992 if(
ecs
 && scs->
fld_unsigd
) {

993 
uv
;

994 if(
	`a_INTEGER2ulg
(

, &
uv
))

995 
ASN__ENCODE_FAILED
;

997 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

998 if(
uv
 < ()

->
low_bound
)

999 
ext
 = 1;

1000 } if(

->
nge_bs
 >= 0) {

1001 if(
uv
 < ()

->
low_bound


1002 || 
uv
 > ()

->
u_bound
)

1003 
ext
 = 1;

1005 
	`ASN_DEBUG
("Value %lu (%02x/%lu)b %ld ub %ld %s",

1006 
uv
, 

->
buf
[0], st->
size
,

1007 

->
low_bound
, ct->
u_bound
,

1008 
ext
 ? "ext" : "fix");

1009 
vue
 = 
uv
;

1011 if(
	`a_INTEGER2lg
(

, &
vue
)
ASN__ENCODE_FAILED
;

1013 if(

->
ags
 & 
APC_SEMI_CONSTRAINED
) {

1014 if(
vue
 < 

->
low_bound
)

1015 
ext
 = 1;

1016 } if(

->
nge_bs
 >= 0) {

1017 if(
vue
 < 

->
low_bound


1018 || 
vue
 > 

->
u_bound
)

1019 
ext
 = 1;

1021 
	`ASN_DEBUG
("Value %lu (%02x/%lu)b %ld ub %ld %s",

1022 
vue
, 

->
buf
[0], st->
size
,

1023 

->
low_bound
, ct->
u_bound
,

1024 
ext
 ? "ext" : "fix");

1026 if(

->
ags
 & 
APC_EXTENSIBLE
) {

1027 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

1028 
ASN__ENCODE_FAILED
;

1029 if(
ext


 = 0;

1030 } if(
ext
) {

1031 
ASN__ENCODE_FAILED
;

1036 if(

 && ct->
nge_bs
 >= 0) {

1037 
v
;

1040 
	`ASN_DEBUG
("Encoding integer %ld (%lu) withange %d bits",

1041 
vue
, vu- 

->
low_bound
, ct->
nge_bs
);

1043 
v
 = 
vue
 - 

->
low_bound
;

1046 i(

->
nge_bs
 < 8) {

1047 if(
	`r_put_w_bs
(
po
, 0x00 | 
v
, 

->
nge_bs
))

1048 
ASN__ENCODE_FAILED
;

1049 } i(

->
nge_bs
 == 8) {

1050 if(
	`_put_ign
(
po
) < 0)

1051 
ASN__ENCODE_FAILED
;

1052 if(
	`r_put_w_bs
(
po
, 0x00 | 
v
, 

->
nge_bs
))

1053 
ASN__ENCODE_FAILED
;

1054 } i(

->
nge_bs
 <= 16) {

1056 if(
	`_put_ign
(
po
) < 0)

1057 
ASN__ENCODE_FAILED
;

1058 if(
	`r_put_w_bs
(
po
, 0x0000 | 
v
,

1060 
ASN__ENCODE_FAILED
;

1063 
t64_t
 
v64
 = 
v
;

1064 
i
, 
j
;

1065 
max_nge_bys
 = (

->
nge_bs
 >> 3) +

1066 (((

->
nge_bs
 % 8) > 0) ? 1 : 0);

1068 
i
 = 1; ; i++) {

1069 
u
 = 1 << 
i
;

1070 i(
u
 >
max_nge_bys
)

1074 
j
 = (
t64_t
) -1; j != 0; j--) {

1075 
t64_t
 
v
;

1076 
v
 = 
v64
 >> (
j
 * 8);

1077 i(
v
 != 0)

1082 i(
	`r_put_w_bs
(
po
, 
j
, 
i
))

1083 
ASN__ENCODE_FAILED
;

1086 i(
	`_put_ign
(
po
) < 0)

1087 
ASN__ENCODE_FAILED
;

1089 
i
 = 0; i <
j
; i++) {

1090 if(
	`r_put_w_bs
(
po
, (
v64
 >> (8 * (
j
 - 
i
))) & 0xff, 8))

1091 
ASN__ENCODE_FAILED
;

1094 
	`ASN__ENCODED_OK
(

);

1097 if(

 && ct->
low_bound
) {

1098 
	`ASN_DEBUG
("Adjuow bound%ld", 

->
low_bound
);

1100 
ASN__ENCODE_FAILED
;

1103 
buf
 = 

->buf, 
d
 = st->bu+ st->
size
; buf <nd;) {

1104 
ssize_t
 
mayEncode
 = 
	`_put_ngth
(
po
, -1, 
d
 - 
buf
);

1105 if(
mayEncode
 < 0)

1106 
ASN__ENCODE_FAILED
;

1107 if(
	`r_put_my_bs
(
po
, 
buf
, 8 * 
mayEncode
))

1108 
ASN__ENCODE_FAILED
;

1109 
buf
 +
mayEncode
;

1112 
	`ASN__ENCODED_OK
(

);

1113 
	}
}

1117 
tmax_t


1118 
	$a__g_cvt
(cڡ 
ut8_t
 *
b
, cڡ ut8_*
d
) {

1119 
utmax_t
 
vue
;

1123 if((*
b
 >> 7)) {

1124 
vue
 = (
utmax_t
)(-1);

1126 
vue
 = 0;

1130 ; 
b
 < 
d
; b++) {

1131 
vue
 = (vu<< 8| *
b
;

1134  
vue
;

1135 
	}
}

1138 
	$a_INTEGER2imax
(cڡ 
INTEGER_t
 *

, 
tmax_t
 *
͌
) {

1139 
ut8_t
 *
b
, *
d
;

1140 
size_t
 
size
;

1143 if(!

 || !->
buf
 || !
͌
) {

1144 
o
 = 
EINVAL
;

1149 
b
 = 

->
buf
;

1150 
size
 = 

->size;

1151 
d
 = 
b
 + 
size
;

1153 if(
size
 > (
tmax_t
)) {

1154 
ut8_t
 *
d1
 = 
d
 - 1;

1162 ; 
b
 < 
d1
; b++) {

1163 *
b
) {

1164 0x00: if((
b
[1] & 0x80) == 0) ; ;

1165 0xff: if((
b
[1] & 0x80) != 0) ; ;

1170 
size
 = 
d
 - 
b
;

1171 if(
size
 > (
tmax_t
)) {

1173 
o
 = 
ERANGE
;

1179 if(
d
 =
b
) {

1180 *
͌
 = 0;

1184 *
͌
 = 
	`a__g_cvt
(
b
, 
d
);

1186 
	}
}

1190 
	$a_INTEGER2umax
(cڡ 
INTEGER_t
 *

, 
utmax_t
 *
͌
) {

1191 
ut8_t
 *
b
, *
d
;

1192 
utmax_t
 
vue
;

1193 
size_t
 
size
;

1195 if(!

 || !->
buf
 || !
͌
) {

1196 
o
 = 
EINVAL
;

1200 
b
 = 

->
buf
;

1201 
size
 = 

->size;

1202 
d
 = 
b
 + 
size
;

1205 ; 
size
 > (
vue
); 
b
++, size--) {

1206 if(*
b
) {

1208 
o
 = 
ERANGE
;

1214 
vue
 = 0; 
b
 < 
d
; b++)

1215 
vue
 = (vu<< 8| *
b
;

1217 *
͌
 = 
vue
;

1219 
	}
}

1222 
	$a_umax2INTEGER
(
INTEGER_t
 *

, 
utmax_t
 
vue
) {

1223 
ut8_t
 *
buf
;

1224 
ut8_t
 *
d
;

1225 
ut8_t
 *
b
;

1226 
shr
;

1228 if(
vue
 <((~(
utmax_t
)0) >> 1)) {

1229  
	`a_imax2INTEGER
(

, 
vue
);

1232 
buf
 = (
ut8_t
 *)
	`MALLOC
(1 + (
vue
));

1233 if(!
buf
)  -1;

1235 
d
 = 
buf
 + ((
vue
) + 1);

1236 
buf
[0] = 0;

1237 
b
 = 
buf
 + 1, 
shr
 = ((
vue
- 1* 8; b < 
d
; shr -= 8, b++)

1238 *
b
 = (
ut8_t
)(
vue
 >> 
shr
);

1240 if(

->
buf

	`FREEMEM
(st->buf);

1241 

->
buf
 = buf;

1242 

->
size
 = 1 + (
vue
);

1245 
	}
}

1248 
	$a_imax2INTEGER
(
INTEGER_t
 *

, 
tmax_t
 
vue
) {

1249 
ut8_t
 *
buf
, *
bp
;

1250 
ut8_t
 *
p
;

1251 
ut8_t
 *
pt
;

1252 
ut8_t
 *
nd1
;

1253 
leEndn
 = 1;

1254 
add
;

1256 if(!

) {

1257 
o
 = 
EINVAL
;

1261 
buf
 = (
ut8_t
 *)(*)
	`MALLOC
((
vue
));

1262 if(!
buf
)  -1;

1264 if(*(*)&
leEndn
) {

1265 
pt
 = (
ut8_t
 *)&
vue
 + (value) - 1;

1266 
nd1
 = (
ut8_t
 *)&
vue
;

1267 
add
 = -1;

1269 
pt
 = (
ut8_t
 *)&
vue
;

1270 
nd1
 = 
pt
 + (
vue
) - 1;

1271 
add
 = 1;

1280 
p
 = 
pt
; !
nd1
; +
add
) {

1281 *
p
) {

1282 0x00: if((*(
p
+
add
) & 0x80) == 0)

1285 0xff: if((*(
p
+
add
) & 0x80))

1292 
bp
 = 
buf
, 
nd1
 +
add
; 
p
 !=end1; +=dd)

1293 *
bp
++ = *
p
;

1295 if(

->
buf

	`FREEMEM
(st->buf);

1296 

->
buf
 = buf;

1297 

->
size
 = 
bp
 - 
buf
;

1300 
	}
}

1303 
	$a_INTEGER2lg
(cڡ 
INTEGER_t
 *

, *
l
) {

1304 
tmax_t
 
v
;

1305 if(
	`a_INTEGER2imax
(

, &
v
) == 0) {

1306 if(
v
 < 
LONG_MIN
 || v > 
LONG_MAX
) {

1307 
o
 = 
ERANGE
;

1310 *
l
 = 
v
;

1315 
	}
}

1318 
	$a_INTEGER2ulg
(cڡ 
INTEGER_t
 *

, *
l
) {

1319 
utmax_t
 
v
;

1320 if(
	`a_INTEGER2umax
(

, &
v
) == 0) {

1321 if(
v
 > 
ULONG_MAX
) {

1322 
o
 = 
ERANGE
;

1325 *
l
 = 
v
;

1330 
	}
}

1333 
	$a_lg2INTEGER
(
INTEGER_t
 *

, 
vue
) {

1334  
	`a_imax2INTEGER
(

, 
vue
);

1335 
	}
}

1338 
	$a_ulg2INTEGER
(
INTEGER_t
 *

, 
vue
) {

1339  
	`a_imax2INTEGER
(

, 
vue
);

1340 
	}
}

1344 
	$a_ut642INTEGER
(
INTEGER_t
 *

, 
ut64_t
 
vue
) {

1345 
ut8_t
 *
buf
;

1346 
ut8_t
 *
d
;

1347 
ut8_t
 *
b
;

1348 
shr
;

1350 if(
vue
 <
INT64_MAX
)

1351  
	`a_t642INTEGER
(

, 
vue
);

1353 
buf
 = (
ut8_t
 *)
	`MALLOC
(1 + (
vue
));

1354 if(!
buf
)  -1;

1356 
d
 = 
buf
 + ((
vue
) + 1);

1357 
buf
[0] = 0;

1358 
b
 = 
buf
 + 1, 
shr
 = ((
vue
)-1)*8; b < 
d
; shr -= 8, b++)

1359 *
b
 = (
ut8_t
)(
vue
 >> 
shr
);

1361 if(

->
buf

	`FREEMEM
(st->buf);

1362 

->
buf
 = buf;

1363 

->
size
 = 1 + (
vue
);

1366 
	}
}

1369 
	$a_t642INTEGER
(
INTEGER_t
 *

, 
t64_t
 
vue
) {

1370 
ut8_t
 *
buf
, *
bp
;

1371 
ut8_t
 *
p
;

1372 
ut8_t
 *
pt
;

1373 
ut8_t
 *
nd1
;

1374 
leEndn
 = 1;

1375 
add
;

1377 if(!

) {

1378 
o
 = 
EINVAL
;

1382 
buf
 = (
ut8_t
 *)
	`MALLOC
((
vue
));

1383 if(!
buf
)  -1;

1385 if(*(*)&
leEndn
) {

1386 
pt
 = (
ut8_t
 *)&
vue
 + (value) - 1;

1387 
nd1
 = (
ut8_t
 *)&
vue
;

1388 
add
 = -1;

1390 
pt
 = (
ut8_t
 *)&
vue
;

1391 
nd1
 = 
pt
 + (
vue
) - 1;

1392 
add
 = 1;

1401 
p
 = 
pt
; !
nd1
; +
add
) {

1402 *
p
) {

1403 0x00: if((*(
p
+
add
) & 0x80) == 0)

1406 0xff: if((*(
p
+
add
) & 0x80))

1413 
pt
 = 
p
, 
bp
 = 
buf
, 
nd1
 +
add
; !=end1; +=dd)

1414 *
bp
++ = *
p
;

1416 if(

->
buf

	`FREEMEM
(st->buf);

1417 

->
buf
 = buf;

1418 

->
size
 = 
bp
 - 
buf
;

1421 
	}
}

1429 
a_ox_su_e


1430 
	$a_oimax_lim
(cڡ *
r
, cڡ **
d
, 
tmax_t
 *

) {

1431 
sign
 = 1;

1432 
tmax_t
 
vue
;

1434 
	#ASN1_INTMAX_MAX
 ((~(
utmax_t
)0>> 1)

	)

1435 cڡ 
tmax_t
 
u_boundy
 = 
ASN1_INTMAX_MAX
 / 10;

1436 
tmax_t
 
ϡ_dig_max
 = 
ASN1_INTMAX_MAX
 % 10;

1437 #unde
ASN1_INTMAX_MAX


1439 if(
r
 >*
d
 
ASN_STRTOX_ERROR_INVAL
;

1441 *
r
) {

1443 
ϡ_dig_max
++;

1444 
sign
 = -1;

1447 
r
++;

1448 if(
r
 >*
d
) {

1449 *
d
 = 
r
;

1450  
ASN_STRTOX_EXPECT_MORE
;

1454 
vue
 = 0; 
r
 < (*
d
); str++) {

1455 *
r
) {

1458 
d
 = *
r
 - '0';

1459 if(
vue
 < 
u_boundy
) {

1460 
vue
 = vu* 10 + 
d
;

1461 } if(
vue
 =
u_boundy
) {

1462 if(
d
 <
ϡ_dig_max
) {

1463 if(
sign
 > 0) {

1464 
vue
 = vu* 10 + 
d
;

1466 
sign
 = 1;

1467 
vue
 = -vu* 10 - 
d
;

1470 *
d
 = 
r
;

1471  
ASN_STRTOX_ERROR_RANGE
;

1474 *
d
 = 
r
;

1475  
ASN_STRTOX_ERROR_RANGE
;

1480 *
d
 = 
r
;

1481 *

 = 
sign
 * 
vue
;

1482  
ASN_STRTOX_EXTRA_DATA
;

1486 *
d
 = 
r
;

1487 *

 = 
sign
 * 
vue
;

1488  
ASN_STRTOX_OK
;

1489 
	}
}

1497 
a_ox_su_e


1498 
	$a_oumax_lim
(cڡ *
r
, cڡ **
d
, 
utmax_t
 *
u
) {

1499 
utmax_t
 
vue
;

1501 
	#ASN1_UINTMAX_MAX
 ((~(
utmax_t
)0))

	)

1502 cڡ 
utmax_t
 
u_boundy
 = 
ASN1_UINTMAX_MAX
 / 10;

1503 
utmax_t
 
ϡ_dig_max
 = 
ASN1_UINTMAX_MAX
 % 10;

1504 #unde
ASN1_UINTMAX_MAX


1506 if(
r
 >*
d
 
ASN_STRTOX_ERROR_INVAL
;

1508 *
r
) {

1510  
ASN_STRTOX_ERROR_INVAL
;

1512 
r
++;

1513 if(
r
 >*
d
) {

1514 *
d
 = 
r
;

1515  
ASN_STRTOX_EXPECT_MORE
;

1519 
vue
 = 0; 
r
 < (*
d
); str++) {

1520 *
r
) {

1523 
d
 = *
r
 - '0';

1524 if(
vue
 < 
u_boundy
) {

1525 
vue
 = vu* 10 + 
d
;

1526 } if(
vue
 =
u_boundy
) {

1527 if(
d
 <
ϡ_dig_max
) {

1528 
vue
 = vu* 10 + 
d
;

1530 *
d
 = 
r
;

1531  
ASN_STRTOX_ERROR_RANGE
;

1534 *
d
 = 
r
;

1535  
ASN_STRTOX_ERROR_RANGE
;

1540 *
d
 = 
r
;

1541 *
u
 = 
vue
;

1542  
ASN_STRTOX_EXTRA_DATA
;

1546 *
d
 = 
r
;

1547 *
u
 = 
vue
;

1548  
ASN_STRTOX_OK
;

1549 
	}
}

1551 
a_ox_su_e


1552 
	$a__lim
(cڡ *
r
, cڡ **
d
, *

) {

1553 
tmax_t
 
vue
;

1554 
	`a_oimax_lim
(
r
, 
d
, &
vue
)) {

1555 
ASN_STRTOX_ERROR_RANGE
:

1556  
ASN_STRTOX_ERROR_RANGE
;

1557 
ASN_STRTOX_ERROR_INVAL
:

1558  
ASN_STRTOX_ERROR_INVAL
;

1559 
ASN_STRTOX_EXPECT_MORE
:

1560  
ASN_STRTOX_EXPECT_MORE
;

1561 
ASN_STRTOX_OK
:

1562 if(
vue
 >
LONG_MIN
 && vu<
LONG_MAX
) {

1563 *

 = 
vue
;

1564  
ASN_STRTOX_OK
;

1566  
ASN_STRTOX_ERROR_RANGE
;

1568 
ASN_STRTOX_EXTRA_DATA
:

1569 if(
vue
 >
LONG_MIN
 && vu<
LONG_MAX
) {

1570 *

 = 
vue
;

1571  
ASN_STRTOX_EXTRA_DATA
;

1573  
ASN_STRTOX_ERROR_RANGE
;

1577 
	`as
(!"Unreachable");

1578  
ASN_STRTOX_ERROR_INVAL
;

1579 
	}
}

1581 
a_ox_su_e


1582 
	$a_oul_lim
(cڡ *
r
, cڡ **
d
, *
u
) {

1583 
utmax_t
 
vue
;

1584 
	`a_oumax_lim
(
r
, 
d
, &
vue
)) {

1585 
ASN_STRTOX_ERROR_RANGE
:

1586  
ASN_STRTOX_ERROR_RANGE
;

1587 
ASN_STRTOX_ERROR_INVAL
:

1588  
ASN_STRTOX_ERROR_INVAL
;

1589 
ASN_STRTOX_EXPECT_MORE
:

1590  
ASN_STRTOX_EXPECT_MORE
;

1591 
ASN_STRTOX_OK
:

1592 if(
vue
 <
ULONG_MAX
) {

1593 *
u
 = 
vue
;

1594  
ASN_STRTOX_OK
;

1596  
ASN_STRTOX_ERROR_RANGE
;

1598 
ASN_STRTOX_EXTRA_DATA
:

1599 if(
vue
 <
ULONG_MAX
) {

1600 *
u
 = 
vue
;

1601  
ASN_STRTOX_EXTRA_DATA
;

1603  
ASN_STRTOX_ERROR_RANGE
;

1607 
	`as
(!"Unreachable");

1608  
ASN_STRTOX_ERROR_INVAL
;

1609 
	}
}

1612 
	$INTEGER_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1613 cڡ *
br
) {

1614 cڡ 
INTEGER_t
 *
a
 = 

;

1615 cڡ 
INTEGER_t
 *
b
 = 
br
;

1617 ()
td
;

1619 if(
a
 && 
b
) {

1620 if(
a
->
size
 && 
b
->size) {

1621 
sign_a
 = (
a
->
buf
[0] & 0x80) ? -1 : 1;

1622 
sign_b
 = (
b
->
buf
[0] & 0x80) ? -1 : 1;

1624 if(
sign_a
 < 
sign_b
)  -1;

1625 if(
sign_a
 > 
sign_b
)  1;

1628 if(
a
->
size
 < 
b
->size) {

1629  -1 * 
sign_a
;

1630 } if(
a
->
size
 > 
b
->size) {

1631  1 * 
sign_b
;

1634  
sign_a
 * 
	`memcmp
(
a
->
buf
, 
b
->buf,->
size
);

1635 } if(
a
->
size
) {

1636 
sign
 = (
a
->
buf
[0] & 0x80) ? -1 : 1;

1637  (1* 
sign
;

1638 } if(
b
->
size
) {

1639 
sign
 = (
a
->
buf
[0] & 0x80) ? -1 : 1;

1640  (-1* 
sign
;

1644 } if(!
a
 && !
b
) {

1646 } if(!
a
) {

1652 
	}
}

1654 
a_ndom_fl_su_t


1655 
	$INTEGER_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

1656 cڡ 
a_codg_cڡts_t
 *
cڡts
,

1657 
size_t
 
max_ngth
) {

1658 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

1659 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

1660 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

1661 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

1662 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

1663 
INTEGER_t
 *

 = *

;

1664 cڡ 
a_INTEGER_um_m_t
 *
em
;

1665 
size_t
 
em_n
;

1666 
tmax_t
 
vue
;

1667 
fd_side_m
;

1669 if(
max_ngth
 =0 
su_skd
;

1671 if(

 =
NULL
) {

1672 

 = (
INTEGER_t
 *)
	`CALLOC
(1, (*st));

1673 if(

 =
NULL
) {

1674  
su_ed
;

1678 if(
ecs
) {

1679 
em
 = 
ecs
->
vue2um
;

1680 
em_n
 = 
ecs
->
m_cou
;

1681 if(
ecs
->
ri_umi
) {

1682 
fd_side_m
 = 
em_n
 > 0;

1684 
fd_side_m
 = 
em_n
 ? 
	`a_ndom_bwn
(0, 1) : 0;

1687 
em
 = 0;

1688 
em_n
 = 0;

1689 
fd_side_m
 = 0;

1692 if(
fd_side_m
) {

1693 
	`as
(
em_n
 > 0);

1694 
vue
 = 
em
[
	`a_ndom_bwn
(0, 
em_n
 - 1)].
t_vue
;

1696 cڡ 
a_r_cڡts_t
 *

;

1698 cڡ 
vs
[] = {

1704 if(
ecs
 && scs->
fld_unsigd
) {

1705 
	`as
(
vs
[18] == 0);

1706 
vue
 = 
vs
[
	`a_ndom_bwn
(

1707 18, (
vs
) / (variants[0]) - 1)];

1709 
vue
 = 
vs
[
	`a_ndom_bwn
(

1710 0, (
vs
) / (variants[0]) - 1)];

1713 if(!
cڡts
cڡt&
td
->
codg_cڡts
;

1714 

 = 
cڡts
 ? cڡts->
r_cڡts
 : 0;

1715 if(

 && (->
vue
.
ags
 & 
APC_CONSTRAINED
)) {

1716 if(
vue
 < 

->vue.
low_bound
 || vu> ct->vue.
u_bound
) {

1717 
vue
 = 
	`a_ndom_bwn
(

->vue.
low_bound
,

1718 

->
vue
.
u_bound
);

1723 if(
	`a_imax2INTEGER
(

, 
vue
)) {

1724 if(

 =*

) {

1725 
	`ASN_STRUCT_RESET
(*
td
, 

);

1727 
	`ASN_STRUCT_FREE
(*
td
, 

);

1729  
su_ed
;

1731 *

 = 

;

1732 
su_ok
.
ngth
 = 

->
size
;

1733  
su_ok
;

1735 
	}
}

	@IndexToRFSP.c

8 
	~"IndexToRFSP.h
"

11 
	$IndexToRFSP_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 256)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_IndexToRFSP_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 1, 256 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_IndexToRFSP_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_IndexToRFSP
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_IndexToRFSP_gs_1
,

52 (
a_DEF_IndexToRFSP_gs_1
)

53 /(
a_DEF_IndexToRFSP_gs_1
[0]),

54 
a_DEF_IndexToRFSP_gs_1
,

55 (
a_DEF_IndexToRFSP_gs_1
)

56 /(
a_DEF_IndexToRFSP_gs_1
[0]),

57 { 0, &
a_PER_ty_IndexToRFSP_cڡr_1
, 
IndexToRFSP_cڡt
 },

	@Interface-MessageID.c

8 
	~"I-MesgeID.h
"

14 
a_r_cڡts_t
 
a_PER_ty_mesgeTy_cڡr_3
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 2, 2, 0, 2 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_mesgeTy_vue2um_3
[] = {

25 cڡ 
	ga_MAP_mesgeTy_um2vue_3
[] = {

31 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_mesgeTy_ecs_3
 = {

32 
a_MAP_mesgeTy_vue2um_3
,

33 
a_MAP_mesgeTy_um2vue_3
,

40 cڡ 
b_v_g_t
 
	ga_DEF_mesgeTy_gs_3
[] = {

41 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

42 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

45 
a_TYPE_dest_t
 
	ga_DEF_mesgeTy_3
 = {

48 &
a_OP_NiveEnumed
,

49 
a_DEF_mesgeTy_gs_3
,

50 (
a_DEF_mesgeTy_gs_3
)

51 /(
a_DEF_mesgeTy_gs_3
[0]) - 1,

52 
a_DEF_mesgeTy_gs_3
,

53 (
a_DEF_mesgeTy_gs_3
)

54 /(
a_DEF_mesgeTy_gs_3
[0]),

55 { 0, &
a_PER_ty_mesgeTy_cڡr_3
, 
NiveEnumed_cڡt
 },

57 &
a_SPC_mesgeTy_ecs_3


60 
a_TYPE_memb_t
 
	ga_MBR_I_MesgeID_1
[] = {

61 { 
ATF_NOFLAGS
, 0, 
offtof
(
I_MesgeID
, 
rProduID
),

62 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

64 &
a_DEF_NiveIeg
,

70 { 
ATF_NOFLAGS
, 0, 
offtof
(
I_MesgeID
, 
mesgeTy
),

71 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

73 &
a_DEF_mesgeTy_3
,

80 cڡ 
b_v_g_t
 
	ga_DEF_I_MesgeID_gs_1
[] = {

81 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

83 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_I_MesgeID_g2_1
[] = {

84 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

85 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

87 
a_SEQUENCE_ecifics_t
 
	ga_SPC_I_MesgeID_ecs_1
 = {

88 (
I_MesgeID
),

89 
offtof
(
I_MesgeID
, 
_a_x
),

90 
a_MAP_I_MesgeID_g2_1
,

95 
a_TYPE_dest_t
 
	ga_DEF_I_MesgeID
 = {

98 &
a_OP_SEQUENCE
,

99 
a_DEF_I_MesgeID_gs_1
,

100 (
a_DEF_I_MesgeID_gs_1
)

101 /(
a_DEF_I_MesgeID_gs_1
[0]),

102 
a_DEF_I_MesgeID_gs_1
,

103 (
a_DEF_I_MesgeID_gs_1
)

104 /(
a_DEF_I_MesgeID_gs_1
[0]),

105 { 0, 0, 
SEQUENCE_cڡt
 },

106 
a_MBR_I_MesgeID_1
,

108 &
a_SPC_I_MesgeID_ecs_1


	@InterfaceID-E1.c

8 
	~"IID-E1.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_E1_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_E1
, 
globGNB_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GlobGNB_ID
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_E1
, 
gNB_CU_UP_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_GNB_CU_UP_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_IID_E1_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_E1_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_E1_ecs_1
 = {

38 (
IID_E1
),

39 
offtof
(
IID_E1
, 
_a_x
),

40 
a_MAP_IID_E1_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_IID_E1
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_IID_E1_gs_1
,

50 (
a_DEF_IID_E1_gs_1
)

51 /(
a_DEF_IID_E1_gs_1
[0]),

52 
a_DEF_IID_E1_gs_1
,

53 (
a_DEF_IID_E1_gs_1
)

54 /(
a_DEF_IID_E1_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_IID_E1_1
,

58 &
a_SPC_IID_E1_ecs_1


	@InterfaceID-F1.c

8 
	~"IID-F1.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_F1_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_F1
, 
globGNB_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GlobGNB_ID
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_F1
, 
gNB_DU_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_GNB_DU_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_IID_F1_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_F1_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_F1_ecs_1
 = {

38 (
IID_F1
),

39 
offtof
(
IID_F1
, 
_a_x
),

40 
a_MAP_IID_F1_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_IID_F1
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_IID_F1_gs_1
,

50 (
a_DEF_IID_F1_gs_1
)

51 /(
a_DEF_IID_F1_gs_1
[0]),

52 
a_DEF_IID_F1_gs_1
,

53 (
a_DEF_IID_F1_gs_1
)

54 /(
a_DEF_IID_F1_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_IID_F1_1
,

58 &
a_SPC_IID_F1_ecs_1


	@InterfaceID-NG.c

8 
	~"IID-NG.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_NG_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_NG
, 
guami
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GUAMI
,

21 cڡ 
b_v_g_t
 
	ga_DEF_IID_NG_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_NG_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_NG_ecs_1
 = {

28 (
IID_NG
),

29 
offtof
(
IID_NG
, 
_a_x
),

30 
a_MAP_IID_NG_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_IID_NG
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_IID_NG_gs_1
,

40 (
a_DEF_IID_NG_gs_1
)

41 /(
a_DEF_IID_NG_gs_1
[0]),

42 
a_DEF_IID_NG_gs_1
,

43 (
a_DEF_IID_NG_gs_1
)

44 /(
a_DEF_IID_NG_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_IID_NG_1
,

48 &
a_SPC_IID_NG_ecs_1


	@InterfaceID-S1.c

8 
	~"IID-S1.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_S1_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_S1
, 
gUMMEI
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GUMMEI
,

21 cڡ 
b_v_g_t
 
	ga_DEF_IID_S1_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_S1_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_S1_ecs_1
 = {

28 (
IID_S1
),

29 
offtof
(
IID_S1
, 
_a_x
),

30 
a_MAP_IID_S1_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_IID_S1
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_IID_S1_gs_1
,

40 (
a_DEF_IID_S1_gs_1
)

41 /(
a_DEF_IID_S1_gs_1
[0]),

42 
a_DEF_IID_S1_gs_1
,

43 (
a_DEF_IID_S1_gs_1
)

44 /(
a_DEF_IID_S1_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_IID_S1_1
,

48 &
a_SPC_IID_S1_ecs_1


	@InterfaceID-W1.c

8 
	~"IID-W1.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_W1_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_W1
, 
glob_ng_eNB_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GlobNgENB_ID
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_W1
, 
ng_eNB_DU_ID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_NGENB_DU_ID
,

30 cڡ 
b_v_g_t
 
	ga_DEF_IID_W1_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_W1_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_W1_ecs_1
 = {

38 (
IID_W1
),

39 
offtof
(
IID_W1
, 
_a_x
),

40 
a_MAP_IID_W1_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_IID_W1
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_IID_W1_gs_1
,

50 (
a_DEF_IID_W1_gs_1
)

51 /(
a_DEF_IID_W1_gs_1
[0]),

52 
a_DEF_IID_W1_gs_1
,

53 (
a_DEF_IID_W1_gs_1
)

54 /(
a_DEF_IID_W1_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_IID_W1_1
,

58 &
a_SPC_IID_W1_ecs_1


	@InterfaceID-X2.c

8 
	~"IID-X2.h
"

10 
	~"GlobENB-ID.h
"

11 
	~"GlobGNB-ID.h
"

12 
a_r_cڡts_t
 
a_PER_ty_nodeTy_cڡr_2
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_nodeTy_2
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
IID_X2__nodeTy
, 
choi
.
glob_eNB_ID
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_GlobENB_ID
,

27 { 
ATF_POINTER
, 0, 
offtof
(
IID_X2__nodeTy
, 
choi
.
glob__gNB_ID
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_GlobGNB_ID
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_nodeTy_g2_2
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_nodeTy_ecs_2
 = {

42 (
IID_X2__nodeTy
),

43 
offtof
(
IID_X2__nodeTy
, 
_a_x
),

44 
offtof
(
IID_X2__nodeTy
, 
e
),

45 (((
IID_X2__nodeTy
 *)0)->
e
),

46 
a_MAP_nodeTy_g2_2
,

52 
a_TYPE_dest_t
 
	ga_DEF_nodeTy_2
 = {

55 &
a_OP_CHOICE
,

60 { 0, &
a_PER_ty_nodeTy_cڡr_2
, 
CHOICE_cڡt
 },

61 
a_MBR_nodeTy_2
,

63 &
a_SPC_nodeTy_ecs_2


66 
a_TYPE_memb_t
 
	ga_MBR_IID_X2_1
[] = {

67 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_X2
, 
nodeTy
),

68 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

70 &
a_DEF_nodeTy_2
,

77 cڡ 
b_v_g_t
 
	ga_DEF_IID_X2_gs_1
[] = {

78 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

80 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_X2_g2_1
[] = {

81 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

83 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_X2_ecs_1
 = {

84 (
IID_X2
),

85 
offtof
(
IID_X2
, 
_a_x
),

86 
a_MAP_IID_X2_g2_1
,

91 
a_TYPE_dest_t
 
	ga_DEF_IID_X2
 = {

94 &
a_OP_SEQUENCE
,

95 
a_DEF_IID_X2_gs_1
,

96 (
a_DEF_IID_X2_gs_1
)

97 /(
a_DEF_IID_X2_gs_1
[0]),

98 
a_DEF_IID_X2_gs_1
,

99 (
a_DEF_IID_X2_gs_1
)

100 /(
a_DEF_IID_X2_gs_1
[0]),

101 { 0, 0, 
SEQUENCE_cڡt
 },

102 
a_MBR_IID_X2_1
,

104 &
a_SPC_IID_X2_ecs_1


	@InterfaceID-Xn.c

8 
	~"IID-Xn.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_IID_Xn_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
IID_Xn
, 
glob_NG_RAN_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GlobNGRANNodeID
,

21 cڡ 
b_v_g_t
 
	ga_DEF_IID_Xn_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IID_Xn_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_IID_Xn_ecs_1
 = {

28 (
IID_Xn
),

29 
offtof
(
IID_Xn
, 
_a_x
),

30 
a_MAP_IID_Xn_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_IID_Xn
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_IID_Xn_gs_1
,

40 (
a_DEF_IID_Xn_gs_1
)

41 /(
a_DEF_IID_Xn_gs_1
[0]),

42 
a_DEF_IID_Xn_gs_1
,

43 (
a_DEF_IID_Xn_gs_1
)

44 /(
a_DEF_IID_Xn_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_IID_Xn_1
,

48 &
a_SPC_IID_Xn_ecs_1


	@InterfaceIdentifier.c

8 
	~"IIdtifr.h
"

10 
	~"IID-NG.h
"

11 
	~"IID-Xn.h
"

12 
	~"IID-F1.h
"

13 
	~"IID-E1.h
"

14 
	~"IID-S1.h
"

15 
	~"IID-X2.h
"

16 
	~"IID-W1.h
"

17 
a_r_cڡts_t
 
a_PER_ty_IIdtifr_cڡr_1
 
	gCC_NOTUSED
 = {

18 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 6 } ,

19 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

22 
a_TYPE_memb_t
 
	ga_MBR_IIdtifr_1
[] = {

23 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
nG
),

24 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

26 &
a_DEF_IID_NG
,

32 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
xN
),

33 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

35 &
a_DEF_IID_Xn
,

41 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
f1
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

44 &
a_DEF_IID_F1
,

50 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
e1
),

51 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

53 &
a_DEF_IID_E1
,

59 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
s1
),

60 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

62 &
a_DEF_IID_S1
,

68 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
x2
),

69 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

71 &
a_DEF_IID_X2
,

77 { 
ATF_POINTER
, 0, 
offtof
(
IIdtifr
, 
choi
.
w1
),

78 (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)),

80 &
a_DEF_IID_W1
,

87 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_IIdtifr_g2_1
[] = {

88 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

89 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

90 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

91 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

92 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

93 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 },

94 { (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)), 6, 0, 0 }

96 
a_CHOICE_ecifics_t
 
	ga_SPC_IIdtifr_ecs_1
 = {

97 (
IIdtifr
),

98 
offtof
(
IIdtifr
, 
_a_x
),

99 
offtof
(
IIdtifr
, 
e
),

100 (((
IIdtifr
 *)0)->
e
),

101 
a_MAP_IIdtifr_g2_1
,

106 
a_TYPE_dest_t
 
	ga_DEF_IIdtifr
 = {

109 &
a_OP_CHOICE
,

114 { 0, &
a_PER_ty_IIdtifr_cڡr_1
, 
CHOICE_cڡt
 },

115 
a_MBR_IIdtifr_1
,

117 &
a_SPC_IIdtifr_ecs_1


	@InterfaceType.c

8 
	~"ITy.h
"

14 
a_r_cڡts_t
 
a_PER_ty_ITy_cڡr_1
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 6 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_ITy_vue2um_1
[] = {

29 cڡ 
	ga_MAP_ITy_um2vue_1
[] = {

39 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_ITy_ecs_1
 = {

40 
a_MAP_ITy_vue2um_1
,

41 
a_MAP_ITy_um2vue_1
,

48 cڡ 
b_v_g_t
 
	ga_DEF_ITy_gs_1
[] = {

49 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

51 
a_TYPE_dest_t
 
	ga_DEF_ITy
 = {

54 &
a_OP_NiveEnumed
,

55 
a_DEF_ITy_gs_1
,

56 (
a_DEF_ITy_gs_1
)

57 /(
a_DEF_ITy_gs_1
[0]),

58 
a_DEF_ITy_gs_1
,

59 (
a_DEF_ITy_gs_1
)

60 /(
a_DEF_ITy_gs_1
[0]),

61 { 0, &
a_PER_ty_ITy_cڡr_1
, 
NiveEnumed_cڡt
 },

63 &
a_SPC_ITy_ecs_1


	@LabelInfoItem.c

8 
	~"LabInfoIm.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_LabInfoIm_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
LabInfoIm
, 
msLab
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_MsumtLab
,

21 cڡ 
b_v_g_t
 
	ga_DEF_LabInfoIm_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_LabInfoIm_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_LabInfoIm_ecs_1
 = {

28 (
LabInfoIm
),

29 
offtof
(
LabInfoIm
, 
_a_x
),

30 
a_MAP_LabInfoIm_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_LabInfoIm
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_LabInfoIm_gs_1
,

40 (
a_DEF_LabInfoIm_gs_1
)

41 /(
a_DEF_LabInfoIm_gs_1
[0]),

42 
a_DEF_LabInfoIm_gs_1
,

43 (
a_DEF_LabInfoIm_gs_1
)

44 /(
a_DEF_LabInfoIm_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_LabInfoIm_1
,

48 &
a_SPC_LabInfoIm_ecs_1


	@LabelInfoList.c

8 
	~"LabInfoLi.h
"

10 
	~"LabInfoIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_LabInfoLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 31, -1, 1, 2147483647 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_LabInfoLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_LabInfoIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_LabInfoLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_LabInfoLi_ecs_1
 = {

31 (
LabInfoLi
),

32 
offtof
(
LabInfoLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_LabInfoLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_LabInfoLi_gs_1
,

40 (
a_DEF_LabInfoLi_gs_1
)

41 /(
a_DEF_LabInfoLi_gs_1
[0]),

42 
a_DEF_LabInfoLi_gs_1
,

43 (
a_DEF_LabInfoLi_gs_1
)

44 /(
a_DEF_LabInfoLi_gs_1
[0]),

45 { 0, &
a_PER_ty_LabInfoLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_LabInfoLi_1
,

48 &
a_SPC_LabInfoLi_ecs_1


	@MME-Code.c

8 
	~"MME-Code.h
"

11 
	$MME_Code_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 1)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_MME_Code_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 1, 1 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_MME_Code_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_MME_Code
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_MME_Code_gs_1
,

53 (
a_DEF_MME_Code_gs_1
)

54 /(
a_DEF_MME_Code_gs_1
[0]),

55 
a_DEF_MME_Code_gs_1
,

56 (
a_DEF_MME_Code_gs_1
)

57 /(
a_DEF_MME_Code_gs_1
[0]),

58 { 0, &
a_PER_ty_MME_Code_cڡr_1
, 
MME_Code_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@MME-Group-ID.c

8 
	~"MME-Group-ID.h
"

11 
	$MME_Group_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 2)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_MME_Group_ID_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 2, 2 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_MME_Group_ID_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_MME_Group_ID
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_MME_Group_ID_gs_1
,

53 (
a_DEF_MME_Group_ID_gs_1
)

54 /(
a_DEF_MME_Group_ID_gs_1
[0]),

55 
a_DEF_MME_Group_ID_gs_1
,

56 (
a_DEF_MME_Group_ID_gs_1
)

57 /(
a_DEF_MME_Group_ID_gs_1
[0]),

58 { 0, &
a_PER_ty_MME_Group_ID_cڡr_1
, 
MME_Group_ID_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@MME-UE-S1AP-ID.c

8 
	~"MME-UE-S1AP-ID.h
"

11 
	$MME_UE_S1AP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

30 
a_r_cڡts_t
 
a_PER_ty_MME_UE_S1AP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

31 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

32 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_MME_UE_S1AP_ID_ecs_1
 = {

40 cڡ 
b_v_g_t
 
	ga_DEF_MME_UE_S1AP_ID_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

43 
a_TYPE_dest_t
 
	ga_DEF_MME_UE_S1AP_ID
 = {

46 &
a_OP_NiveIeg
,

47 
a_DEF_MME_UE_S1AP_ID_gs_1
,

48 (
a_DEF_MME_UE_S1AP_ID_gs_1
)

49 /(
a_DEF_MME_UE_S1AP_ID_gs_1
[0]),

50 
a_DEF_MME_UE_S1AP_ID_gs_1
,

51 (
a_DEF_MME_UE_S1AP_ID_gs_1
)

52 /(
a_DEF_MME_UE_S1AP_ID_gs_1
[0]),

53 { 0, &
a_PER_ty_MME_UE_S1AP_ID_cڡr_1
, 
MME_UE_S1AP_ID_cڡt
 },

55 &
a_SPC_MME_UE_S1AP_ID_ecs_1


	@MatchingCondItem.c

8 
	~"MchgCdIm.h
"

10 
	~"MsumtLab.h
"

11 
	~"TeCdInfo.h
"

12 
a_r_cڡts_t
 
a_PER_ty_MchgCdIm_cڡr_1
 
	gCC_NOTUSED
 = {

13 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

14 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

17 
a_TYPE_memb_t
 
	ga_MBR_MchgCdIm_1
[] = {

18 { 
ATF_POINTER
, 0, 
offtof
(
MchgCdIm
, 
choi
.
msLab
),

19 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

21 &
a_DEF_MsumtLab
,

27 { 
ATF_POINTER
, 0, 
offtof
(
MchgCdIm
, 
choi
.
CdInfo
),

28 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

30 &
a_DEF_TeCdInfo
,

37 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MchgCdIm_g2_1
[] = {

38 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

39 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

41 
a_CHOICE_ecifics_t
 
	ga_SPC_MchgCdIm_ecs_1
 = {

42 (
MchgCdIm
),

43 
offtof
(
MchgCdIm
, 
_a_x
),

44 
offtof
(
MchgCdIm
, 
e
),

45 (((
MchgCdIm
 *)0)->
e
),

46 
a_MAP_MchgCdIm_g2_1
,

51 
a_TYPE_dest_t
 
	ga_DEF_MchgCdIm
 = {

54 &
a_OP_CHOICE
,

59 { 0, &
a_PER_ty_MchgCdIm_cڡr_1
, 
CHOICE_cڡt
 },

60 
a_MBR_MchgCdIm_1
,

62 &
a_SPC_MchgCdIm_ecs_1


	@MatchingCondList.c

8 
	~"MchgCdLi.h
"

10 
	~"MchgCdIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MchgCdLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 15, 15, 1, 32768 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MchgCdLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

20 &
a_DEF_MchgCdIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MchgCdLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MchgCdLi_ecs_1
 = {

31 (
MchgCdLi
),

32 
offtof
(
MchgCdLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MchgCdLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MchgCdLi_gs_1
,

40 (
a_DEF_MchgCdLi_gs_1
)

41 /(
a_DEF_MchgCdLi_gs_1
[0]),

42 
a_DEF_MchgCdLi_gs_1
,

43 (
a_DEF_MchgCdLi_gs_1
)

44 /(
a_DEF_MchgCdLi_gs_1
[0]),

45 { 0, &
a_PER_ty_MchgCdLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MchgCdLi_1
,

48 &
a_SPC_MchgCdLi_ecs_1


	@MatchingUEidItem.c

8 
	~"MchgUEidIm.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_MchgUEidIm_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
MchgUEidIm
, 
ueID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_UEID
,

21 cڡ 
b_v_g_t
 
	ga_DEF_MchgUEidIm_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MchgUEidIm_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MchgUEidIm_ecs_1
 = {

28 (
MchgUEidIm
),

29 
offtof
(
MchgUEidIm
, 
_a_x
),

30 
a_MAP_MchgUEidIm_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_MchgUEidIm
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_MchgUEidIm_gs_1
,

40 (
a_DEF_MchgUEidIm_gs_1
)

41 /(
a_DEF_MchgUEidIm_gs_1
[0]),

42 
a_DEF_MchgUEidIm_gs_1
,

43 (
a_DEF_MchgUEidIm_gs_1
)

44 /(
a_DEF_MchgUEidIm_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_MchgUEidIm_1
,

48 &
a_SPC_MchgUEidIm_ecs_1


	@MatchingUEidList.c

8 
	~"MchgUEidLi.h
"

10 
	~"MchgUEidIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MchgUEidLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MchgUEidLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MchgUEidIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MchgUEidLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MchgUEidLi_ecs_1
 = {

31 (
MchgUEidLi
),

32 
offtof
(
MchgUEidLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MchgUEidLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MchgUEidLi_gs_1
,

40 (
a_DEF_MchgUEidLi_gs_1
)

41 /(
a_DEF_MchgUEidLi_gs_1
[0]),

42 
a_DEF_MchgUEidLi_gs_1
,

43 (
a_DEF_MchgUEidLi_gs_1
)

44 /(
a_DEF_MchgUEidLi_gs_1
[0]),

45 { 0, &
a_PER_ty_MchgUEidLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MchgUEidLi_1
,

48 &
a_SPC_MchgUEidLi_ecs_1


	@MeasurementCondItem.c

8 
	~"MsumtCdIm.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_MsumtCdIm_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtCdIm
, 
msTy
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_MsumtTy
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtCdIm
, 
mchgCd
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_MchgCdLi
,

30 cڡ 
b_v_g_t
 
	ga_DEF_MsumtCdIm_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtCdIm_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtCdIm_ecs_1
 = {

38 (
MsumtCdIm
),

39 
offtof
(
MsumtCdIm
, 
_a_x
),

40 
a_MAP_MsumtCdIm_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_MsumtCdIm
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_MsumtCdIm_gs_1
,

50 (
a_DEF_MsumtCdIm_gs_1
)

51 /(
a_DEF_MsumtCdIm_gs_1
[0]),

52 
a_DEF_MsumtCdIm_gs_1
,

53 (
a_DEF_MsumtCdIm_gs_1
)

54 /(
a_DEF_MsumtCdIm_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_MsumtCdIm_1
,

58 &
a_SPC_MsumtCdIm_ecs_1


	@MeasurementCondList.c

8 
	~"MsumtCdLi.h
"

10 
	~"MsumtCdIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtCdLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtCdLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MsumtCdIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtCdLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtCdLi_ecs_1
 = {

31 (
MsumtCdLi
),

32 
offtof
(
MsumtCdLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtCdLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtCdLi_gs_1
,

40 (
a_DEF_MsumtCdLi_gs_1
)

41 /(
a_DEF_MsumtCdLi_gs_1
[0]),

42 
a_DEF_MsumtCdLi_gs_1
,

43 (
a_DEF_MsumtCdLi_gs_1
)

44 /(
a_DEF_MsumtCdLi_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtCdLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtCdLi_1
,

48 &
a_SPC_MsumtCdLi_ecs_1


	@MeasurementCondUEidItem.c

8 
	~"MsumtCdUEidIm.h
"

10 
	~"MchgUEidLi.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_MsumtCdUEidIm_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtCdUEidIm
, 
msTy
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_MsumtTy
,

21 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtCdUEidIm
, 
mchgCd
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_MchgCdLi
,

30 { 
ATF_POINTER
, 1, 
offtof
(
MsumtCdUEidIm
, 
mchgUEidLi
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_MchgUEidLi
,

40 cڡ 
	ga_MAP_MsumtCdUEidIm_oms_1
[] = { 2 };

41 cڡ 
b_v_g_t
 
	ga_DEF_MsumtCdUEidIm_gs_1
[] = {

42 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

44 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtCdUEidIm_g2_1
[] = {

45 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

47 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

49 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtCdUEidIm_ecs_1
 = {

50 (
MsumtCdUEidIm
),

51 
offtof
(
MsumtCdUEidIm
, 
_a_x
),

52 
a_MAP_MsumtCdUEidIm_g2_1
,

54 
a_MAP_MsumtCdUEidIm_oms_1
,

58 
a_TYPE_dest_t
 
	ga_DEF_MsumtCdUEidIm
 = {

61 &
a_OP_SEQUENCE
,

62 
a_DEF_MsumtCdUEidIm_gs_1
,

63 (
a_DEF_MsumtCdUEidIm_gs_1
)

64 /(
a_DEF_MsumtCdUEidIm_gs_1
[0]),

65 
a_DEF_MsumtCdUEidIm_gs_1
,

66 (
a_DEF_MsumtCdUEidIm_gs_1
)

67 /(
a_DEF_MsumtCdUEidIm_gs_1
[0]),

68 { 0, 0, 
SEQUENCE_cڡt
 },

69 
a_MBR_MsumtCdUEidIm_1
,

71 &
a_SPC_MsumtCdUEidIm_ecs_1


	@MeasurementCondUEidList.c

8 
	~"MsumtCdUEidLi.h
"

10 
	~"MsumtCdUEidIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtCdUEidLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtCdUEidLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MsumtCdUEidIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtCdUEidLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtCdUEidLi_ecs_1
 = {

31 (
MsumtCdUEidLi
),

32 
offtof
(
MsumtCdUEidLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtCdUEidLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtCdUEidLi_gs_1
,

40 (
a_DEF_MsumtCdUEidLi_gs_1
)

41 /(
a_DEF_MsumtCdUEidLi_gs_1
[0]),

42 
a_DEF_MsumtCdUEidLi_gs_1
,

43 (
a_DEF_MsumtCdUEidLi_gs_1
)

44 /(
a_DEF_MsumtCdUEidLi_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtCdUEidLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtCdUEidLi_1
,

48 &
a_SPC_MsumtCdUEidLi_ecs_1


	@MeasurementData.c

8 
	~"MsumtDa.h
"

10 
	~"MsumtDaIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtDa_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtDa_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MsumtDaIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtDa_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtDa_ecs_1
 = {

31 (
MsumtDa
),

32 
offtof
(
MsumtDa
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtDa
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtDa_gs_1
,

40 (
a_DEF_MsumtDa_gs_1
)

41 /(
a_DEF_MsumtDa_gs_1
[0]),

42 
a_DEF_MsumtDa_gs_1
,

43 (
a_DEF_MsumtDa_gs_1
)

44 /(
a_DEF_MsumtDa_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtDa_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtDa_1
,

48 &
a_SPC_MsumtDa_ecs_1


	@MeasurementDataItem.c

8 
	~"MsumtDaIm.h
"

14 
a_r_cڡts_t
 
a_PER_ty_comeFg_cڡr_3
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_comeFg_vue2um_3
[] = {

23 cڡ 
	ga_MAP_comeFg_um2vue_3
[] = {

27 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_comeFg_ecs_3
 = {

28 
a_MAP_comeFg_vue2um_3
,

29 
a_MAP_comeFg_um2vue_3
,

36 cڡ 
b_v_g_t
 
	ga_DEF_comeFg_gs_3
[] = {

37 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

38 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

41 
a_TYPE_dest_t
 
	ga_DEF_comeFg_3
 = {

44 &
a_OP_NiveEnumed
,

45 
a_DEF_comeFg_gs_3
,

46 (
a_DEF_comeFg_gs_3
)

47 /(
a_DEF_comeFg_gs_3
[0]) - 1,

48 
a_DEF_comeFg_gs_3
,

49 (
a_DEF_comeFg_gs_3
)

50 /(
a_DEF_comeFg_gs_3
[0]),

51 { 0, &
a_PER_ty_comeFg_cڡr_3
, 
NiveEnumed_cڡt
 },

53 &
a_SPC_comeFg_ecs_3


56 
a_TYPE_memb_t
 
	ga_MBR_MsumtDaIm_1
[] = {

57 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtDaIm
, 
msRecd
),

58 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

60 &
a_DEF_MsumtRecd
,

66 { 
ATF_POINTER
, 1, 
offtof
(
MsumtDaIm
, 
comeFg
),

67 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

69 &
a_DEF_comeFg_3
,

76 cڡ 
	ga_MAP_MsumtDaIm_oms_1
[] = { 1 };

77 cڡ 
b_v_g_t
 
	ga_DEF_MsumtDaIm_gs_1
[] = {

78 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

80 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtDaIm_g2_1
[] = {

81 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

82 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

84 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtDaIm_ecs_1
 = {

85 (
MsumtDaIm
),

86 
offtof
(
MsumtDaIm
, 
_a_x
),

87 
a_MAP_MsumtDaIm_g2_1
,

89 
a_MAP_MsumtDaIm_oms_1
,

93 
a_TYPE_dest_t
 
	ga_DEF_MsumtDaIm
 = {

96 &
a_OP_SEQUENCE
,

97 
a_DEF_MsumtDaIm_gs_1
,

98 (
a_DEF_MsumtDaIm_gs_1
)

99 /(
a_DEF_MsumtDaIm_gs_1
[0]),

100 
a_DEF_MsumtDaIm_gs_1
,

101 (
a_DEF_MsumtDaIm_gs_1
)

102 /(
a_DEF_MsumtDaIm_gs_1
[0]),

103 { 0, 0, 
SEQUENCE_cڡt
 },

104 
a_MBR_MsumtDaIm_1
,

106 &
a_SPC_MsumtDaIm_ecs_1


	@MeasurementInfo-Action-Item.c

8 
	~"MsumtInfo-Ai-Im.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_MsumtInfo_Ai_Im_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtInfo_Ai_Im
, 
msName
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_MsumtTyName
,

20 { 
ATF_POINTER
, 1, 
offtof
(
MsumtInfo_Ai_Im
, 
msID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_MsumtTyID
,

30 cڡ 
	ga_MAP_MsumtInfo_Ai_Im_oms_1
[] = { 1 };

31 cڡ 
b_v_g_t
 
	ga_DEF_MsumtInfo_Ai_Im_gs_1
[] = {

32 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

34 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtInfo_Ai_Im_g2_1
[] = {

35 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

36 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

38 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtInfo_Ai_Im_ecs_1
 = {

39 (
MsumtInfo_Ai_Im
),

40 
offtof
(
MsumtInfo_Ai_Im
, 
_a_x
),

41 
a_MAP_MsumtInfo_Ai_Im_g2_1
,

43 
a_MAP_MsumtInfo_Ai_Im_oms_1
,

47 
a_TYPE_dest_t
 
	ga_DEF_MsumtInfo_Ai_Im
 = {

50 &
a_OP_SEQUENCE
,

51 
a_DEF_MsumtInfo_Ai_Im_gs_1
,

52 (
a_DEF_MsumtInfo_Ai_Im_gs_1
)

53 /(
a_DEF_MsumtInfo_Ai_Im_gs_1
[0]),

54 
a_DEF_MsumtInfo_Ai_Im_gs_1
,

55 (
a_DEF_MsumtInfo_Ai_Im_gs_1
)

56 /(
a_DEF_MsumtInfo_Ai_Im_gs_1
[0]),

57 { 0, 0, 
SEQUENCE_cڡt
 },

58 
a_MBR_MsumtInfo_Ai_Im_1
,

60 &
a_SPC_MsumtInfo_Ai_Im_ecs_1


	@MeasurementInfo-Action-List.c

8 
	~"MsumtInfo-Ai-Li.h
"

10 
	~"MsumtInfo-Ai-Im.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtInfo_Ai_Li_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtInfo_Ai_Li_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MsumtInfo_Ai_Im
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtInfo_Ai_Li_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtInfo_Ai_Li_ecs_1
 = {

31 (
MsumtInfo_Ai_Li
),

32 
offtof
(
MsumtInfo_Ai_Li
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtInfo_Ai_Li
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtInfo_Ai_Li_gs_1
,

40 (
a_DEF_MsumtInfo_Ai_Li_gs_1
)

41 /(
a_DEF_MsumtInfo_Ai_Li_gs_1
[0]),

42 
a_DEF_MsumtInfo_Ai_Li_gs_1
,

43 (
a_DEF_MsumtInfo_Ai_Li_gs_1
)

44 /(
a_DEF_MsumtInfo_Ai_Li_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtInfo_Ai_Li_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtInfo_Ai_Li_1
,

48 &
a_SPC_MsumtInfo_Ai_Li_ecs_1


	@MeasurementInfoItem.c

8 
	~"MsumtInfoIm.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_MsumtInfoIm_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtInfoIm
, 
msTy
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_MsumtTy
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtInfoIm
, 
bInfoLi
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_LabInfoLi
,

30 cڡ 
b_v_g_t
 
	ga_DEF_MsumtInfoIm_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtInfoIm_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtInfoIm_ecs_1
 = {

38 (
MsumtInfoIm
),

39 
offtof
(
MsumtInfoIm
, 
_a_x
),

40 
a_MAP_MsumtInfoIm_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_MsumtInfoIm
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_MsumtInfoIm_gs_1
,

50 (
a_DEF_MsumtInfoIm_gs_1
)

51 /(
a_DEF_MsumtInfoIm_gs_1
[0]),

52 
a_DEF_MsumtInfoIm_gs_1
,

53 (
a_DEF_MsumtInfoIm_gs_1
)

54 /(
a_DEF_MsumtInfoIm_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_MsumtInfoIm_1
,

58 &
a_SPC_MsumtInfoIm_ecs_1


	@MeasurementInfoList.c

8 
	~"MsumtInfoLi.h
"

10 
	~"MsumtInfoIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtInfoLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtInfoLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_MsumtInfoIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtInfoLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtInfoLi_ecs_1
 = {

31 (
MsumtInfoLi
),

32 
offtof
(
MsumtInfoLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtInfoLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtInfoLi_gs_1
,

40 (
a_DEF_MsumtInfoLi_gs_1
)

41 /(
a_DEF_MsumtInfoLi_gs_1
[0]),

42 
a_DEF_MsumtInfoLi_gs_1
,

43 (
a_DEF_MsumtInfoLi_gs_1
)

44 /(
a_DEF_MsumtInfoLi_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtInfoLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtInfoLi_1
,

48 &
a_SPC_MsumtInfoLi_ecs_1


	@MeasurementLabel.c

8 
	~"MsumtLab.h
"

10 
	~"S-NSSAI.h
"

40 
	$memb_aRPmax_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

41 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

42 
vue
;

44 if(!

) {

45 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

47 
td
->
me
, 
__FILE__
, 
__LINE__
);

51 
vue
 = *(cڡ *)

;

53 if((
vue
 >= 1 && value <= 15)) {

57 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

59 
td
->
me
, 
__FILE__
, 
__LINE__
);

62 
	}
}

65 
	$memb_aRPm_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

66 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

67 
vue
;

69 if(!

) {

70 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

72 
td
->
me
, 
__FILE__
, 
__LINE__
);

76 
vue
 = *(cڡ *)

;

78 if((
vue
 >= 1 && value <= 15)) {

82 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

84 
td
->
me
, 
__FILE__
, 
__LINE__
);

87 
	}
}

90 
	$memb_bRge_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

91 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

92 
vue
;

94 if(!

) {

95 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

97 
td
->
me
, 
__FILE__
, 
__LINE__
);

101 
vue
 = *(cڡ *)

;

103 if((
vue
 >= 1 && value <= 65535)) {

107 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

109 
td
->
me
, 
__FILE__
, 
__LINE__
);

112 
	}
}

115 
	$memb_yMU_MIMO_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

116 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

117 
vue
;

119 if(!

) {

120 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

122 
td
->
me
, 
__FILE__
, 
__LINE__
);

126 
vue
 = *(cڡ *)

;

128 if((
vue
 >= 1 && value <= 65535)) {

132 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

134 
td
->
me
, 
__FILE__
, 
__LINE__
);

137 
	}
}

140 
	$memb_diBX_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

141 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

142 
vue
;

144 if(!

) {

145 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

147 
td
->
me
, 
__FILE__
, 
__LINE__
);

151 
vue
 = *(cڡ *)

;

153 if((
vue
 >= 1 && value <= 65535)) {

157 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

159 
td
->
me
, 
__FILE__
, 
__LINE__
);

162 
	}
}

165 
	$memb_diBY_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

166 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

167 
vue
;

169 if(!

) {

170 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

172 
td
->
me
, 
__FILE__
, 
__LINE__
);

176 
vue
 = *(cڡ *)

;

178 if((
vue
 >= 1 && value <= 65535)) {

182 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

184 
td
->
me
, 
__FILE__
, 
__LINE__
);

187 
	}
}

190 
	$memb_diBZ_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

191 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

192 
vue
;

194 if(!

) {

195 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

197 
td
->
me
, 
__FILE__
, 
__LINE__
);

201 
vue
 = *(cڡ *)

;

203 if((
vue
 >= 1 && value <= 65535)) {

207 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

209 
td
->
me
, 
__FILE__
, 
__LINE__
);

212 
	}
}

214 
a_r_cڡts_t
 
a_PER_ty_noLab_cڡr_2
 
	gCC_NOTUSED
 = {

215 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

216 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

219 
a_r_cڡts_t
 
a_PER_ty_sUM_cڡr_16
 
	gCC_NOTUSED
 = {

220 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

221 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

224 
a_r_cڡts_t
 
a_PER_ty_eLabOvride_cڡr_22
 
	gCC_NOTUSED
 = {

225 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

226 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

229 
a_r_cڡts_t
 
a_PER_ty_tEndInd_cڡr_25
 
	gCC_NOTUSED
 = {

230 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

231 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

234 
a_r_cڡts_t
 
a_PER_ty_m_cڡr_29
 
	gCC_NOTUSED
 = {

235 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

236 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

239 
a_r_cڡts_t
 
a_PER_ty_max_cڡr_32
 
	gCC_NOTUSED
 = {

240 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

241 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

244 
a_r_cڡts_t
 
a_PER_ty_avg_cڡr_35
 
	gCC_NOTUSED
 = {

245 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

246 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

249 
a_r_cڡts_t
 
a_PER_memb_aRPmax_cڡr_12
 
	gCC_NOTUSED
 = {

250 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 4, 4, 1, 15 } ,

251 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

254 
a_r_cڡts_t
 
a_PER_memb_aRPm_cڡr_13
 
	gCC_NOTUSED
 = {

255 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 4, 4, 1, 15 } ,

256 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

259 
a_r_cڡts_t
 
a_PER_memb_bRge_cڡr_14
 
	gCC_NOTUSED
 = {

260 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, 16, 1, 65535 } ,

261 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

264 
a_r_cڡts_t
 
a_PER_memb_yMU_MIMO_cڡr_15
 
	gCC_NOTUSED
 = {

265 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, 16, 1, 65535 } ,

266 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

269 
a_r_cڡts_t
 
a_PER_memb_diBX_cڡr_19
 
	gCC_NOTUSED
 = {

270 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, 16, 1, 65535 } ,

271 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

274 
a_r_cڡts_t
 
a_PER_memb_diBY_cڡr_20
 
	gCC_NOTUSED
 = {

275 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, 16, 1, 65535 } ,

276 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

279 
a_r_cڡts_t
 
a_PER_memb_diBZ_cڡr_21
 
	gCC_NOTUSED
 = {

280 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, 16, 1, 65535 } ,

281 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

284 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_noLab_vue2um_2
[] = {

288 cڡ 
	ga_MAP_noLab_um2vue_2
[] = {

292 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_noLab_ecs_2
 = {

293 
a_MAP_noLab_vue2um_2
,

294 
a_MAP_noLab_um2vue_2
,

301 cڡ 
b_v_g_t
 
	ga_DEF_noLab_gs_2
[] = {

302 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

303 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

306 
a_TYPE_dest_t
 
	ga_DEF_noLab_2
 = {

309 &
a_OP_NiveEnumed
,

310 
a_DEF_noLab_gs_2
,

311 (
a_DEF_noLab_gs_2
)

312 /(
a_DEF_noLab_gs_2
[0]) - 1,

313 
a_DEF_noLab_gs_2
,

314 (
a_DEF_noLab_gs_2
)

315 /(
a_DEF_noLab_gs_2
[0]),

316 { 0, &
a_PER_ty_noLab_cڡr_2
, 
NiveEnumed_cڡt
 },

318 &
a_SPC_noLab_ecs_2


321 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_sUM_vue2um_16
[] = {

325 cڡ 
	ga_MAP_sUM_um2vue_16
[] = {

329 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_sUM_ecs_16
 = {

330 
a_MAP_sUM_vue2um_16
,

331 
a_MAP_sUM_um2vue_16
,

338 cڡ 
b_v_g_t
 
	ga_DEF_sUM_gs_16
[] = {

339 (
ASN_TAG_CLASS_CONTEXT
 | (12 << 2)),

340 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

343 
a_TYPE_dest_t
 
	ga_DEF_sUM_16
 = {

346 &
a_OP_NiveEnumed
,

347 
a_DEF_sUM_gs_16
,

348 (
a_DEF_sUM_gs_16
)

349 /(
a_DEF_sUM_gs_16
[0]) - 1,

350 
a_DEF_sUM_gs_16
,

351 (
a_DEF_sUM_gs_16
)

352 /(
a_DEF_sUM_gs_16
[0]),

353 { 0, &
a_PER_ty_sUM_cڡr_16
, 
NiveEnumed_cڡt
 },

355 &
a_SPC_sUM_ecs_16


358 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_eLabOvride_vue2um_22
[] = {

362 cڡ 
	ga_MAP_eLabOvride_um2vue_22
[] = {

366 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_eLabOvride_ecs_22
 = {

367 
a_MAP_eLabOvride_vue2um_22
,

368 
a_MAP_eLabOvride_um2vue_22
,

375 cڡ 
b_v_g_t
 
	ga_DEF_eLabOvride_gs_22
[] = {

376 (
ASN_TAG_CLASS_CONTEXT
 | (16 << 2)),

377 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

380 
a_TYPE_dest_t
 
	ga_DEF_eLabOvride_22
 = {

383 &
a_OP_NiveEnumed
,

384 
a_DEF_eLabOvride_gs_22
,

385 (
a_DEF_eLabOvride_gs_22
)

386 /(
a_DEF_eLabOvride_gs_22
[0]) - 1,

387 
a_DEF_eLabOvride_gs_22
,

388 (
a_DEF_eLabOvride_gs_22
)

389 /(
a_DEF_eLabOvride_gs_22
[0]),

390 { 0, &
a_PER_ty_eLabOvride_cڡr_22
, 
NiveEnumed_cڡt
 },

392 &
a_SPC_eLabOvride_ecs_22


395 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_tEndInd_vue2um_25
[] = {

400 cڡ 
	ga_MAP_tEndInd_um2vue_25
[] = {

405 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_tEndInd_ecs_25
 = {

406 
a_MAP_tEndInd_vue2um_25
,

407 
a_MAP_tEndInd_um2vue_25
,

414 cڡ 
b_v_g_t
 
	ga_DEF_tEndInd_gs_25
[] = {

415 (
ASN_TAG_CLASS_CONTEXT
 | (17 << 2)),

416 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

419 
a_TYPE_dest_t
 
	ga_DEF_tEndInd_25
 = {

422 &
a_OP_NiveEnumed
,

423 
a_DEF_tEndInd_gs_25
,

424 (
a_DEF_tEndInd_gs_25
)

425 /(
a_DEF_tEndInd_gs_25
[0]) - 1,

426 
a_DEF_tEndInd_gs_25
,

427 (
a_DEF_tEndInd_gs_25
)

428 /(
a_DEF_tEndInd_gs_25
[0]),

429 { 0, &
a_PER_ty_tEndInd_cڡr_25
, 
NiveEnumed_cڡt
 },

431 &
a_SPC_tEndInd_ecs_25


434 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_m_vue2um_29
[] = {

438 cڡ 
	ga_MAP_m_um2vue_29
[] = {

442 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_m_ecs_29
 = {

443 
a_MAP_m_vue2um_29
,

444 
a_MAP_m_um2vue_29
,

451 cڡ 
b_v_g_t
 
	ga_DEF_m_gs_29
[] = {

452 (
ASN_TAG_CLASS_CONTEXT
 | (18 << 2)),

453 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

456 
a_TYPE_dest_t
 
	ga_DEF_m_29
 = {

459 &
a_OP_NiveEnumed
,

460 
a_DEF_m_gs_29
,

461 (
a_DEF_m_gs_29
)

462 /(
a_DEF_m_gs_29
[0]) - 1,

463 
a_DEF_m_gs_29
,

464 (
a_DEF_m_gs_29
)

465 /(
a_DEF_m_gs_29
[0]),

466 { 0, &
a_PER_ty_m_cڡr_29
, 
NiveEnumed_cڡt
 },

468 &
a_SPC_m_ecs_29


471 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_max_vue2um_32
[] = {

475 cڡ 
	ga_MAP_max_um2vue_32
[] = {

479 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_max_ecs_32
 = {

480 
a_MAP_max_vue2um_32
,

481 
a_MAP_max_um2vue_32
,

488 cڡ 
b_v_g_t
 
	ga_DEF_max_gs_32
[] = {

489 (
ASN_TAG_CLASS_CONTEXT
 | (19 << 2)),

490 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

493 
a_TYPE_dest_t
 
	ga_DEF_max_32
 = {

496 &
a_OP_NiveEnumed
,

497 
a_DEF_max_gs_32
,

498 (
a_DEF_max_gs_32
)

499 /(
a_DEF_max_gs_32
[0]) - 1,

500 
a_DEF_max_gs_32
,

501 (
a_DEF_max_gs_32
)

502 /(
a_DEF_max_gs_32
[0]),

503 { 0, &
a_PER_ty_max_cڡr_32
, 
NiveEnumed_cڡt
 },

505 &
a_SPC_max_ecs_32


508 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_avg_vue2um_35
[] = {

512 cڡ 
	ga_MAP_avg_um2vue_35
[] = {

516 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_avg_ecs_35
 = {

517 
a_MAP_avg_vue2um_35
,

518 
a_MAP_avg_um2vue_35
,

525 cڡ 
b_v_g_t
 
	ga_DEF_avg_gs_35
[] = {

526 (
ASN_TAG_CLASS_CONTEXT
 | (20 << 2)),

527 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

530 
a_TYPE_dest_t
 
	ga_DEF_avg_35
 = {

533 &
a_OP_NiveEnumed
,

534 
a_DEF_avg_gs_35
,

535 (
a_DEF_avg_gs_35
)

536 /(
a_DEF_avg_gs_35
[0]) - 1,

537 
a_DEF_avg_gs_35
,

538 (
a_DEF_avg_gs_35
)

539 /(
a_DEF_avg_gs_35
[0]),

540 { 0, &
a_PER_ty_avg_cڡr_35
, 
NiveEnumed_cڡt
 },

542 &
a_SPC_avg_ecs_35


545 
a_TYPE_memb_t
 
	ga_MBR_MsumtLab_1
[] = {

546 { 
ATF_POINTER
, 21, 
offtof
(
MsumtLab
, 
noLab
),

547 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

549 &
a_DEF_noLab_2
,

555 { 
ATF_POINTER
, 20, 
offtof
(
MsumtLab
, 
mnID
),

556 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

558 &
a_DEF_PLMNIdty
,

564 { 
ATF_POINTER
, 19, 
offtof
(
MsumtLab
, 
iID
),

565 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

567 &
a_DEF_S_NSSAI
,

573 { 
ATF_POINTER
, 18, 
offtof
(
MsumtLab
, 
fiveQI
),

574 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

576 &
a_DEF_FiveQI
,

582 { 
ATF_POINTER
, 17, 
offtof
(
MsumtLab
, 
qFI
),

583 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

585 &
a_DEF_QosFlowIdtifr
,

591 { 
ATF_POINTER
, 16, 
offtof
(
MsumtLab
, 
qCI
),

592 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

594 &
a_DEF_QCI
,

600 { 
ATF_POINTER
, 15, 
offtof
(
MsumtLab
, 
qCImax
),

601 (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)),

603 &
a_DEF_QCI
,

609 { 
ATF_POINTER
, 14, 
offtof
(
MsumtLab
, 
qCIm
),

610 (
ASN_TAG_CLASS_CONTEXT
 | (7 << 2)),

612 &
a_DEF_QCI
,

618 { 
ATF_POINTER
, 13, 
offtof
(
MsumtLab
, 
aRPmax
),

619 (
ASN_TAG_CLASS_CONTEXT
 | (8 << 2)),

621 &
a_DEF_NiveIeg
,

623 { 0, &
a_PER_memb_aRPmax_cڡr_12
, 
memb_aRPmax_cڡt_1
 },

627 { 
ATF_POINTER
, 12, 
offtof
(
MsumtLab
, 
aRPm
),

628 (
ASN_TAG_CLASS_CONTEXT
 | (9 << 2)),

630 &
a_DEF_NiveIeg
,

632 { 0, &
a_PER_memb_aRPm_cڡr_13
, 
memb_aRPm_cڡt_1
 },

636 { 
ATF_POINTER
, 11, 
offtof
(
MsumtLab
, 
bRge
),

637 (
ASN_TAG_CLASS_CONTEXT
 | (10 << 2)),

639 &
a_DEF_NiveIeg
,

641 { 0, &
a_PER_memb_bRge_cڡr_14
, 
memb_bRge_cڡt_1
 },

645 { 
ATF_POINTER
, 10, 
offtof
(
MsumtLab
, 
yMU_MIMO
),

646 (
ASN_TAG_CLASS_CONTEXT
 | (11 << 2)),

648 &
a_DEF_NiveIeg
,

650 { 0, &
a_PER_memb_yMU_MIMO_cڡr_15
, 
memb_yMU_MIMO_cڡt_1
 },

654 { 
ATF_POINTER
, 9, 
offtof
(
MsumtLab
, 
sUM
),

655 (
ASN_TAG_CLASS_CONTEXT
 | (12 << 2)),

657 &
a_DEF_sUM_16
,

663 { 
ATF_POINTER
, 8, 
offtof
(
MsumtLab
, 
diBX
),

664 (
ASN_TAG_CLASS_CONTEXT
 | (13 << 2)),

666 &
a_DEF_NiveIeg
,

668 { 0, &
a_PER_memb_diBX_cڡr_19
, 
memb_diBX_cڡt_1
 },

672 { 
ATF_POINTER
, 7, 
offtof
(
MsumtLab
, 
diBY
),

673 (
ASN_TAG_CLASS_CONTEXT
 | (14 << 2)),

675 &
a_DEF_NiveIeg
,

677 { 0, &
a_PER_memb_diBY_cڡr_20
, 
memb_diBY_cڡt_1
 },

681 { 
ATF_POINTER
, 6, 
offtof
(
MsumtLab
, 
diBZ
),

682 (
ASN_TAG_CLASS_CONTEXT
 | (15 << 2)),

684 &
a_DEF_NiveIeg
,

686 { 0, &
a_PER_memb_diBZ_cڡr_21
, 
memb_diBZ_cڡt_1
 },

690 { 
ATF_POINTER
, 5, 
offtof
(
MsumtLab
, 
eLabOvride
),

691 (
ASN_TAG_CLASS_CONTEXT
 | (16 << 2)),

693 &
a_DEF_eLabOvride_22
,

699 { 
ATF_POINTER
, 4, 
offtof
(
MsumtLab
, 
tEndInd
),

700 (
ASN_TAG_CLASS_CONTEXT
 | (17 << 2)),

702 &
a_DEF_tEndInd_25
,

708 { 
ATF_POINTER
, 3, 
offtof
(
MsumtLab
, 
m
),

709 (
ASN_TAG_CLASS_CONTEXT
 | (18 << 2)),

711 &
a_DEF_m_29
,

717 { 
ATF_POINTER
, 2, 
offtof
(
MsumtLab
, 
max
),

718 (
ASN_TAG_CLASS_CONTEXT
 | (19 << 2)),

720 &
a_DEF_max_32
,

726 { 
ATF_POINTER
, 1, 
offtof
(
MsumtLab
, 
avg
),

727 (
ASN_TAG_CLASS_CONTEXT
 | (20 << 2)),

729 &
a_DEF_avg_35
,

736 cڡ 
	ga_MAP_MsumtLab_oms_1
[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };

737 cڡ 
b_v_g_t
 
	ga_DEF_MsumtLab_gs_1
[] = {

738 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

740 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtLab_g2_1
[] = {

741 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

742 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

743 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

744 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

745 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

746 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 },

747 { (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)), 6, 0, 0 },

748 { (
ASN_TAG_CLASS_CONTEXT
 | (7 << 2)), 7, 0, 0 },

749 { (
ASN_TAG_CLASS_CONTEXT
 | (8 << 2)), 8, 0, 0 },

750 { (
ASN_TAG_CLASS_CONTEXT
 | (9 << 2)), 9, 0, 0 },

751 { (
ASN_TAG_CLASS_CONTEXT
 | (10 << 2)), 10, 0, 0 },

752 { (
ASN_TAG_CLASS_CONTEXT
 | (11 << 2)), 11, 0, 0 },

753 { (
ASN_TAG_CLASS_CONTEXT
 | (12 << 2)), 12, 0, 0 },

754 { (
ASN_TAG_CLASS_CONTEXT
 | (13 << 2)), 13, 0, 0 },

755 { (
ASN_TAG_CLASS_CONTEXT
 | (14 << 2)), 14, 0, 0 },

756 { (
ASN_TAG_CLASS_CONTEXT
 | (15 << 2)), 15, 0, 0 },

757 { (
ASN_TAG_CLASS_CONTEXT
 | (16 << 2)), 16, 0, 0 },

758 { (
ASN_TAG_CLASS_CONTEXT
 | (17 << 2)), 17, 0, 0 },

759 { (
ASN_TAG_CLASS_CONTEXT
 | (18 << 2)), 18, 0, 0 },

760 { (
ASN_TAG_CLASS_CONTEXT
 | (19 << 2)), 19, 0, 0 },

761 { (
ASN_TAG_CLASS_CONTEXT
 | (20 << 2)), 20, 0, 0 }

763 
a_SEQUENCE_ecifics_t
 
	ga_SPC_MsumtLab_ecs_1
 = {

764 (
MsumtLab
),

765 
offtof
(
MsumtLab
, 
_a_x
),

766 
a_MAP_MsumtLab_g2_1
,

768 
a_MAP_MsumtLab_oms_1
,

772 
a_TYPE_dest_t
 
	ga_DEF_MsumtLab
 = {

775 &
a_OP_SEQUENCE
,

776 
a_DEF_MsumtLab_gs_1
,

777 (
a_DEF_MsumtLab_gs_1
)

778 /(
a_DEF_MsumtLab_gs_1
[0]),

779 
a_DEF_MsumtLab_gs_1
,

780 (
a_DEF_MsumtLab_gs_1
)

781 /(
a_DEF_MsumtLab_gs_1
[0]),

782 { 0, 0, 
SEQUENCE_cڡt
 },

783 
a_MBR_MsumtLab_1
,

785 &
a_SPC_MsumtLab_ecs_1


	@MeasurementRecord.c

8 
	~"MsumtRecd.h
"

10 
	~"MsumtRecdIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_MsumtRecd_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 31, -1, 1, 2147483647 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_MsumtRecd_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

20 &
a_DEF_MsumtRecdIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_MsumtRecd_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_MsumtRecd_ecs_1
 = {

31 (
MsumtRecd
),

32 
offtof
(
MsumtRecd
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_MsumtRecd
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_MsumtRecd_gs_1
,

40 (
a_DEF_MsumtRecd_gs_1
)

41 /(
a_DEF_MsumtRecd_gs_1
[0]),

42 
a_DEF_MsumtRecd_gs_1
,

43 (
a_DEF_MsumtRecd_gs_1
)

44 /(
a_DEF_MsumtRecd_gs_1
[0]),

45 { 0, &
a_PER_ty_MsumtRecd_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_MsumtRecd_1
,

48 &
a_SPC_MsumtRecd_ecs_1


	@MeasurementRecordItem.c

8 
	~"MsumtRecdIm.h
"

11 
	$g_2_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

31 
	$memb_g_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

32 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

34 if(!

) {

35 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

37 
td
->
me
, 
__FILE__
, 
__LINE__
);

44 
	}
}

46 
a_r_cڡts_t
 
a_PER_ty_g_cڡr_2
 
	gCC_NOTUSED
 = {

47 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

48 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

51 
a_r_cڡts_t
 
a_PER_memb_g_cڡr_2
 
	gCC_NOTUSED
 = {

52 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

53 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

56 
a_r_cڡts_t
 
a_PER_ty_MsumtRecdIm_cڡr_1
 
	gCC_NOTUSED
 = {

57 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 2, 2, 0, 2 } ,

58 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

61 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_g_ecs_2
 = {

66 cڡ 
b_v_g_t
 
	ga_DEF_g_gs_2
[] = {

67 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

68 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

71 
a_TYPE_dest_t
 
	ga_DEF_g_2
 = {

74 &
a_OP_NiveIeg
,

75 
a_DEF_g_gs_2
,

76 (
a_DEF_g_gs_2
)

77 /(
a_DEF_g_gs_2
[0]) - 1,

78 
a_DEF_g_gs_2
,

79 (
a_DEF_g_gs_2
)

80 /(
a_DEF_g_gs_2
[0]),

81 { 0, &
a_PER_ty_g_cڡr_2
, 
g_2_cڡt
 },

83 &
a_SPC_g_ecs_2


86 
a_TYPE_memb_t
 
	ga_MBR_MsumtRecdIm_1
[] = {

87 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtRecdIm
, 
choi
.
g
),

88 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

90 &
a_DEF_g_2
,

92 { 0, &
a_PER_memb_g_cڡr_2
, 
memb_g_cڡt_1
 },

96 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtRecdIm
, 
choi
.

),

97 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

99 &
a_DEF_NiveRl
,

105 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtRecdIm
, 
choi
.
noVue
),

106 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

108 &
a_DEF_NULL
,

115 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtRecdIm_g2_1
[] = {

116 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

117 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

118 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

120 
a_CHOICE_ecifics_t
 
	ga_SPC_MsumtRecdIm_ecs_1
 = {

121 (
MsumtRecdIm
),

122 
offtof
(
MsumtRecdIm
, 
_a_x
),

123 
offtof
(
MsumtRecdIm
, 
e
),

124 (((
MsumtRecdIm
 *)0)->
e
),

125 
a_MAP_MsumtRecdIm_g2_1
,

130 
a_TYPE_dest_t
 
	ga_DEF_MsumtRecdIm
 = {

133 &
a_OP_CHOICE
,

138 { 0, &
a_PER_ty_MsumtRecdIm_cڡr_1
, 
CHOICE_cڡt
 },

139 
a_MBR_MsumtRecdIm_1
,

141 &
a_SPC_MsumtRecdIm_ecs_1


	@MeasurementType.c

8 
	~"MsumtTy.h
"

10 
a_r_cڡts_t
 
a_PER_ty_MsumtTy_cڡr_1
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_MsumtTy_1
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtTy
, 
choi
.
msName
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_MsumtTyName
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
MsumtTy
, 
choi
.
msID
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_MsumtTyID
,

35 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_MsumtTy_g2_1
[] = {

36 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

37 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

39 
a_CHOICE_ecifics_t
 
	ga_SPC_MsumtTy_ecs_1
 = {

40 (
MsumtTy
),

41 
offtof
(
MsumtTy
, 
_a_x
),

42 
offtof
(
MsumtTy
, 
e
),

43 (((
MsumtTy
 *)0)->
e
),

44 
a_MAP_MsumtTy_g2_1
,

49 
a_TYPE_dest_t
 
	ga_DEF_MsumtTy
 = {

52 &
a_OP_CHOICE
,

57 { 0, &
a_PER_ty_MsumtTy_cڡr_1
, 
CHOICE_cڡt
 },

58 
a_MBR_MsumtTy_1
,

60 &
a_SPC_MsumtTy_ecs_1


	@MeasurementTypeID.c

8 
	~"MsumtTyID.h
"

11 
	$MsumtTyID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 65536)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_MsumtTyID_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 16, -1, 1, 65536 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_MsumtTyID_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_MsumtTyID
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_MsumtTyID_gs_1
,

52 (
a_DEF_MsumtTyID_gs_1
)

53 /(
a_DEF_MsumtTyID_gs_1
[0]),

54 
a_DEF_MsumtTyID_gs_1
,

55 (
a_DEF_MsumtTyID_gs_1
)

56 /(
a_DEF_MsumtTyID_gs_1
[0]),

57 { 0, &
a_PER_ty_MsumtTyID_cڡr_1
, 
MsumtTyID_cڡt
 },

	@MeasurementTypeName.c

8 
	~"MsumtTyName.h
"

10 cڡ 
	grmd_phab_b_1
[256] = {

20 cڡ 
	grmd_phab_code2vue_1
[74] = {

28 
	$check_rmd_phab_1
(cڡ *

) {

29 cڡ *
b
 = 
rmd_phab_b_1
;

31 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

32 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

33 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

35 ; 
ch
 < 
d
; ch++) {

36 
ut8_t
 
cv
 = *
ch
;

37 if(!
b
[
cv
])  -1;

40 
	}
}

43 
	$MsumtTyName_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

44 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

45 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

46 
size_t
 
size
;

48 if(!

) {

49 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

51 
td
->
me
, 
__FILE__
, 
__LINE__
);

55 
size
 = 

->size;

57 if((
size
 >= 1 && size <= 150)

58 && !
	`check_rmd_phab_1
(

)) {

62 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

64 
td
->
me
, 
__FILE__
, 
__LINE__
);

67 
	}
}

69 
	$a_PER_MAP_MsumtTyName_1_v2c
(
vue
) {

70 if(
vue
 >(
rmd_phab_b_1
)/(permitted_alphabet_table_1[0]))

72  
rmd_phab_b_1
[
vue
] - 1;

73 
	}
}

74 
	$a_PER_MAP_MsumtTyName_1_c2v
(
code
) {

75 if(
code
 >(
rmd_phab_code2vue_1
)/(permitted_alphabet_code2value_1[0]))

77  
rmd_phab_code2vue_1
[
code
];

78 
	}
}

83 
a_r_cڡts_t
 
a_PER_ty_MsumtTyName_cڡr_1
 
	gCC_NOTUSED
 = {

84 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

85 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 1, 150 } ,

86 
a_PER_MAP_MsumtTyName_1_v2c
,

87 
a_PER_MAP_MsumtTyName_1_c2v


89 cڡ 
b_v_g_t
 
	ga_DEF_MsumtTyName_gs_1
[] = {

90 (
ASN_TAG_CLASS_UNIVERSAL
 | (19 << 2))

92 
a_TYPE_dest_t
 
	ga_DEF_MsumtTyName
 = {

95 &
a_OP_PrbSg
,

96 
a_DEF_MsumtTyName_gs_1
,

97 (
a_DEF_MsumtTyName_gs_1
)

98 /(
a_DEF_MsumtTyName_gs_1
[0]),

99 
a_DEF_MsumtTyName_gs_1
,

100 (
a_DEF_MsumtTyName_gs_1
)

101 /(
a_DEF_MsumtTyName_gs_1
[0]),

102 { 0, &
a_PER_ty_MsumtTyName_cڡr_1
, 
MsumtTyName_cڡt
 },

	@NG-RANnodeUEXnAPID.c

8 
	~"NG-RANnodeUEXnAPID.h
"

11 
	$NG_RANnodeUEXnAPID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

30 
a_r_cڡts_t
 
a_PER_ty_NG_RANnodeUEXnAPID_cڡr_1
 
	gCC_NOTUSED
 = {

31 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

32 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_NG_RANnodeUEXnAPID_ecs_1
 = {

40 cڡ 
b_v_g_t
 
	ga_DEF_NG_RANnodeUEXnAPID_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

43 
a_TYPE_dest_t
 
	ga_DEF_NG_RANnodeUEXnAPID
 = {

46 &
a_OP_NiveIeg
,

47 
a_DEF_NG_RANnodeUEXnAPID_gs_1
,

48 (
a_DEF_NG_RANnodeUEXnAPID_gs_1
)

49 /(
a_DEF_NG_RANnodeUEXnAPID_gs_1
[0]),

50 
a_DEF_NG_RANnodeUEXnAPID_gs_1
,

51 (
a_DEF_NG_RANnodeUEXnAPID_gs_1
)

52 /(
a_DEF_NG_RANnodeUEXnAPID_gs_1
[0]),

53 { 0, &
a_PER_ty_NG_RANnodeUEXnAPID_cڡr_1
, 
NG_RANnodeUEXnAPID_cڡt
 },

55 &
a_SPC_NG_RANnodeUEXnAPID_ecs_1


	@NGENB-CU-UE-W1AP-ID.c

8 
	~"NGENB-CU-UE-W1AP-ID.h
"

11 
	$NGENB_CU_UE_W1AP_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

14 if(!

) {

15 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

17 
td
->
me
, 
__FILE__
, 
__LINE__
);

24 
	}
}

30 
a_r_cڡts_t
 
a_PER_ty_NGENB_CU_UE_W1AP_ID_cڡr_1
 
	gCC_NOTUSED
 = {

31 { 
APC_CONSTRAINED
, 32, -1, 0, 4294967295 } ,

32 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_NGENB_CU_UE_W1AP_ID_ecs_1
 = {

40 cڡ 
b_v_g_t
 
	ga_DEF_NGENB_CU_UE_W1AP_ID_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

43 
a_TYPE_dest_t
 
	ga_DEF_NGENB_CU_UE_W1AP_ID
 = {

46 &
a_OP_NiveIeg
,

47 
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
,

48 (
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
)

49 /(
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
[0]),

50 
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
,

51 (
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
)

52 /(
a_DEF_NGENB_CU_UE_W1AP_ID_gs_1
[0]),

53 { 0, &
a_PER_ty_NGENB_CU_UE_W1AP_ID_cڡr_1
, 
NGENB_CU_UE_W1AP_ID_cڡt
 },

55 &
a_SPC_NGENB_CU_UE_W1AP_ID_ecs_1


	@NGENB-DU-ID.c

8 
	~"NGENB-DU-ID.h
"

11 
	$NGENB_DU_ID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
INTEGER_t
 *

 = (cڡ INTEGER_*)

;

14 
vue
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(
	`a_INTEGER2lg
(

, &
vue
)) {

24 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

26 
td
->
me
, 
__FILE__
, 
__LINE__
);

30 if((
vue
 >= 0 && value <= 68719476735)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_NGENB_DU_ID_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_CONSTRAINED
, 36, -1, 0, 68719476735 } ,

47 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

50 cڡ 
b_v_g_t
 
	ga_DEF_NGENB_DU_ID_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_NGENB_DU_ID
 = {

56 &
a_OP_INTEGER
,

57 
a_DEF_NGENB_DU_ID_gs_1
,

58 (
a_DEF_NGENB_DU_ID_gs_1
)

59 /(
a_DEF_NGENB_DU_ID_gs_1
[0]),

60 
a_DEF_NGENB_DU_ID_gs_1
,

61 (
a_DEF_NGENB_DU_ID_gs_1
)

62 /(
a_DEF_NGENB_DU_ID_gs_1
[0]),

63 { 0, &
a_PER_ty_NGENB_DU_ID_cڡr_1
, 
NGENB_DU_ID_cڡt
 },

	@NR-ARFCN.c

8 
	~"NR-ARFCN.h
"

11 
	$memb_nRARFCN_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 3279165)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

35 
a_r_cڡts_t
 
a_PER_memb_nRARFCN_cڡr_2
 
	gCC_NOTUSED
 = {

36 { 
APC_CONSTRAINED
, 22, -1, 0, 3279165 } ,

37 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

40 
a_TYPE_memb_t
 
	ga_MBR_NR_ARFCN_1
[] = {

41 { 
ATF_NOFLAGS
, 0, 
offtof
(
NR_ARFCN
, 
nRARFCN
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

44 &
a_DEF_NiveIeg
,

46 { 0, &
a_PER_memb_nRARFCN_cڡr_2
, 
memb_nRARFCN_cڡt_1
 },

51 cڡ 
b_v_g_t
 
	ga_DEF_NR_ARFCN_gs_1
[] = {

52 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

54 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_NR_ARFCN_g2_1
[] = {

55 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

57 
a_SEQUENCE_ecifics_t
 
	ga_SPC_NR_ARFCN_ecs_1
 = {

58 (
NR_ARFCN
),

59 
offtof
(
NR_ARFCN
, 
_a_x
),

60 
a_MAP_NR_ARFCN_g2_1
,

65 
a_TYPE_dest_t
 
	ga_DEF_NR_ARFCN
 = {

68 &
a_OP_SEQUENCE
,

69 
a_DEF_NR_ARFCN_gs_1
,

70 (
a_DEF_NR_ARFCN_gs_1
)

71 /(
a_DEF_NR_ARFCN_gs_1
[0]),

72 
a_DEF_NR_ARFCN_gs_1
,

73 (
a_DEF_NR_ARFCN_gs_1
)

74 /(
a_DEF_NR_ARFCN_gs_1
[0]),

75 { 0, 0, 
SEQUENCE_cڡt
 },

76 
a_MBR_NR_ARFCN_1
,

78 &
a_SPC_NR_ARFCN_ecs_1


	@NR-CGI.c

8 
	~"NR-CGI.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_NR_CGI_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
NR_CGI
, 
pLMNIdty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_PLMNIdty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
NR_CGI
, 
nRClIdty
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_NRClIdty
,

30 cڡ 
b_v_g_t
 
	ga_DEF_NR_CGI_gs_1
[] = {

31 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

33 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_NR_CGI_g2_1
[] = {

34 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

35 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

37 
a_SEQUENCE_ecifics_t
 
	ga_SPC_NR_CGI_ecs_1
 = {

38 (
NR_CGI
),

39 
offtof
(
NR_CGI
, 
_a_x
),

40 
a_MAP_NR_CGI_g2_1
,

45 
a_TYPE_dest_t
 
	ga_DEF_NR_CGI
 = {

48 &
a_OP_SEQUENCE
,

49 
a_DEF_NR_CGI_gs_1
,

50 (
a_DEF_NR_CGI_gs_1
)

51 /(
a_DEF_NR_CGI_gs_1
[0]),

52 
a_DEF_NR_CGI_gs_1
,

53 (
a_DEF_NR_CGI_gs_1
)

54 /(
a_DEF_NR_CGI_gs_1
[0]),

55 { 0, 0, 
SEQUENCE_cڡt
 },

56 
a_MBR_NR_CGI_1
,

58 &
a_SPC_NR_CGI_ecs_1


	@NR-PCI.c

8 
	~"NR-PCI.h
"

11 
	$NR_PCI_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 1007)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_NR_PCI_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 10, 10, 0, 1007 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_NR_PCI_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_NR_PCI
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_NR_PCI_gs_1
,

52 (
a_DEF_NR_PCI_gs_1
)

53 /(
a_DEF_NR_PCI_gs_1
[0]),

54 
a_DEF_NR_PCI_gs_1
,

55 (
a_DEF_NR_PCI_gs_1
)

56 /(
a_DEF_NR_PCI_gs_1
[0]),

57 { 0, &
a_PER_ty_NR_PCI_cڡr_1
, 
NR_PCI_cڡt
 },

	@NRCellIdentity.c

8 
	~"NRClIdty.h
"

11 
	$NRClIdty_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 36)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

45 
a_r_cڡts_t
 
a_PER_ty_NRClIdty_cڡr_1
 
	gCC_NOTUSED
 = {

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

47 { 
APC_CONSTRAINED
, 0, 0, 36, 36 } ,

50 cڡ 
b_v_g_t
 
	ga_DEF_NRClIdty_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (3 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_NRClIdty
 = {

56 &
a_OP_BIT_STRING
,

57 
a_DEF_NRClIdty_gs_1
,

58 (
a_DEF_NRClIdty_gs_1
)

59 /(
a_DEF_NRClIdty_gs_1
[0]),

60 
a_DEF_NRClIdty_gs_1
,

61 (
a_DEF_NRClIdty_gs_1
)

62 /(
a_DEF_NRClIdty_gs_1
[0]),

63 { 0, &
a_PER_ty_NRClIdty_cڡr_1
, 
NRClIdty_cڡt
 },

65 &
a_SPC_BIT_STRING_ecs


	@NRFrequencyBand-List.c

8 
	~"NRFqucyBd-Li.h
"

10 
	~"NRFqucyBdIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_NRFqucyBd_Li_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 5, 5, 1, 32 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_NRFqucyBd_Li_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_NRFqucyBdIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_NRFqucyBd_Li_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_NRFqucyBd_Li_ecs_1
 = {

31 (
NRFqucyBd_Li
),

32 
offtof
(
NRFqucyBd_Li
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_NRFqucyBd_Li
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_NRFqucyBd_Li_gs_1
,

40 (
a_DEF_NRFqucyBd_Li_gs_1
)

41 /(
a_DEF_NRFqucyBd_Li_gs_1
[0]),

42 
a_DEF_NRFqucyBd_Li_gs_1
,

43 (
a_DEF_NRFqucyBd_Li_gs_1
)

44 /(
a_DEF_NRFqucyBd_Li_gs_1
[0]),

45 { 0, &
a_PER_ty_NRFqucyBd_Li_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_NRFqucyBd_Li_1
,

48 &
a_SPC_NRFqucyBd_Li_ecs_1


	@NRFrequencyBandItem.c

8 
	~"NRFqucyBdIm.h
"

11 
	$memb_eqBdInditNr_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 1024)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

35 
a_r_cڡts_t
 
a_PER_memb_eqBdInditNr_cڡr_2
 
	gCC_NOTUSED
 = {

36 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 10, 10, 1, 1024 } ,

37 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

40 
a_TYPE_memb_t
 
	ga_MBR_NRFqucyBdIm_1
[] = {

41 { 
ATF_NOFLAGS
, 0, 
offtof
(
NRFqucyBdIm
, 
eqBdInditNr
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

44 &
a_DEF_NiveIeg
,

46 { 0, &
a_PER_memb_eqBdInditNr_cڡr_2
, 
memb_eqBdInditNr_cڡt_1
 },

50 { 
ATF_NOFLAGS
, 0, 
offtof
(
NRFqucyBdIm
, 
su܋dSULBdLi
),

51 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

53 &
a_DEF_Su܋dSULBdLi
,

60 cڡ 
b_v_g_t
 
	ga_DEF_NRFqucyBdIm_gs_1
[] = {

61 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

63 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_NRFqucyBdIm_g2_1
[] = {

64 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

65 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

67 
a_SEQUENCE_ecifics_t
 
	ga_SPC_NRFqucyBdIm_ecs_1
 = {

68 (
NRFqucyBdIm
),

69 
offtof
(
NRFqucyBdIm
, 
_a_x
),

70 
a_MAP_NRFqucyBdIm_g2_1
,

75 
a_TYPE_dest_t
 
	ga_DEF_NRFqucyBdIm
 = {

78 &
a_OP_SEQUENCE
,

79 
a_DEF_NRFqucyBdIm_gs_1
,

80 (
a_DEF_NRFqucyBdIm_gs_1
)

81 /(
a_DEF_NRFqucyBdIm_gs_1
[0]),

82 
a_DEF_NRFqucyBdIm_gs_1
,

83 (
a_DEF_NRFqucyBdIm_gs_1
)

84 /(
a_DEF_NRFqucyBdIm_gs_1
[0]),

85 { 0, 0, 
SEQUENCE_cڡt
 },

86 
a_MBR_NRFqucyBdIm_1
,

88 &
a_SPC_NRFqucyBdIm_ecs_1


	@NRFrequencyInfo.c

8 
	~"NRFqucyInfo.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_NRFqucyInfo_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
NRFqucyInfo
, 
ARFCN
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_NR_ARFCN
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
NRFqucyInfo
, 
equcyBd_Li
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_NRFqucyBd_Li
,

29 { 
ATF_POINTER
, 1, 
offtof
(
NRFqucyInfo
, 
equcyShi7p5khz
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_NRFqucyShi7p5khz
,

39 cڡ 
	ga_MAP_NRFqucyInfo_oms_1
[] = { 2 };

40 cڡ 
b_v_g_t
 
	ga_DEF_NRFqucyInfo_gs_1
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

43 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_NRFqucyInfo_g2_1
[] = {

44 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

45 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

46 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

48 
a_SEQUENCE_ecifics_t
 
	ga_SPC_NRFqucyInfo_ecs_1
 = {

49 (
NRFqucyInfo
),

50 
offtof
(
NRFqucyInfo
, 
_a_x
),

51 
a_MAP_NRFqucyInfo_g2_1
,

53 
a_MAP_NRFqucyInfo_oms_1
,

57 
a_TYPE_dest_t
 
	ga_DEF_NRFqucyInfo
 = {

60 &
a_OP_SEQUENCE
,

61 
a_DEF_NRFqucyInfo_gs_1
,

62 (
a_DEF_NRFqucyInfo_gs_1
)

63 /(
a_DEF_NRFqucyInfo_gs_1
[0]),

64 
a_DEF_NRFqucyInfo_gs_1
,

65 (
a_DEF_NRFqucyInfo_gs_1
)

66 /(
a_DEF_NRFqucyInfo_gs_1
[0]),

67 { 0, 0, 
SEQUENCE_cڡt
 },

68 
a_MBR_NRFqucyInfo_1
,

70 &
a_SPC_NRFqucyInfo_ecs_1


	@NRFrequencyShift7p5khz.c

8 
	~"NRFqucyShi7p5khz.h
"

14 
a_r_cڡts_t
 
a_PER_ty_NRFqucyShi7p5khz_cڡr_1
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_NRFqucyShi7p5khz_vue2um_1
[] = {

24 cڡ 
	ga_MAP_NRFqucyShi7p5khz_um2vue_1
[] = {

29 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_NRFqucyShi7p5khz_ecs_1
 = {

30 
a_MAP_NRFqucyShi7p5khz_vue2um_1
,

31 
a_MAP_NRFqucyShi7p5khz_um2vue_1
,

38 cڡ 
b_v_g_t
 
	ga_DEF_NRFqucyShi7p5khz_gs_1
[] = {

39 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

41 
a_TYPE_dest_t
 
	ga_DEF_NRFqucyShi7p5khz
 = {

44 &
a_OP_NiveEnumed
,

45 
a_DEF_NRFqucyShi7p5khz_gs_1
,

46 (
a_DEF_NRFqucyShi7p5khz_gs_1
)

47 /(
a_DEF_NRFqucyShi7p5khz_gs_1
[0]),

48 
a_DEF_NRFqucyShi7p5khz_gs_1
,

49 (
a_DEF_NRFqucyShi7p5khz_gs_1
)

50 /(
a_DEF_NRFqucyShi7p5khz_gs_1
[0]),

51 { 0, &
a_PER_ty_NRFqucyShi7p5khz_cڡr_1
, 
NiveEnumed_cڡt
 },

53 &
a_SPC_NRFqucyShi7p5khz_ecs_1


	@NULL.c

5 
	~<a_.h
>

6 
	~<a_codecs_im.h
>

7 
	~<NULL.h
>

8 
	~<BOOLEAN.h
>

13 cڡ 
b_v_g_t
 
	ga_DEF_NULL_gs
[] = {

14 (
ASN_TAG_CLASS_UNIVERSAL
 | (5 << 2))

16 
a_TYPE_ݔi_t
 
	ga_OP_NULL
 = {

17 
BOOLEAN_
,

18 
NULL_t
,

19 
NULL_com
,

20 
BOOLEAN_decode_b
,

21 
NULL_code_d
,

22 
NULL_decode_x
,

23 
NULL_code_x
,

24 #ifdef 
ASN_DISABLE_OER_SUPPORT


28 
NULL_decode_r
,

29 
NULL_code_r
,

31 #ifdef 
ASN_DISABLE_PER_SUPPORT


37 
NULL_decode_ur
,

38 
NULL_code_ur
,

39 
NULL_decode_
,

40 
NULL_code_
,

42 
NULL_ndom_fl
,

45 
a_TYPE_dest_t
 
	ga_DEF_NULL
 = {

48 &
a_OP_NULL
,

49 
a_DEF_NULL_gs
,

50 (
a_DEF_NULL_gs
) / (asn_DEF_NULL_tags[0]),

51 
a_DEF_NULL_gs
,

52 (
a_DEF_NULL_gs
) / (asn_DEF_NULL_tags[0]),

53 { 0, 0, 
a_gic_no_cڡt
 },

58 
a_c_rv_t


59 
	$NULL_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
r
, 
g_mode
,

60 
b_v_g_t
 
g
, 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

61 
a_c_rv_t
 
v
 = {0,0,0};

63 
v
.
coded
 = 
	`d_wre_gs
(
td
, 0, 
g_mode
, 0, 
g
, 
cb
, 
p_key
);

64 if(
v
.
coded
 == -1) {

65 
v
.
ed_ty
 = 
td
;

66 
v
.
ruu_r
 = 
r
;

69 
	`ASN__ENCODED_OK
(
v
);

70 
	}
}

72 
a_c_rv_t


73 
	$NULL_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

74 
x_cod_ags_e
 
ags
, 
a_p_csume_bys_f
 *
cb
,

75 *
p_key
) {

76 
a_c_rv_t
 

 = {0,0,0};

78 ()
td
;

79 ()

;

80 ()
ev
;

81 ()
ags
;

82 ()
cb
;

83 ()
p_key
;

86 

.
coded
 = 0;

87 
	`ASN__ENCODED_OK
(

);

88 
	}
}

91 
x_pbd_rv


92 
	$NULL__x_body_decode
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

93 cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

94 ()
td
;

95 ()

;

96 ()
chunk_buf
;

101 if(
chunk_size
)

102  
XPBD_BROKEN_ENCODING
;

104  
XPBD_BODY_CONSUMED
;

105 
	}
}

107 
a_dec_rv_t


108 
	$NULL_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

109 cڡ 
a_TYPE_dest_t
 *
td
, **

,

110 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

111  
	`x_decode_imive
(
t_codec_x
, 
td
,

112 

, (
NULL_t
), 
t_mme
, 
buf_r
, 
size
,

113 
NULL__x_body_decode
);

114 
	}
}

117 
	$NULL_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
a
, cڡ *
b
) {

118 ()
td
;

119 ()
a
;

120 ()
b
;

122 
	}
}

125 
	$NULL_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

126 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

127 ()
td
;

128 ()
ev
;

130 if(

) {

131  (
	`cb
("<e>", 9, 
p_key
) < 0) ? -1 : 0;

133  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

135 
	}
}

137 #ide
ASN_DISABLE_OER_SUPPORT


139 
a_dec_rv_t


140 
	$NULL_decode_r
(cڡ 
a_codec_x_t
 *
t_codec_x
,

141 cڡ 
a_TYPE_dest_t
 *
td
,

142 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

143 cڡ *
r
, 
size_t
 
size
) {

144 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

145 ()
t_codec_x
;

146 ()
td
;

147 ()
cڡts
;

148 ()
r
;

149 ()
size
;

151 if(!*

) {

152 *

 = 
	`MALLOC
((
NULL_t
));

153 if(*

) {

154 *(
NULL_t
 *)*

 = 0;

156 
ASN__DECODE_FAILED
;

160  
rv
;

161 
	}
}

163 
a_c_rv_t


164 
	$NULL_code_r
(cڡ 
a_TYPE_dest_t
 *
td
,

165 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

166 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

167 
a_c_rv_t
 

 = {0,0,0};

169 ()
td
;

170 ()

;

171 ()
cڡts
;

172 ()
cb
;

173 ()
p_key
;

175 

.
coded
 = 0;

177 
	`ASN__ENCODED_OK
(

);

178 
	}
}

182 #ide
ASN_DISABLE_PER_SUPPORT


184 
a_dec_rv_t


185 
	$NULL_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

186 cڡ 
a_TYPE_dest_t
 *
td
,

187 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

188 
a_r_da_t
 *
pd
) {

189 
a_dec_rv_t
 
rv
;

191 ()
t_codec_x
;

192 ()
td
;

193 ()
cڡts
;

194 ()
pd
;

196 if(!*

) {

197 *

 = 
	`MALLOC
((
NULL_t
));

198 if(*

) {

199 *(
NULL_t
 *)*

 = 0;

201 
ASN__DECODE_FAILED
;

209 
rv
.
code
 = 
RC_OK
;

210 
rv
.
csumed
 = 0;

211  
rv
;

212 
	}
}

214 
a_c_rv_t


215 
	$NULL_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

216 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

217 
a_r_ou_t
 *
po
) {

218 
a_c_rv_t
 

 = {0,0,0};

220 ()
td
;

221 ()
cڡts
;

222 ()

;

223 ()
po
;

225 

.
coded
 = 0;

226 
	`ASN__ENCODED_OK
(

);

227 
	}
}

229 
a_dec_rv_t


230 
	$NULL_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

231 cڡ 
a_TYPE_dest_t
 *
td
,

232 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

233 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

235 ()
t_codec_x
;

236 ()
td
;

237 ()
cڡts
;

238 ()
pd
;

240 if(!*

) {

241 *

 = 
	`MALLOC
((
NULL_t
));

242 if(*

) {

243 *(
NULL_t
 *)*

 = 0;

245 
ASN__DECODE_FAILED
;

253 
rv
.
code
 = 
RC_OK
;

254 
rv
.
csumed
 = 0;

255  
rv
;

256 
	}
}

259 
a_c_rv_t


260 
	$NULL_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

261 cڡ 
a_r_cڡts_t
 *
cڡts
,

262 cڡ *

, 
a_r_ou_t
 *
po
) {

263 
a_c_rv_t
 

 = {0,0,0};

265 ()
td
;

266 ()
cڡts
;

267 ()

;

268 ()
po
;

270 

.
coded
 = 0;

271 
	`ASN__ENCODED_OK
(

);

272 
	}
}

276 
a_ndom_fl_su_t


277 
	$NULL_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

278 cڡ 
a_codg_cڡts_t
 *
cڡr
,

279 
size_t
 
max_ngth
) {

280 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

281 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

282 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

283 
NULL_t
 *

 = *

;

285 ()
td
;

286 ()
cڡr
;

288 if(
max_ngth
 =0 
su_skd
;

290 if(

 =
NULL
) {

291 

 = (
NULL_t
 *)(*

 = 
	`CALLOC
(1, (*st)));

292 if(

 =
NULL
) {

293  
su_ed
;

297  
su_ok
;

298 
	}
}

	@NativeEnumerated.c

12 
	~<a_.h
>

13 
	~<NiveEnumed.h
>

18 cڡ 
b_v_g_t
 
	ga_DEF_NiveEnumed_gs
[] = {

19 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

21 
a_TYPE_ݔi_t
 
	ga_OP_NiveEnumed
 = {

22 
NiveIeg_
,

23 
NiveIeg_t
,

24 
NiveIeg_com
,

25 
NiveIeg_decode_b
,

26 
NiveIeg_code_d
,

27 
NiveIeg_decode_x
,

28 
NiveEnumed_code_x
,

29 #ifdef 
ASN_DISABLE_OER_SUPPORT


33 
NiveEnumed_decode_r
,

34 
NiveEnumed_code_r
,

36 #ifdef 
ASN_DISABLE_PER_SUPPORT


42 
NiveEnumed_decode_ur
,

43 
NiveEnumed_code_ur
,

44 
NiveEnumed_decode_
,

45 
NiveEnumed_code_
,

47 
NiveEnumed_ndom_fl
,

50 
a_TYPE_dest_t
 
	ga_DEF_NiveEnumed
 = {

53 &
a_OP_NiveEnumed
,

54 
a_DEF_NiveEnumed_gs
,

55 (
a_DEF_NiveEnumed_gs
) / (asn_DEF_NativeEnumerated_tags[0]),

56 
a_DEF_NiveEnumed_gs
,

57 (
a_DEF_NiveEnumed_gs
) / (asn_DEF_NativeEnumerated_tags[0]),

58 { 0, 0, 
a_gic_no_cڡt
 },

63 
a_c_rv_t


64 
	$NiveEnumed_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

65 
ev
, 
x_cod_ags_e
 
ags
,

66 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

67 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

68 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

69 
a_c_rv_t
 

 = {0,0,0};

70 cڡ *
tive
 = (cڡ *)

;

71 cڡ 
a_INTEGER_um_m_t
 *

;

73 ()
ev
;

74 ()
ags
;

76 if(!
tive

ASN__ENCODE_FAILED
;

78 

 = 
	`INTEGER_m_vue2um
(
ecs
, *
tive
);

79 if(

) {

80 

.
coded
 =

81 
	`a__fm_to_back
(
cb
, 
p_key
, "<%s/>", 

->
um_me
);

82 if(

.
coded
 < 0
ASN__ENCODE_FAILED
;

83 
	`ASN__ENCODED_OK
(

);

85 
	`ASN_DEBUG
(

88 
ASN__ENCODE_FAILED
;

90 
	}
}

92 
a_dec_rv_t


93 
	$NiveEnumed_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

94 cڡ 
a_TYPE_dest_t
 *
td
,

95 cڡ 
a_r_cڡts_t
 *
cڡts
,

96 **

, 
a_r_da_t
 *
pd
) {

97 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = 
td
->
ecifics
;

98 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

99 *
tive
 = (*)*

;

100 cڡ 
a_r_cڡt_t
 *

 = 
NULL
;

101 
vue
;

103 ()
t_codec_x
;

105 if(
cڡts


 = &cڡts->
vue
;

106 if(
td
->
codg_cڡts
.
r_cڡts
)

107 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

108 
ASN__DECODE_FAILED
;

109 if(!
ecs

ASN__DECODE_FAILED
;

111 if(!
tive
) {

112 
tive
 = (*)(*

 = 
	`CALLOC
(1, (*native)));

113 if(!
tive

ASN__DECODE_FAILED
;

116 
	`ASN_DEBUG
("Decodg %aNiveEnumed", 
td
->
me
);

118 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

119 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

120 if(
ext
 < 0
ASN__DECODE_STARVED
;

121 if(
ext


 = 0;

124 if(

 && ct->
nge_bs
 >= 0) {

125 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

126 if(
vue
 < 0
ASN__DECODE_STARVED
;

127 if(
vue
 >(
ecs
->
exnsi


128 ? 
ecs
->
exnsi
 - 1 : scs->
m_cou
))

129 
ASN__DECODE_FAILED
;

131 if(!
ecs
->
exnsi
)

132 
ASN__DECODE_FAILED
;

136 
vue
 = 
	`ur_g_nnwn
(
pd
);

137 if(
vue
 < 0
ASN__DECODE_STARVED
;

138 
vue
 +
ecs
->
exnsi
 - 1;

139 if(
vue
 >
ecs
->
m_cou
)

140 
ASN__DECODE_FAILED
;

143 *
tive
 = 
ecs
->
vue2um
[
vue
].
t_vue
;

144 
	`ASN_DEBUG
("Decoded %%ld", 
td
->
me
, *
tive
);

146  
rv
;

147 
	}
}

150 
	$NiveEnumed__comr_vue2um
(cڡ *

, cڡ *
bp
) {

151 cڡ 
a_INTEGER_um_m_t
 *
a
 = 

;

152 cڡ 
a_INTEGER_um_m_t
 *
b
 = 
bp
;

153 if(
a
->
t_vue
 =
b
->nat_value)

155 if(
a
->
t_vue
 < 
b
->nat_value)

158 
	}
}

160 
a_c_rv_t


161 
	$NiveEnumed_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

162 cڡ 
a_r_cڡts_t
 *
cڡts
,

163 cڡ *

, 
a_r_ou_t
 *
po
) {

164 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

165 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

166 
a_c_rv_t
 

 = {0,0,0};

167 
tive
, 
vue
;

168 cڡ 
a_r_cڡt_t
 *

 = 
NULL
;

169 
ext
 = 0;

170 
a_INTEGER_um_m_t
 
key
;

171 cڡ 
a_INTEGER_um_m_t
 *
kf
;

173 if(!


ASN__ENCODE_FAILED
;

174 if(!
ecs

ASN__ENCODE_FAILED
;

176 if(
cڡts


 = &cڡts->
vue
;

177 if(
td
->
codg_cڡts
.
r_cڡts
)

178 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

179 
ASN__ENCODE_FAILED
;

181 
	`ASN_DEBUG
("Encodg %aNiveEnumed", 
td
->
me
);

183 

.
coded
 = 0;

185 
tive
 = *(cڡ *)

;

187 
key
.
t_vue
 = 
tive
;

188 
kf
 = 
	`bch
(&
key
, 
ecs
->
vue2um
, scs->
m_cou
,

189 (
key
), 
NiveEnumed__comr_vue2um
);

190 if(!
kf
) {

191 
	`ASN_DEBUG
("Nؖemcܻdt%ld", 
tive
);

192 
ASN__ENCODE_FAILED
;

194 
vue
 = 
kf
 - 
ecs
->
vue2um
;

196 if(

 && ct->
nge_bs
 >= 0) {

197 
cmpWh
 = 
ecs
->
exnsi


198 ? 
ecs
->
exnsi
 - 1 : scs->
m_cou
;

199 if(
vue
 >
cmpWh
)

200 
ext
 = 1;

202 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

203 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

204 
ASN__ENCODE_FAILED
;

205 if(
ext


 = 0;

206 } if(
ext
) {

207 
ASN__ENCODE_FAILED
;

210 if(

 && ct->
nge_bs
 >= 0) {

211 if(
	`r_put_w_bs
(
po
, 
vue
, 

->
nge_bs
))

212 
ASN__ENCODE_FAILED
;

213 
	`ASN__ENCODED_OK
(

);

216 if(!
ecs
->
exnsi
)

217 
ASN__ENCODE_FAILED
;

222 
	`ASN_DEBUG
("value = %ld,xt = %d, inext = %d,es = %ld",

223 
vue
, 
ecs
->
exnsi
, 
ext
,

224 
vue
 - (
ext
 ? (
ecs
->
exnsi
 - 1) : 0));

225 if(
	`ur_put_nnwn
(
po
, 
vue
 - (
ext
 ? (
ecs
->
exnsi
 - 1) : 0)))

226 
ASN__ENCODE_FAILED
;

228 
	`ASN__ENCODED_OK
(

);

229 
	}
}

231 
a_dec_rv_t


232 
	$NiveEnumed_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

233 cڡ 
a_TYPE_dest_t
 *
td
,

234 cڡ 
a_r_cڡts_t
 *
cڡts
,

235 **

, 
a_r_da_t
 *
pd
) {

236 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

237 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

238 *
tive
 = (*)*

;

239 cڡ 
a_r_cڡt_t
 *

 = 
NULL
;

240 
vue
;

242 ()
t_codec_x
;

244 if(
cڡts


 = &cڡts->
vue
;

245 if(
td
->
codg_cڡts
.
r_cڡts
)

246 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

247 
ASN__DECODE_FAILED
;

248 if(!
ecs

ASN__DECODE_FAILED
;

250 if(!
tive
) {

251 
tive
 = (*)(*

 = 
	`CALLOC
(1, (*native)));

252 if(!
tive

ASN__DECODE_FAILED
;

255 
	`ASN_DEBUG
("Decodg %aNiveEnumed", 
td
->
me
);

257 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

258 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

259 if(
ext
 < 0
ASN__DECODE_STARVED
;

260 if(
ext


 = 0;

264 if(

 && ct->
u_bound
 >= 255) {

265 
ddg
 = 0;

266 
ddg
 = (8 - (
pd
->
moved
 % 8)) % 8;

267 
	`ASN_DEBUG
("F NiveEnumed %s,offt%lu Paddg b%d", 
td
->
me
, 
pd
->
moved
, 
ddg
);

268 
	`ASN_DEBUG
("F NiveEnumed %s, u bound = %lu", 
td
->
me
, 

->
u_bound
);

269 if(
ddg
 > 0)

270 
	`r_g_w_bs
(
pd
, 
ddg
);

273 if(

 && ct->
nge_bs
 >= 0) {

274 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

275 if(
vue
 < 0
ASN__DECODE_STARVED
;

276 if(
vue
 >(
ecs
->
exnsi


277 ? 
ecs
->
exnsi
 - 1 : scs->
m_cou
))

278 
ASN__DECODE_FAILED
;

280 if(!
ecs
->
exnsi
)

281 
ASN__DECODE_FAILED
;

285 
vue
 = 
	`ur_g_nnwn
(
pd
);

286 if(
vue
 < 0
ASN__DECODE_STARVED
;

287 
vue
 +
ecs
->
exnsi
 - 1;

288 if(
vue
 >
ecs
->
m_cou
)

289 
ASN__DECODE_FAILED
;

292 *
tive
 = 
ecs
->
vue2um
[
vue
].
t_vue
;

293 
	`ASN_DEBUG
("Decoded %%ld", 
td
->
me
, *
tive
);

295  
rv
;

296 
	}
}

298 
a_c_rv_t


299 
	$NiveEnumed_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

300 cڡ 
a_r_cڡts_t
 *
cڡts
,

301 cڡ *

, 
a_r_ou_t
 *
po
) {

302 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

303 
a_c_rv_t
 

 = {0,0,0};

304 
tive
, 
vue
;

305 cڡ 
a_r_cڡt_t
 *

 = 
NULL
;

306 
ext
 = 0;

307 
a_INTEGER_um_m_t
 
key
;

308 
a_INTEGER_um_m_t
 *
kf
;

310 if(!


ASN__ENCODE_FAILED
;

311 if(!
ecs

ASN__ENCODE_FAILED
;

313 if(
cڡts


 = &cڡts->
vue
;

314 if(
td
->
codg_cڡts
.
r_cڡts
)

315 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

316 
ASN__ENCODE_FAILED
;

318 
	`ASN_DEBUG
("Encodg %aNiveEnumed", 
td
->
me
);

320 

.
coded
 = 0;

322 
tive
 = *(cڡ *)

;

323 if(
tive
 < 0
ASN__ENCODE_FAILED
;

325 
key
.
t_vue
 = 
tive
;

326 
kf
 = 
	`bch
(&
key
, 
ecs
->
vue2um
, scs->
m_cou
,

327 (
key
), 
NiveEnumed__comr_vue2um
);

328 if(!
kf
) {

329 
	`ASN_DEBUG
("Nؖemcܻdt%ld", 
tive
);

330 
ASN__ENCODE_FAILED
;

332 
vue
 = 
kf
 - 
ecs
->
vue2um
;

334 if(

 && ct->
nge_bs
 >= 0) {

335 
cmpWh
 = 
ecs
->
exnsi


336 ? 
ecs
->
exnsi
 - 1 : scs->
m_cou
;

337 if(
vue
 >
cmpWh
)

338 
ext
 = 1;

340 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

341 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

342 
ASN__ENCODE_FAILED
;

343 if(
ext


 = 0;

344 } if(
ext
) {

345 
ASN__ENCODE_FAILED
;

348 if(

 && ct->
nge_bs
 >= 0) {

349 if(
	`r_put_w_bs
(
po
, 
vue
, 

->
nge_bs
))

350 
ASN__ENCODE_FAILED
;

351 
	`ASN__ENCODED_OK
(

);

354 if(!
ecs
->
exnsi
)

355 
ASN__ENCODE_FAILED
;

360 
	`ASN_DEBUG
("value = %ld,xt = %d, inext = %d,es = %ld",

361 
vue
, 
ecs
->
exnsi
, 
ext
,

362 
vue
 - (
ext
 ? (
ecs
->
exnsi
 - 1) : 0));

363 if(
	`ur_put_nnwn
(
po
, 
vue
 - (
ext
 ? (
ecs
->
exnsi
 - 1) : 0)))

364 
ASN__ENCODE_FAILED
;

366 
	`ASN__ENCODED_OK
(

);

367 
	}
}

	@NativeInteger.c

13 
	~<a_.h
>

14 
	~<NiveIeg.h
>

19 cڡ 
b_v_g_t
 
	ga_DEF_NiveIeg_gs
[] = {

20 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

22 
a_TYPE_ݔi_t
 
	ga_OP_NiveIeg
 = {

23 
NiveIeg_
,

24 
NiveIeg_t
,

25 
NiveIeg_com
,

26 
NiveIeg_decode_b
,

27 
NiveIeg_code_d
,

28 
NiveIeg_decode_x
,

29 
NiveIeg_code_x
,

30 #ifdef 
ASN_DISABLE_OER_SUPPORT


34 
NiveIeg_decode_r
,

35 
NiveIeg_code_r
,

37 #ifdef 
ASN_DISABLE_PER_SUPPORT


43 
NiveIeg_decode_ur
,

44 
NiveIeg_code_ur
,

45 
NiveIeg_decode_
,

46 
NiveIeg_code_
,

48 
NiveIeg_ndom_fl
,

51 
a_TYPE_dest_t
 
	ga_DEF_NiveIeg
 = {

54 &
a_OP_NiveIeg
,

55 
a_DEF_NiveIeg_gs
,

56 (
a_DEF_NiveIeg_gs
) / (asn_DEF_NativeInteger_tags[0]),

57 
a_DEF_NiveIeg_gs
,

58 (
a_DEF_NiveIeg_gs
) / (asn_DEF_NativeInteger_tags[0]),

59 { 0, 0, 
a_gic_no_cڡt
 },

67 
a_dec_rv_t


68 
	$NiveIeg_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

69 cڡ 
a_TYPE_dest_t
 *
td
, **
nt_r
,

70 cڡ *
buf_r
, 
size_t
 
size
, 
g_mode
) {

71 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

72 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

73 *
tive
 = (*)*
nt_r
;

74 
a_dec_rv_t
 
rv
;

75 
b_v_n_t
 
ngth
;

80 if(
tive
 =
NULL
) {

81 
tive
 = (*)(*
nt_r
 = 
	`CALLOC
(1, (*native)));

82 if(
tive
 =
NULL
) {

83 
rv
.
code
 = 
RC_FAIL
;

84 
rv
.
csumed
 = 0;

85  
rv
;

89 
	`ASN_DEBUG
("Decoding %ss INTEGER (tm=%d)",

90 
td
->
me
, 
g_mode
);

95 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 0, 
buf_r
, 
size
,

96 
g_mode
, 0, &
ngth
, 0);

97 if(
rv
.
code
 !
RC_OK
)

98  
rv
;

100 
	`ASN_DEBUG
("%ngth i%d bys", 
td
->
me
, ()
ngth
);

105 
buf_r
 = ((cڡ *)buf_r+ 
rv
.
csumed
;

106 
size
 -
rv
.
csumed
;

107 if(
ngth
 > (
b_v_n_t
)
size
) {

108 
rv
.
code
 = 
RC_WMORE
;

109 
rv
.
csumed
 = 0;

110  
rv
;

119 
INTEGER_t
 
tmp
;

121 cڡ *
cڡbuf
;

122 *
ncڡbuf
;

123 } 
uncڡ_buf
;

124 
l
;

126 
uncڡ_buf
.
cڡbuf
 = 
buf_r
;

127 
tmp
.
buf
 = (
ut8_t
 *)
uncڡ_buf
.
ncڡbuf
;

128 
tmp
.
size
 = 
ngth
;

130 if((
ecs
&&ecs->
fld_unsigd
)

131 ? 
	`a_INTEGER2ulg
(&
tmp
, (*)&
l
)

132 : 
	`a_INTEGER2lg
(&
tmp
, &
l
)) {

133 
rv
.
code
 = 
RC_FAIL
;

134 
rv
.
csumed
 = 0;

135  
rv
;

138 *
tive
 = 
l
;

141 
rv
.
code
 = 
RC_OK
;

142 
rv
.
csumed
 +
ngth
;

144 
	`ASN_DEBUG
("Took %ld/%ld bytesoncode %s (%ld)",

145 ()
rv
.
csumed
, ()
ngth
, 
td
->
me
, ()*
tive
);

147  
rv
;

148 
	}
}

153 
a_c_rv_t


154 
	$NiveIeg_code_d
(cڡ 
a_TYPE_dest_t
 *
sd
, cڡ *
r
,

155 
g_mode
, 
b_v_g_t
 
g
,

156 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

157 
tive
 = *(cڡ *)
r
;

158 
a_c_rv_t
 
v
 = {0,0,0};

159 
INTEGER_t
 
tmp
;

161 #ifdef 
WORDS_BIGENDIAN


163 
tmp
.
buf
 = (
ut8_t
 *)&
tive
;

164 
tmp
.
size
 = (
tive
);

167 
ut8_t
 
buf
[(
tive
)];

168 
ut8_t
 *
p
;

171 
p
 = 
buf
 + (buf- 1; >buf;--, 
tive
 >>= 8)

172 *
p
 = (
ut8_t
)
tive
;

174 
tmp
.
buf
 = buf;

175 
tmp
.
size
 = (
buf
);

179 
v
 = 
	`INTEGER_code_d
(
sd
, &
tmp
, 
g_mode
, 
g
, 
cb
, 
p_key
);

180 if(
v
.
ruu_r
 =&
tmp
) {

181 
v
.
ruu_r
 = 
r
;

183  
v
;

184 
	}
}

189 
a_dec_rv_t


190 
	$NiveIeg_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

191 cڡ 
a_TYPE_dest_t
 *
td
, **

,

192 cڡ *
t_mme
, cڡ *
buf_r
,

193 
size_t
 
size
) {

194 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

195 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

196 
a_dec_rv_t
 
rv
;

197 
INTEGER_t
 

;

198 *
_r
 = (*)&

;

199 *
tive
 = (*)*

;

201 if(!
tive
) {

202 
tive
 = (*)(*

 = 
	`CALLOC
(1, (*native)));

203 if(!
tive

ASN__DECODE_FAILED
;

206 
	`memt
(&

, 0, (st));

207 
rv
 = 
	`INTEGER_decode_x
(
t_codec_x
, 
td
, &
_r
,

208 
t_mme
, 
buf_r
, 
size
);

209 if(
rv
.
code
 =
RC_OK
) {

210 
l
;

211 if((
ecs
&&ecs->
fld_unsigd
)

212 ? 
	`a_INTEGER2ulg
(&

, (*)&
l
)

213 : 
	`a_INTEGER2lg
(&

, &
l
)) {

214 
rv
.
code
 = 
RC_FAIL
;

215 
rv
.
csumed
 = 0;

217 *
tive
 = 
l
;

225 
rv
.
csumed
 = 0;

227 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_INTEGER
, &

);

228  
rv
;

229 
	}
}

232 
a_c_rv_t


233 
	$NiveIeg_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

234 
ev
, 
x_cod_ags_e
 
ags
,

235 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

236 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

237 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

238 
sch
[32];

239 
a_c_rv_t
 

 = {0,0,0};

240 cڡ *
tive
 = (cڡ *)

;

242 ()
ev
;

243 ()
ags
;

245 if(!
tive

ASN__ENCODE_FAILED
;

247 

.
coded
 = 
	`tf
(
sch
, (scratch),

248 (
ecs
 && scs->
fld_unsigd
)

249 ? "%lu" : "%ld", *
tive
);

250 if(

.
coded
 <0 || (
size_t
r.coded >(
sch
)

251 || 
	`cb
(
sch
, 

.
coded
, 
p_key
) < 0)

252 
ASN__ENCODE_FAILED
;

254 
	`ASN__ENCODED_OK
(

);

255 
	}
}

257 #ide 
ASN_DISABLE_PER_SUPPORT


259 
a_dec_rv_t


260 
	$NiveIeg_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

261 cڡ 
a_TYPE_dest_t
 *
td
,

262 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

263 
a_r_da_t
 *
pd
) {

264 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

265 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

266 
a_dec_rv_t
 
rv
;

267 *
tive
 = (*)*

;

268 
INTEGER_t
 
tmpt
;

269 *
tmp
 = &
tmpt
;

271 ()
t_codec_x
;

272 
	`ASN_DEBUG
("Decodg NiveIeg %(UPER)", 
td
->
me
);

274 if(!
tive
) {

275 
tive
 = (*)(*

 = 
	`CALLOC
(1, (*native)));

276 if(!
tive

ASN__DECODE_FAILED
;

279 
	`memt
(&
tmpt
, 0, mpint);

280 
rv
 = 
	`INTEGER_decode_ur
(
t_codec_x
, 
td
, 
cڡts
,

281 &
tmp
, 
pd
);

282 if(
rv
.
code
 =
RC_OK
) {

283 if((
ecs
&&ecs->
fld_unsigd
)

284 ? 
	`a_INTEGER2ulg
(&
tmpt
, (*)
tive
)

285 : 
	`a_INTEGER2lg
(&
tmpt
, 
tive
))

286 
rv
.
code
 = 
RC_FAIL
;

288 
	`ASN_DEBUG
("NativeInteger %s got value %ld",

289 
td
->
me
, *
tive
);

291 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_INTEGER
, &
tmpt
);

293  
rv
;

294 
	}
}

296 
a_c_rv_t


297 
	$NiveIeg_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

298 cڡ 
a_r_cڡts_t
 *
cڡts
,

299 cڡ *

, 
a_r_ou_t
 *
po
) {

300 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

301 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

302 
a_c_rv_t
 

 = {0,0,0};

303 
tive
;

304 
INTEGER_t
 
tmpt
;

306 if(!


ASN__ENCODE_FAILED
;

308 
tive
 = *(cڡ *)

;

310 
	`ASN_DEBUG
("Encodg NiveIeg %%ld (UPER)", 
td
->
me
, 
tive
);

312 
	`memt
(&
tmpt
, 0, (tmpint));

313 if((
ecs
&&ecs->
fld_unsigd
)

314 ? 
	`a_ulg2INTEGER
(&
tmpt
, 
tive
)

315 : 
	`a_lg2INTEGER
(&
tmpt
, 
tive
))

316 
ASN__ENCODE_FAILED
;

317 

 = 
	`INTEGER_code_ur
(
td
, 
cڡts
, &
tmpt
, 
po
);

318 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_INTEGER
, &
tmpt
);

319  

;

320 
	}
}

322 
a_dec_rv_t


323 
	$NiveIeg_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

324 cڡ 
a_TYPE_dest_t
 *
td
,

325 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

327 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

328 
a_dec_rv_t
 
rv
;

329 *
tive
 = (*)*

;

330 
INTEGER_t
 
tmpt
;

331 *
tmp
 = &
tmpt
;

333 ()
t_codec_x
;

334 
	`ASN_DEBUG
("Decodg NiveIeg %(APER)", 
td
->
me
);

336 if(!
tive
) {

337 
tive
 = (*)(*

 = 
	`CALLOC
(1, (*native)));

338 if(!
tive

ASN__DECODE_FAILED
;

341 
	`memt
(&
tmpt
, 0, mpint);

342 
rv
 = 
	`INTEGER_decode_
(
t_codec_x
, 
td
, 
cڡts
,

343 &
tmp
, 
pd
);

344 if(
rv
.
code
 =
RC_OK
) {

345 if((
ecs
&&ecs->
fld_unsigd
)

346 ? 
	`a_INTEGER2ulg
(&
tmpt
, (*)
tive
)

347 : 
	`a_INTEGER2lg
(&
tmpt
, 
tive
))

348 
rv
.
code
 = 
RC_FAIL
;

350 
	`ASN_DEBUG
("NativeInteger %s got value %ld",

351 
td
->
me
, *
tive
);

353 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_INTEGER
, &
tmpt
);

355  
rv
;

356 
	}
}

358 
a_c_rv_t


359 
	$NiveIeg_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

360 cڡ 
a_r_cڡts_t
 *
cڡts
,

361 cڡ *

, 
a_r_ou_t
 *
po
) {

363 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 = (cڡ_INTEGER_ecifics_*)
td
->
ecifics
;

364 
a_c_rv_t
 

 = {0,0,0};

365 
tive
;

366 
INTEGER_t
 
tmpt
;

368 if(!


ASN__ENCODE_FAILED
;

370 
tive
 = *(cڡ *)

;

372 
	`ASN_DEBUG
("Encodg NiveIeg %%ld (APER)", 
td
->
me
, 
tive
);

374 
	`memt
(&
tmpt
, 0, (tmpint));

375 if((
ecs
&&ecs->
fld_unsigd
)

376 ? 
	`a_ulg2INTEGER
(&
tmpt
, ()
tive
)

377 : 
	`a_lg2INTEGER
(&
tmpt
, 
tive
))

378 
ASN__ENCODE_FAILED
;

379 

 = 
	`INTEGER_code_
(
td
, 
cڡts
, &
tmpt
, 
po
);

380 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_INTEGER
, &
tmpt
);

381  

;

382 
	}
}

390 
	$NiveIeg_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

391 
ev
, 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

392 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

393 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

394 cڡ *
tive
 = (cڡ *)

;

395 
sch
[32];

396 
t
;

398 ()
td
;

399 ()
ev
;

401 if(
tive
) {

402 
vue
 = *
tive
;

403 
t
 = 
	`tf
(
sch
, (scratch),

404 (
ecs
 && scs->
fld_unsigd
? "%lu" : "%ld", 
vue
);

405 
	`as
(
t
 > 0 && (
size_t
 < (
sch
));

406 if(
	`cb
(
sch
, 
t
, 
p_key
) < 0)  -1;

407 if(
ecs
 && (
vue
 >0 || !ecs->
fld_unsigd
)) {

408 cڡ 
a_INTEGER_um_m_t
 *

 =

409 
	`INTEGER_m_vue2um
(
ecs
, 
vue
);

410 if(

) {

411 if(
	`cb
(" (", 2, 
p_key
) < 0)  -1;

412 if(
	`cb
(

->
um_me
,l->
um_n
, 
p_key
) < 0)  -1;

413 if(
	`cb
(")", 1, 
p_key
) < 0)  -1;

418  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

420 
	}
}

423 
	$NiveIeg_
(cڡ 
a_TYPE_dest_t
 *
td
, *
r
,

424 
a_ru__mhod
 
mhod
) {

425 if(!
td
 || !
r
)

428 
	`ASN_DEBUG
("Freeing %ss INTEGER (%d, %p, Native)",

429 
td
->
me
, 
mhod
, 
r
);

431 
mhod
) {

432 
ASFM_FREE_EVERYTHING
:

433 
	`FREEMEM
(
r
);

435 
ASFM_FREE_UNDERLYING
:

437 
ASFM_FREE_UNDERLYING_AND_RESET
:

438 
	`memt
(
r
, 0, ());

441 
	}
}

444 
	$NiveIeg_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, cڡ *
br
) {

445 ()
td
;

447 if(

 && 
br
) {

448 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

449 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

450 if(
ecs
 && scs->
fld_unsigd
) {

451 cڡ *
a
 = 

;

452 cڡ *
b
 = 
br
;

453 if(*
a
 < *
b
) {

455 } if(*
a
 > *
b
) {

461 cڡ *
a
 = 

;

462 cڡ *
b
 = 
br
;

463 if(*
a
 < *
b
) {

465 } if(*
a
 > *
b
) {

471 } if(!

) {

476 
	}
}

478 
a_ndom_fl_su_t


479 
	$NiveIeg_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

480 cڡ 
a_codg_cڡts_t
 *
cڡts
,

481 
size_t
 
max_ngth
) {

482 cڡ 
a_INTEGER_ecifics_t
 *
ecs
 =

483 (cڡ 
a_INTEGER_ecifics_t
 *)
td
->
ecifics
;

484 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

485 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

486 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

487 *

 = *

;

488 cڡ 
a_INTEGER_um_m_t
 *
em
;

489 
size_t
 
em_n
;

490 
tmax_t
 
vue
;

491 
fd_side_m
;

493 if(
max_ngth
 =0 
su_skd
;

495 if(

 =
NULL
) {

496 

 = (*)
	`CALLOC
(1, (*st));

497 if(

 =
NULL
) {

498  
su_ed
;

502 if(
ecs
) {

503 
em
 = 
ecs
->
vue2um
;

504 
em_n
 = 
ecs
->
m_cou
;

505 if(
ecs
->
ri_umi
) {

506 
fd_side_m
 = 
em_n
 > 0;

508 
fd_side_m
 = 
em_n
 ? 
	`a_ndom_bwn
(0, 1) : 0;

511 
em
 = 0;

512 
em_n
 = 0;

513 
fd_side_m
 = 0;

516 if(
fd_side_m
) {

517 
	`as
(
em_n
 > 0);

518 
vue
 = 
em
[
	`a_ndom_bwn
(0, 
em_n
 - 1)].
t_vue
;

520 cڡ 
a_r_cڡts_t
 *

;

522 cڡ 
vs
[] = {

528 if(
ecs
 && scs->
fld_unsigd
) {

529 
	`as
(
vs
[18] == 0);

530 
vue
 = 
vs
[
	`a_ndom_bwn
(

531 18, (
vs
) / (variants[0]) - 1)];

533 
vue
 = 
vs
[
	`a_ndom_bwn
(

534 0, (
vs
) / (variants[0]) - 1)];

537 if(!
cڡts
cڡt&
td
->
codg_cڡts
;

538 

 = 
cڡts
 ? cڡts->
r_cڡts
 : 0;

539 if(

 && (->
vue
.
ags
 & 
APC_CONSTRAINED
)) {

540 if(
vue
 < 

->vue.
low_bound
 || vu> ct->vue.
u_bound
) {

541 
vue
 = 
	`a_ndom_bwn
(

->vue.
low_bound
,

542 

->
vue
.
u_bound
);

547 *

 = 

;

548 *

 = 
vue
;

549  
su_ok
;

550 
	}
}

	@NativeReal.c

12 
	~<a_.h
>

13 
	~<NiveRl.h
>

14 
	~<REAL.h
>

15 
	~<OCTET_STRING.h
>

16 
	~<mh.h
>

17 
	~<t.h
>

19 #i
defed
(
__g__
)

27 #agm
g
 
dgnoic
 
push


28 #agm
g
 
dgnoic
 
igned
 "-Wc11-extensions"

29 
	$a_i
(
d
) {

30  
	`i
(
d
);

31 
	}
}

32 #agm
g
 
dgnoic
 
p


34 
	#a_i
(
v

	`i
(v)

	)

40 cڡ 
b_v_g_t
 
	ga_DEF_NiveRl_gs
[] = {

41 (
ASN_TAG_CLASS_UNIVERSAL
 | (9 << 2))

43 
a_TYPE_ݔi_t
 
	ga_OP_NiveRl
 = {

44 
NiveRl_
,

45 
NiveRl_t
,

46 
NiveRl_com
,

47 
NiveRl_decode_b
,

48 
NiveRl_code_d
,

49 
NiveRl_decode_x
,

50 
NiveRl_code_x
,

51 #ifdef 
ASN_DISABLE_OER_SUPPORT


55 
NiveRl_decode_r
,

56 
NiveRl_code_r
,

58 #ifdef 
ASN_DISABLE_PER_SUPPORT


64 
NiveRl_decode_ur
,

65 
NiveRl_code_ur
,

66 
NiveRl_decode_
,

67 
NiveRl_code_
,

69 
NiveRl_ndom_fl
,

72 
a_TYPE_dest_t
 
	ga_DEF_NiveRl
 = {

75 &
a_OP_NiveRl
,

76 
a_DEF_NiveRl_gs
,

77 (
a_DEF_NiveRl_gs
) / (asn_DEF_NativeReal_tags[0]),

78 
a_DEF_NiveRl_gs
,

79 (
a_DEF_NiveRl_gs
) / (asn_DEF_NativeReal_tags[0]),

80 { 0, 0, 
a_gic_no_cڡt
 },

85 
size_t
 
NiveRl__t_size
(cڡ 
a_TYPE_dest_t
 *
td
);

86 
NiveRl__g_doub
(cڡ 
a_TYPE_dest_t
 *
td
,

87 cڡ *
r
);

88 
ssize_t
 
NiveRl__t
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

89 
d
);

94 
a_dec_rv_t


95 
	$NiveRl_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

96 cڡ 
a_TYPE_dest_t
 *
td
, **

,

97 cڡ *
buf_r
, 
size_t
 
size
, 
g_mode
) {

98 
a_dec_rv_t
 
rv
;

99 
b_v_n_t
 
ngth
;

101 
	`ASN_DEBUG
("Decodg %aREAL (tm=%d)", 
td
->
me
, 
g_mode
);

106 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 0, 
buf_r
, 
size
, 
g_mode
, 0,

107 &
ngth
, 0);

108 if(
rv
.
code
 !
RC_OK
) val;

109 
	`as
(
ngth
 >= 0);

111 
	`ASN_DEBUG
("%ngth i%d bys", 
td
->
me
, ()
ngth
);

116 
buf_r
 = ((cڡ *)buf_r+ 
rv
.
csumed
;

117 
size
 -
rv
.
csumed
;

118 if(
ngth
 > (
b_v_n_t
)
size
) {

119 
rv
.
code
 = 
RC_WMORE
;

120 
rv
.
csumed
 = 0;

121  
rv
;

130 
ut8_t
 
sch
[24];

131 
REAL_t
 
tmp
;

132 
d
;

133 
t
;

135 if((
size_t
)
ngth
 < (
sch
)) {

136 
tmp
.
buf
 = 
sch
;

137 
tmp
.
size
 = 
ngth
;

140 
tmp
.
buf
 = 
	`CALLOC
(1, 
ngth
 + 1);

141 
tmp
.
size
 = 
ngth
;

142 if(!
tmp
.
buf
) {

143 
rv
.
code
 = 
RC_FAIL
;

144 
rv
.
csumed
 = 0;

145  
rv
;

149 
	`memy
(
tmp
.
buf
, 
buf_r
, 
ngth
);

150 
tmp
.
buf
[
ngth
] = '\0';

152 
t
 = 
	`a_REAL2doub
(&
tmp
, &
d
);

153 if(
tmp
.
buf
 !
sch

	`FREEMEM
(tmp.buf);

154 if(
t
) {

155 
rv
.
code
 = 
RC_FAIL
;

156 
rv
.
csumed
 = 0;

157  
rv
;

160 if(
	`NiveRl__t
(
td
, 

, 
d
) < 0)

161 
ASN__DECODE_FAILED
;

164 
rv
.
code
 = 
RC_OK
;

165 
rv
.
csumed
 +
ngth
;

167 
	`ASN_DEBUG
("Took %ld/%ld bytؒcod%s", ()
rv
.
csumed
,

168 ()
ngth
, 
td
->
me
);

170  
rv
;

171 
	}
}

176 
a_c_rv_t


177 
	$NiveRl_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

178 
g_mode
, 
b_v_g_t
 
g
,

179 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

180 
d
 = 
	`NiveRl__g_doub
(
td
, 

);

181 
a_c_rv_t
 
v
 = {0,0,0};

182 
REAL_t
 
tmp
;

185 
	`memt
(&
tmp
, 0, (tmp));

187 if(
	`a_doub2REAL
(&
tmp
, 
d
))

188 
ASN__ENCODE_FAILED
;

191 
v
 = 
	`d_code_imive
(
td
, &
tmp
, 
g_mode
, 
g
, 
cb
, 
p_key
);

192 if(
v
.
coded
 == -1) {

193 
	`as
(
v
.
ruu_r
 =&
tmp
);

194 
v
.
ruu_r
 = 

;

198 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

200  
v
;

201 
	}
}

203 #ide
ASN_DISABLE_PER_SUPPORT


208 
a_dec_rv_t


209 
	$NiveRl_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

210 cڡ 
a_TYPE_dest_t
 *
td
,

211 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

212 
a_r_da_t
 *
pd
) {

213 
a_dec_rv_t
 
rv
;

214 
d
;

215 
REAL_t
 
tmp
;

216 *
mp
 = &
tmp
;

217 
t
;

219 ()
cڡts
;

221 
	`memt
(&
tmp
, 0, (tmp));

222 
rv
 = 
	`OCTET_STRING_decode_ur
(
t_codec_x
, &
a_DEF_REAL
,

223 
NULL
, &
mp
, 
pd
);

224 if(
rv
.
code
 !
RC_OK
) {

225 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

226  
rv
;

229 
t
 = 
	`a_REAL2doub
(&
tmp
, &
d
);

230 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

231 if(
t

ASN__DECODE_FAILED
;

233 if(
	`NiveRl__t
(
td
, 

, 
d
) < 0 )

234 
ASN__DECODE_FAILED
;

236  
rv
;

237 
	}
}

242 
a_c_rv_t


243 
	$NiveRl_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

244 cڡ 
a_r_cڡts_t
 *
cڡts
,

245 cڡ *

, 
a_r_ou_t
 *
po
) {

246 
d
 = 
	`NiveRl__g_doub
(
td
, 

);

247 
a_c_rv_t
 
v
 = {0,0,0};

248 
REAL_t
 
tmp
;

250 ()
cڡts
;

253 
	`memt
(&
tmp
, 0, (tmp));

255 if(
	`a_doub2REAL
(&
tmp
, 
d
))

256 
ASN__ENCODE_FAILED
;

259 
v
 = 
	`OCTET_STRING_code_ur
(&
a_DEF_REAL
, 
NULL
, &
tmp
, 
po
);

260 if(
v
.
coded
 == -1)

261 
v
.
ruu_r
 = 

;

264 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

266  
v
;

267 
	}
}

270 
a_dec_rv_t


271 
	$NiveRl_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

272 cڡ 
a_TYPE_dest_t
 *
td
,

273 cڡ 
a_r_cڡts_t
 *
cڡts
,

274 **
dbl_r
, 
a_r_da_t
 *
pd
) {

275 *
Dbl
 = (*)*
dbl_r
;

276 
a_dec_rv_t
 
rv
;

277 
REAL_t
 
tmp
;

278 *
mp
 = &
tmp
;

279 
t
;

281 ()
cڡts
;

286 if(
Dbl
 =
NULL
) {

287 *
dbl_r
 = 
	`CALLOC
(1, (*
Dbl
));

288 
Dbl
 = (*)*
dbl_r
;

289 if(
Dbl
 =
NULL
)

290 
ASN__DECODE_FAILED
;

293 
	`memt
(&
tmp
, 0, (tmp));

294 
rv
 = 
	`OCTET_STRING_decode_
(
t_codec_x
, 
td
, 
NULL
,

295 &
mp
, 
pd
);

296 if(
rv
.
code
 !
RC_OK
) {

297 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

298  
rv
;

301 
t
 = 
	`a_REAL2doub
(&
tmp
, 
Dbl
);

302 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

303 if(
t

ASN__DECODE_FAILED
;

305  
rv
;

306 
	}
}

308 
a_c_rv_t


309 
	$NiveRl_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

310 cڡ 
a_r_cڡts_t
 *
cڡts
,

311 cڡ *

, 
a_r_ou_t
 *
po
) {

312 
Dbl
 = *(cڡ *)

;

313 
a_c_rv_t
 
v
 = {0,0,0};

314 
REAL_t
 
tmp
;

316 ()
cڡts
;

319 
	`memt
(&
tmp
, 0, (tmp));

321 if(
	`a_doub2REAL
(&
tmp
, 
Dbl
))

322 
ASN__ENCODE_FAILED
;

325 
v
 = 
	`OCTET_STRING_code_
(
td
, 
NULL
, &
tmp
, 
po
);

326 if(
v
.
coded
 == -1)

327 
v
.
ruu_r
 = 

;

330 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

332  
v
;

333 
	}
}

337 #ide
ASN_DISABLE_OER_SUPPORT


344 
	$NiveRl__twk_sw
(
size_t
 
t_size
, cڡ *

, 
ut8_t
 *
d
) {

345 cڡ 
ut8_t
 *
c
 = 

;

346 

 = -0.0;

347 
t_big_dn
 = *(cڡ *)&

 != 0;

349 cڡ 
sizeof_doub_is_8_a
[()-7] 
CC_NOTUSED
;

350 cڡ 
sizeof_doub_is_8_b
[9-()] 
CC_NOTUSED
;

352 cڡ 
sizeof_t_is_4_a
[()-3] 
CC_NOTUSED
;

353 cڡ 
sizeof_t_is_4_b
[5-()] 
CC_NOTUSED
;

355 
t_size
) {

357 
	`as
(() == 8);

358 if(
t_big_dn
) {

359 
d
[0] = 
c
[0];

360 
d
[1] = 
c
[1];

361 
d
[2] = 
c
[2];

362 
d
[3] = 
c
[3];

363 
d
[4] = 
c
[4];

364 
d
[5] = 
c
[5];

365 
d
[6] = 
c
[6];

366 
d
[7] = 
c
[7];

368 
d
[0] = 
c
[7];

369 
d
[1] = 
c
[6];

370 
d
[2] = 
c
[5];

371 
d
[3] = 
c
[4];

372 
d
[4] = 
c
[3];

373 
d
[5] = 
c
[2];

374 
d
[6] = 
c
[1];

375 
d
[7] = 
c
[0];

379 
	`as
(() == 4);

380 if(
t_big_dn
) {

381 
d
[0] = 
c
[0];

382 
d
[1] = 
c
[1];

383 
d
[2] = 
c
[2];

384 
d
[3] = 
c
[3];

386 
d
[0] = 
c
[3];

387 
d
[1] = 
c
[2];

388 
d
[2] = 
c
[1];

389 
d
[3] = 
c
[0];

393 
	}
}

398 
a_c_rv_t


399 
	$NiveRl_code_r
(cڡ 
a_TYPE_dest_t
 *
td
,

400 cڡ 
a_r_cڡts_t
 *
cڡts
,

401 cڡ *

, 
a_p_csume_bys_f
 *
cb
,

402 *
p_key
) {

403 
a_c_rv_t
 

 = {0, 0, 0};

405 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

406 if(
cڡts
 && cڡts->
vue
.
width
 != 0) {

408 
ut8_t
 
sch
[()];

409 cڡ 
a_NiveRl_ecifics_t
 *
ecs
 =

410 (cڡ 
a_NiveRl_ecifics_t
 *)
td
->
ecifics
;

411 
size_t
 
we_size
 = 
cڡts
->
vue
.
width
;

413 if(
ecs
 ? (
we_size
 =ecs->
t_size
)

414 : (
we_size
 == ())) {

420 
	`as
((
we_size
 == ())

421 || (
ecs
 && scs->
t_size
 =
we_size
));

422 
ASN__ENCODE_FAILED
;

429 
	`NiveRl__twk_sw
(
we_size
, 

, 
sch
);

430 if(
	`cb
(
sch
, 
we_size
, 
p_key
) < 0) {

431 
ASN__ENCODE_FAILED
;

433 

.
coded
 = 
we_size
;

434 
	`ASN__ENCODED_OK
(

);

437 
d
 = 
	`NiveRl__g_doub
(
td
, 

);

438 
ssize_t
 
n_n
;

439 
REAL_t
 
tmp
;

442 
	`memt
(&
tmp
, 0, (tmp));

444 if(
	`a_doub2REAL
(&
tmp
, 
d
)) {

445 
ASN__ENCODE_FAILED
;

449 
n_n
 = 
	`r_rlize_ngth
(
tmp
.
size
, 
cb
, 
p_key
);

450 if(
n_n
 < 0 || 
	`cb
(
tmp
.
buf
,mp.
size
, 
p_key
) < 0) {

451 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

452 
ASN__ENCODE_FAILED
;

454 

.
coded
 = 
n_n
 + 
tmp
.
size
;

455 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &
tmp
);

456 
	`ASN__ENCODED_OK
(

);

459 
	}
}

461 
a_dec_rv_t


462 
	$NiveRl_decode_r
(cڡ 
a_codec_x_t
 *
t_codec_x
,

463 cڡ 
a_TYPE_dest_t
 *
td
,

464 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

465 cڡ *
r
, 
size_t
 
size
) {

466 
a_dec_rv_t
 
ok
 = {
RC_OK
, 0};

467 
d
;

468 
ssize_t
 
n_n
;

469 
size_t
 
_body_n
;

471 ()
t_codec_x
;

473 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

474 if(
cڡts
 && cڡts->
vue
.
width
 != 0) {

476 
ut8_t
 
sch
[()];

477 
size_t
 
we_size
 = 
cڡts
->
vue
.
width
;

479 if(
size
 < 
we_size
)

480 
ASN__DECODE_STARVED
;

486 
	`NiveRl__twk_sw
(
we_size
, 
r
, 
sch
);

489 
we_size
) {

492 
tmp
;

493 
	`memy
(&
tmp
, 
sch
, ());

494 if(
	`NiveRl__t
(
td
, 

, 
tmp
) < 0)

495 
ASN__DECODE_FAILED
;

500 
tmp
;

501 
	`memy
(&
tmp
, 
sch
, ());

502 if(
	`NiveRl__t
(
td
, 

, 
tmp
) < 0)

503 
ASN__DECODE_FAILED
;

507 
ASN__DECODE_FAILED
;

510 
ok
.
csumed
 = 
we_size
;

511  
ok
;

514 
n_n
 = 
	`r_tch_ngth
(
r
, 
size
, &
_body_n
);

515 if(
n_n
 < 0
ASN__DECODE_FAILED
;

516 if(
n_n
 =0
ASN__DECODE_STARVED
;

518 
r
 = (cڡ * + 
n_n
;

519 
size
 -
n_n
;

521 if(
_body_n
 > 
size

ASN__DECODE_STARVED
;

524 
ut8_t
 
sch
[24];

525 
REAL_t
 
tmp
;

526 
t
;

528 if(
_body_n
 < (
sch
)) {

529 
tmp
.
buf
 = 
sch
;

530 
tmp
.
size
 = 
_body_n
;

533 
tmp
.
buf
 = 
	`CALLOC
(1, 
_body_n
 + 1);

534 
tmp
.
size
 = 
_body_n
;

535 if(!
tmp
.
buf
) {

536 
ASN__DECODE_FAILED
;

540 
	`memy
(
tmp
.
buf
, 
r
, 
_body_n
);

541 
tmp
.
buf
[
_body_n
] = '\0';

543 
t
 = 
	`a_REAL2doub
(&
tmp
, &
d
);

544 if(
tmp
.
buf
 !
sch

	`FREEMEM
(tmp.buf);

545 if(
t
) {

546 
	`ASN_DEBUG
("REAL decoded i%" 
ASN_PRI_SIZE
 " bytes, but can't convert double",

547 
_body_n
);

548 
ASN__DECODE_FAILED
;

552 if(
	`NiveRl__t
(
td
, 

, 
d
) < 0)

553 
ASN__DECODE_FAILED
;

555 
ok
.
csumed
 = 
n_n
 + 
_body_n
;

556  
ok
;

557 
	}
}

564 
a_dec_rv_t


565 
	$NiveRl_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

566 cڡ 
a_TYPE_dest_t
 *
td
, **

,

567 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

568 
a_dec_rv_t
 
rv
;

569 
REAL_t
 

 = { 0, 0 };

570 
REAL_t
 *
p
 = &

;

572 
rv
 = 
	`REAL_decode_x
(
t_codec_x
, 
td
, (**)&
p
, 
t_mme
,

573 
buf_r
, 
size
);

574 if(
rv
.
code
 =
RC_OK
) {

575 
d
;

576 if(
	`a_REAL2doub
(&

, &
d
|| 
	`NiveRl__t
(
td
, 

, d) < 0) {

577 
rv
.
code
 = 
RC_FAIL
;

578 
rv
.
csumed
 = 0;

582 
rv
.
csumed
 = 0;

584 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(
a_DEF_REAL
, &

);

585  
rv
;

586 
	}
}

588 
a_c_rv_t


589 
	$NiveRl_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

590 
ev
, 
x_cod_ags_e
 
ags
,

591 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

592 
d
 = 
	`NiveRl__g_doub
(
td
, 

);

593 
a_c_rv_t
 

 = {0,0,0};

595 ()
ev
;

597 

.
coded
 = 
	`REAL__dump
(
d
, 
ags
 & 
XER_F_CANONICAL
, 
cb
, 
p_key
);

598 if(

.
coded
 < 0
ASN__ENCODE_FAILED
;

600 
	`ASN__ENCODED_OK
(

);

601 
	}
}

607 
	$NiveRl_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

608 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

609 ()
ev
;

611 if(

) {

612 
d
 = 
	`NiveRl__g_doub
(
td
, 

);

613  (
	`REAL__dump
(
d
, 0, 
cb
, 
p_key
) < 0) ? -1 : 0;

615  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

617 
	}
}

620 
	$NiveRl_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

621 cڡ *
br
) {

623 if(

 && 
br
) {

624 
a
 = 
	`NiveRl__g_doub
(
td
, 

);

625 
b
 = 
	`NiveRl__g_doub
(
td
, 
br
);

628 if(
	`a_i
(
a
)) {

629 if(
	`a_i
(
b
)) {

634 } if(
	`a_i
(
b
)) {

638 if(
a
 < 
b
) {

640 } if(
a
 > 
b
) {

645 } if(!

) {

650 
	}
}

653 
	$NiveRl_
(cڡ 
a_TYPE_dest_t
 *
td
, *
r
,

654 
a_ru__mhod
 
mhod
) {

655 if(!
td
 || !
r
)

658 
	`ASN_DEBUG
("Freeing %ss REAL (%d, %p, Native)",

659 
td
->
me
, 
mhod
, 
r
);

661 
mhod
) {

662 
ASFM_FREE_EVERYTHING
:

663 
	`FREEMEM
(
r
);

665 
ASFM_FREE_UNDERLYING
:

667 
ASFM_FREE_UNDERLYING_AND_RESET
: {

668 cڡ 
a_NiveRl_ecifics_t
 *
ecs
;

669 
size_t
 
t_size
;

670 
ecs
 = (cڡ 
a_NiveRl_ecifics_t
 *)
td
->
ecifics
;

671 
t_size
 = 
ecs
 ? specs->float_size : ();

672 
	`memt
(
r
, 0, 
t_size
);

675 
	}
}

677 
a_ndom_fl_su_t


678 
	$NiveRl_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

679 cڡ 
a_codg_cڡts_t
 *
cڡts
,

680 
size_t
 
max_ngth
) {

681 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 0};

682 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

683 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

684 #ide
INFINITY


685 
	#INFINITY
 (1.0/0.0)

	)

687 #ide
NAN


688 
	#NAN
 (0.0/0.0)

	)

690 cڡ 
doub_vues
[] = {

691 -
M_E
, M_E, -
M_PI
, M_PI,

699 -
DBL_MIN
, DBL_MIN,

700 -
DBL_MAX
, DBL_MAX,

701 #ifde 
DBL_TRUE_MIN


702 -
DBL_TRUE_MIN
, DBL_TRUE_MIN

705 cڡ 
t_vues
[] = {

706 0, -0.0, -1, 1, -
M_E
, M_E, -3.14, 3.14, -
M_PI
, M_PI, -255, 255,

707 -
FLT_MIN
, FLT_MIN,

708 -
FLT_MAX
, FLT_MAX,

709 #ifde 
FLT_TRUE_MIN


710 -
FLT_TRUE_MIN
, FLT_TRUE_MIN,

712 
INFINITY
, -INFINITY, 
NAN


714 
ssize_t
 
t_t_size
 = 
	`NiveRl__t_size
(
td
);

715 cڡ 
size_t
 
n_doubs
 = (
doub_vues
) / (double_values[0]);

716 cڡ 
size_t
 
n_ts
 = (
t_vues
) / (float_values[0]);

717 
d
;

719 ()
cڡts
;

721 if(
max_ngth
 =0 
su_skd
;

723 if(
t_t_size
 =(&& 
	`a_ndom_bwn
(0, 1) == 0) {

724 
d
 = 
doub_vues
[
	`a_ndom_bwn
(0, 
n_doubs
 - 1)];

726 
d
 = 
t_vues
[
	`a_ndom_bwn
(0, 
n_ts
 - 1)];

729 if(
	`NiveRl__t
(
td
, 

, 
d
) < 0) {

730  
su_ed
;

733 
su_ok
.
ngth
 = 
t_t_size
;

734  
su_ok
;

735 
	}
}

742 
size_t


743 
	$NiveRl__t_size
(cڡ 
a_TYPE_dest_t
 *
td
) {

744 cڡ 
a_NiveRl_ecifics_t
 *
ecs
 =

745 (cڡ 
a_NiveRl_ecifics_t
 *)
td
->
ecifics
;

746  
ecs
 ? scs->
t_size
 : ();

747 
	}
}

750 
	$NiveRl__g_doub
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
r
) {

751 
size_t
 
t_size
 = 
	`NiveRl__t_size
(
td
);

752 if(
t_size
 == ()) {

753  *(cڡ *)
r
;

755  *(cڡ *)
r
;

757 
	}
}

759 
ssize_t


760 
	$NiveRl__t
(cڡ 
a_TYPE_dest_t
 *
td
, **

, 
d
) {

761 
size_t
 
t_size
 = 
	`NiveRl__t_size
(
td
);

762 *
tive
;

764 if(!(
tive
 = *

)) {

765 
tive
 = (*

 = 
	`CALLOC
(1, 
t_size
));

766 if(!
tive
) {

771 if(
t_size
 == ()) {

772 if(
	`a_doub2t
(
d
, (*)
tive
)) {

776 *(*)
tive
 = 
d
;

779  
t_size
;

780 
	}
}

	@NgENB-ID.c

8 
	~"NgENB-ID.h
"

11 
	$memb_maoNgENB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 if(

->
size
 > 0) {

25 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

27 
size
 = 0;

30 if((
size
 == 20)) {

34 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

36 
td
->
me
, 
__FILE__
, 
__LINE__
);

39 
	}
}

42 
	$memb_shtMaoNgENB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

43 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

44 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

45 
size_t
 
size
;

47 if(!

) {

48 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

50 
td
->
me
, 
__FILE__
, 
__LINE__
);

54 if(

->
size
 > 0) {

56 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

58 
size
 = 0;

61 if((
size
 == 18)) {

65 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

67 
td
->
me
, 
__FILE__
, 
__LINE__
);

70 
	}
}

73 
	$memb_lgMaoNgENB_ID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

74 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

75 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

76 
size_t
 
size
;

78 if(!

) {

79 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

81 
td
->
me
, 
__FILE__
, 
__LINE__
);

85 if(

->
size
 > 0) {

87 
size
 = 8 * 

->siz- (->
bs_unud
 & 0x07);

89 
size
 = 0;

92 if((
size
 == 21)) {

96 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

98 
td
->
me
, 
__FILE__
, 
__LINE__
);

101 
	}
}

103 
a_r_cڡts_t
 
a_PER_memb_maoNgENB_ID_cڡr_2
 
	gCC_NOTUSED
 = {

104 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

105 { 
APC_CONSTRAINED
, 0, 0, 20, 20 } ,

108 
a_r_cڡts_t
 
a_PER_memb_shtMaoNgENB_ID_cڡr_3
 
	gCC_NOTUSED
 = {

109 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

110 { 
APC_CONSTRAINED
, 0, 0, 18, 18 } ,

113 
a_r_cڡts_t
 
a_PER_memb_lgMaoNgENB_ID_cڡr_4
 
	gCC_NOTUSED
 = {

114 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

115 { 
APC_CONSTRAINED
, 0, 0, 21, 21 } ,

118 
a_r_cڡts_t
 
a_PER_ty_NgENB_ID_cڡr_1
 
	gCC_NOTUSED
 = {

119 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 2, 2, 0, 2 } ,

120 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

123 
a_TYPE_memb_t
 
	ga_MBR_NgENB_ID_1
[] = {

124 { 
ATF_NOFLAGS
, 0, 
offtof
(
NgENB_ID
, 
choi
.
maoNgENB_ID
),

125 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

127 &
a_DEF_BIT_STRING
,

129 { 0, &
a_PER_memb_maoNgENB_ID_cڡr_2
, 
memb_maoNgENB_ID_cڡt_1
 },

133 { 
ATF_NOFLAGS
, 0, 
offtof
(
NgENB_ID
, 
choi
.
shtMaoNgENB_ID
),

134 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

136 &
a_DEF_BIT_STRING
,

138 { 0, &
a_PER_memb_shtMaoNgENB_ID_cڡr_3
, 
memb_shtMaoNgENB_ID_cڡt_1
 },

142 { 
ATF_NOFLAGS
, 0, 
offtof
(
NgENB_ID
, 
choi
.
lgMaoNgENB_ID
),

143 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

145 &
a_DEF_BIT_STRING
,

147 { 0, &
a_PER_memb_lgMaoNgENB_ID_cڡr_4
, 
memb_lgMaoNgENB_ID_cڡt_1
 },

152 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_NgENB_ID_g2_1
[] = {

153 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

154 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

155 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

157 
a_CHOICE_ecifics_t
 
	ga_SPC_NgENB_ID_ecs_1
 = {

158 (
NgENB_ID
),

159 
offtof
(
NgENB_ID
, 
_a_x
),

160 
offtof
(
NgENB_ID
, 
e
),

161 (((
NgENB_ID
 *)0)->
e
),

162 
a_MAP_NgENB_ID_g2_1
,

167 
a_TYPE_dest_t
 
	ga_DEF_NgENB_ID
 = {

170 &
a_OP_CHOICE
,

175 { 0, &
a_PER_ty_NgENB_ID_cڡr_1
, 
CHOICE_cڡt
 },

176 
a_MBR_NgENB_ID_1
,

178 &
a_SPC_NgENB_ID_ecs_1


	@OCTET_STRING.c

6 
	~<a_.h
>

7 
	~<OCTET_STRING.h
>

8 
	~<BIT_STRING.h
>

9 
	~<o.h
>

14 cڡ 
b_v_g_t
 
	ga_DEF_OCTET_STRING_gs
[] = {

15 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

17 
a_OCTET_STRING_ecifics_t
 
	ga_SPC_OCTET_STRING_ecs
 = {

18 (
OCTET_STRING_t
),

19 
offtof
(
OCTET_STRING_t
, 
_a_x
),

20 
ASN_OSUBV_STR


23 
a_TYPE_ݔi_t
 
	ga_OP_OCTET_STRING
 = {

24 
OCTET_STRING_
,

25 
OCTET_STRING_t
,

26 
OCTET_STRING_com
,

27 
OCTET_STRING_decode_b
,

28 
OCTET_STRING_code_d
,

29 
OCTET_STRING_decode_x_hex
,

30 
OCTET_STRING_code_x
,

31 #ifdef 
ASN_DISABLE_OER_SUPPORT


35 
OCTET_STRING_decode_r
,

36 
OCTET_STRING_code_r
,

38 #ifdef 
ASN_DISABLE_PER_SUPPORT


44 
OCTET_STRING_decode_ur
,

45 
OCTET_STRING_code_ur
,

46 
OCTET_STRING_decode_
,

47 
OCTET_STRING_code_
,

49 
OCTET_STRING_ndom_fl
,

52 
a_TYPE_dest_t
 
	ga_DEF_OCTET_STRING
 = {

55 &
a_OP_OCTET_STRING
,

56 
a_DEF_OCTET_STRING_gs
,

57 (
a_DEF_OCTET_STRING_gs
)

58 / (
a_DEF_OCTET_STRING_gs
[0]),

59 
a_DEF_OCTET_STRING_gs
,

60 (
a_DEF_OCTET_STRING_gs
)

61 / (
a_DEF_OCTET_STRING_gs
[0]),

62 { 0, 0, 
a_gic_no_cڡt
 },

64 &
a_SPC_OCTET_STRING_ecs


67 #unde
_CH_PHASE


68 #unde
NEXT_PHASE


69 #unde
PREV_PHASE


70 
	#_CH_PHASE
(
x
, 
c
) do { \

71 if(
x
->
pha
 == 0) \

72 
x
->
cڋxt
 = 0; \

73 
x
->
pha
 +
c
; \

74 } 0)

	)

75 
	#NEXT_PHASE
(
x

	`_CH_PHASE
(x, +1)

	)

76 
	#PREV_PHASE
(
x

	`_CH_PHASE
(x, -1)

	)

78 #unde
ADVANCE


79 
	#ADVANCE
(
num_bys
) do { \

80 
size_t
 
num
 = (
num_bys
); \

81 
buf_r
 = ((cڡ *)buf_r+ 
num
; \

82 
size
 -
num
; \

83 
csumed_mylf
 +
num
; \

84 } 0)

	)

86 #unde
RETURN


87 
	#RETURN
(
_code
) do { \

88 
a_dec_rv_t
 
tmv
; \

89 
tmv
.
code
 = 
_code
; \

90 
tmv
.
csumed
 = 
csumed_mylf
; \

91  
tmv
; \

92 } 0)

	)

94 #unde
APPEND


95 
	#APPEND
(
bu
, 
bufsize
) do { \

96 
size_t
 
_bs
 = (
bufsize
); \

97 
size_t
 
_ns
 = 
x
->
cڋxt
; \

98 
size_t
 
_es
 = 

->
size
 + 
_bs
; \

100 if(()
_es
 < 0
	`RETURN
(
RC_FAIL
); \

101 if(
_ns
 <
_es
) { \

102 *
r
; \

104 d{ 
_ns
 = _ns ? _ns << 1 : 16; } \

105 
_ns
 <
_es
); \

107 if(()
_ns
 < 0
	`RETURN
(
RC_FAIL
); \

108 
r
 = 
	`REALLOC
(

->
buf
, 
_ns
); \

109 if(
r
) { \

110 

->
buf
 = (
ut8_t
 *)
r
; \

111 
x
->
cڋxt
 = 
_ns
; \

113 
	`RETURN
(
RC_FAIL
); \

115 
	`ASN_DEBUG
("Rotg i%ld", ()
_ns
); \

117 
	`memy
(

->
buf
 + st->
size
, 
bu
, 
_bs
); \

119 

->
buf
[
_es
] = '\0'; \

120 

->
size
 = 
_es
; \

121 } 0)

	)

129 
	s_ack_
 {

130 
b_v_n_t
 
	m
;

131 
b_v_n_t
 
	mg
;

132 
	mct_v
;

133 
	mwt_nus
;

134 
	mbs_chݳd
;

135 
b_v_g_t
 
	mg
;

136 
_ack_
 *
	mev
;

137 
_ack_
 *
	mxt
;

139 
	s_ack
 {

140 
_ack_
 *
	m
;

141 
_ack_
 *
	mcur_r
;

144 
_ack_
 *

145 
	$OS__add_ack_
(
_ack
 *

) {

146 
_ack_
 *
l
;

151 if(

->
cur_r
 && st->cur_r->
xt
) {

152 
l
 = 

->
cur_r
->
xt
;

153 
l
->
bs_chݳd
 = 0;

154 
l
->
g
 = 0;

157 
l
 = (
_ack_
 *)
	`CALLOC
(1, (_stack_el));

158 if(
l
 =
NULL
)

159  
NULL
;

161 if(

->

) {

163 
l
->
ct_v
 = 

->

->cont_level + 1;

164 

->

->
xt
 = 
l
;

166 
l
->
ev
 = 

->

;

167 

->

 = 
l
;

170 

->
cur_r
 = 
l
;

172  
l
;

173 
	}
}

175 
_ack
 *

176 
	$_w_ack
() {

177  (
_ack
 *)
	`CALLOC
(1, (_stack));

178 
	}
}

183 
a_dec_rv_t


184 
	$OCTET_STRING_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

185 cڡ 
a_TYPE_dest_t
 *
td
, **

,

186 cڡ *
buf_r
, 
size_t
 
size
, 
g_mode
) {

187 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


188 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


189 : &
a_SPC_OCTET_STRING_ecs
;

190 
BIT_STRING_t
 *

 = (BIT_STRING_*)*

;

191 
a_dec_rv_t
 
rv
;

192 
a_ru_x_t
 *
x
;

193 
ssize_t
 
csumed_mylf
 = 0;

194 
_ack
 *
ck
;

195 
_ack_
 *
l
 = 0;

196 
v_cڡr
;

197 
a_OS_Subv
 
ty_v
 = 
ecs
->
subv
;

199 
	`ASN_DEBUG
("Decoding %ss %s (frame %ld)",

200 
td
->
me
,

201 (
ty_v
 =
ASN_OSUBV_STR
) ?

203 ()
size
);

208 if(

 =
NULL
) {

209 

 = (
BIT_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

210 if(

 =
NULL

	`RETURN
(
RC_FAIL
);

214 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

216 
x
->
pha
) {

221 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 
x
,

222 
buf_r
, 
size
, 
g_mode
, -1,

223 &
x
->

, &
v_cڡr
);

224 if(
rv
.
code
 !
RC_OK
)

225  
rv
;

227 if(
v_cڡr
) {

231 
x
->
r
 = 
	`_w_ack
();

232 if(!
x
->
r
) {

233 
	`RETURN
(
RC_FAIL
);

239 
	`_CH_PHASE
(
x
, 3);

240 if(
ty_v
 =
ASN_OSUBV_ANY
 && 
g_mode
 != 1)

241 
	`APPEND
(
buf_r
, 
rv
.
csumed
);

242 
	`ADVANCE
(
rv
.
csumed
);

243 
pha3
;

246 
	`NEXT_PHASE
(
x
);

249 
pha1
:

253 
ck
 = (
_ack
 *)
x
->
r
;

254 
l
 = 
ck
->
cur_r
;

256 
b_v_g_t
 
v_g
;

257 
b_v_n_t
 
v_n
;

258 
b_v_g_t
 
exed_g
;

259 
ssize_t
 

, 

, 
vl
;

261 
size_t
 
Le
 = ((!
l
||(size_t)l->

 >
size
)

262 ?
size
:(
size_t
)
l
->

);

265 
	`ASN_DEBUG
("%p, s->l=%ld, s->wn=%ld, s->g=%ld\n", (*)
l
,

266 ()(
l
?l->

:0),

267 ()(
l
?l->
wt_nus
:0),

268 ()(
l
?l->
g
:0)

270 if(
l
 && s->

 <0 && s->
wt_nus
 == 0) {

271 if(
l
->
ev
) {

272 
_ack_
 *
ev
 = 
l
->prev;

273 if(
ev
->

 != -1) {

274 if(
ev
->

 < 
l
->
g
)

275 
	`RETURN
(
RC_FAIL
);

276 
ev
->

 -
l
->
g
;

278 
ev
->
g
 +
l
->got;

279 
l
 = 
ck
->
cur_r
 = 
ev
;

280 if(!
l
) ;

281 
v_cڡr
 = 1;

284 
l
 = 
ck
->
cur_r
 = 0;

289 

 = 
	`b_tch_g
(
buf_r
, 
Le
, &
v_g
);

290 
	`ASN_DEBUG
("fetchag(size=%ld,L=%ld), %sstack,eft=%ld, wn=%ld,l=%ld",

291 ()
size
, ()
Le
, 
l
?"":"!",

292 ()(
l
?l->

:0),

293 ()(
l
?l->
wt_nus
:0),

294 ()

);

295 

) {

296 -1: 
	`RETURN
(
RC_FAIL
);

297 0: 
	`RETURN
(
RC_WMORE
);

300 
v_cڡr
 = 
	`BER_TLV_CONSTRUCTED
(
buf_r
);

302 

 = 
	`b_tch_ngth
(
v_cڡr
,

303 (cڡ *)
buf_r
 + 

,
Le
 -l,&
v_n
);

304 
	`ASN_DEBUG
("Gotag=%s,c=%d,eft=%ld,l=%ld,en=%ld,l=%ld",

305 
	`b_v_g_rg
(
v_g
), 
v_cڡr
,

306 ()
Le
, ()

, ()
v_n
, ()

);

307 

) {

308 -1: 
	`RETURN
(
RC_FAIL
);

309 0: 
	`RETURN
(
RC_WMORE
);

312 if(
l
 && s->
wt_nus


313 && ((cڡ 
ut8_t
 *)
buf_r
)[0] == 0

314 && ((cڡ 
ut8_t
 *)
buf_r
)[1] == 0)

317 
	`ASN_DEBUG
("E EOC; wn=%d--", 
l
->
wt_nus
);

319 if(
ty_v
 =
ASN_OSUBV_ANY


320 && (
g_mode
 !1 || 
l
->
ct_v
))

321 
	`APPEND
("\0\0", 2);

323 
	`ADVANCE
(2);

324 
l
->
g
 += 2;

325 if(
l
->

 != -1) {

326 
l
->

 -= 2;

329 
l
->
wt_nus
--;

330 if(
l
->
wt_nus
 == 0) {

332 
l
->

 = 0;

333 
v_cڡr
 = 1;

343 
ty_v
) {

344 
ASN_OSUBV_BIT
:

347 
ASN_OSUBV_STR
:

349 if(
l
) {

350 
v
 = 
l
->
ct_v
;

351 if(
v
 < 
td
->
l_gs_cou
) {

352 
exed_g
 = 
td
->
l_gs
[
v
];

354 } if(
td
->
l_gs_cou
) {

355 
exed_g
 = 
td
->
l_gs


356 [
td
->
l_gs_cou
 - 1];

362 
ASN_OSUBV_ANY
:

363 
exed_g
 = 
v_g
;

368 if(
v_g
 !
exed_g
) {

369 
buf
[2][32];

370 
	`b_v_g_t
(
v_g
,

371 
buf
[0], (buf[0]));

372 
	`b_v_g_t
(
td
->
gs
[td->
gs_cou
-1],

373 
buf
[1], (buf[1]));

374 
	`ASN_DEBUG
("Tag doesot matchxpectation: %s != %s",

375 
buf
[0], buf[1]);

376 
	`RETURN
(
RC_FAIL
);

379 
vl
 = 

 + 

;

380 if((
v_n
 + 
vl
) < 0) {

382 
	`ASN_DEBUG
("TLVncoding +ength (%ld) isoo big",

383 ()
v_n
);

384 
	`RETURN
(
RC_FAIL
);

390 
l
 = 
	`OS__add_ack_
(
ck
);

391 if(!
l

	`RETURN
(
RC_FAIL
);

393 
l
->
g
 = 
v_g
;

395 
l
->
wt_nus
 = (
v_n
==-1);

396 if(
l
->
ev
 && s->ev->

 != -1) {

398 if(
l
->
ev
->

 < 
vl
 + (
v_n
==-1?0:tlv_len))

399 
	`RETURN
(
RC_FAIL
);

400 if(
v_n
 == -1)

401 
l
->

 = s->
ev
-> - 
vl
;

403 
l
->

 = 
v_n
;

405 
l
->

 = 
v_n
;

407 if(
ty_v
 =
ASN_OSUBV_ANY


408 && (
g_mode
 !1 || 
l
->
ct_v
))

409 
	`APPEND
(
buf_r
, 
vl
);

410 
l
->
g
 +
vl
;

411 
	`ADVANCE
(
vl
);

413 
	`ASN_DEBUG
("+EXPECT2 got=%ldeft=%ld, wn=%d, clvl=%u",

414 ()
l
->
g
, ()l->

,

415 
l
->
wt_nus
, s->
ct_v
);

417 } 
v_cڡr
);

418 if(
l
 =
NULL
) {

420 
	`ASN_DEBUG
("Phase out");

421 
	`_CH_PHASE
(
x
, +3);

425 
	`NEXT_PHASE
(
x
);

428 
ck
 = (
_ack
 *)
x
->
r
;

429 
l
 = 
ck
->
cur_r
;

430 
	`ASN_DEBUG
("Phase 2: Need %ld bytes, size=%ld,lrg=%ld, wn=%d",

431 ()
l
->

, ()
size
, ()l->
g
,

432 
l
->
wt_nus
);

434 
b_v_n_t
 
n
;

436 
	`as
(
l
->

 >= 0);

438 
n
 = ((
b_v_n_t
)
size
 < 
l
->

)

439 ? (
b_v_n_t
)
size
 : 
l
->

;

440 if(
n
 > 0) {

441 if(
ty_v
 =
ASN_OSUBV_BIT


442 && 
l
->
bs_chݳd
 == 0) {

444 

->
bs_unud
 = *(cڡ 
ut8_t
 *)
buf_r
;

445 
	`APPEND
(((cڡ *)
buf_r
+1), (
n
 - 1));

446 
l
->
bs_chݳd
 = 1;

448 
	`APPEND
(
buf_r
, 
n
);

450 
	`ADVANCE
(
n
);

451 
l
->

 -
n
;

452 
l
->
g
 +
n
;

455 if(
l
->

) {

456 
	`ASN_DEBUG
("OSeft %ld, size = %ld, wn=%d\n",

457 ()
l
->

, ()
size
, s->
wt_nus
);

458 
	`RETURN
(
RC_WMORE
);

461 
	`PREV_PHASE
(
x
);

462 
pha1
;

466 
pha3
:

470 
	`as
(
x
->

 >= 0);

472 if(
size
 < (
size_t
)
x
->

) {

473 if(!
size

	`RETURN
(
RC_WMORE
);

474 if(
ty_v
 =
ASN_OSUBV_BIT
 && !
x
->
cڋxt
) {

475 

->
bs_unud
 = *(cڡ 
ut8_t
 *)
buf_r
;

476 
x
->

--;

477 
	`ADVANCE
(1);

479 
	`APPEND
(
buf_r
, 
size
);

480 
	`as
(
x
->
cڋxt
 > 0);

481 
x
->

 -
size
;

482 
	`ADVANCE
(
size
);

483 
	`RETURN
(
RC_WMORE
);

485 if(
ty_v
 =
ASN_OSUBV_BIT


486 && !
x
->
cڋxt
 && ctx->

) {

487 

->
bs_unud
 = *(cڡ 
ut8_t
 *)
buf_r
;

488 
x
->

--;

489 
	`ADVANCE
(1);

491 
	`APPEND
(
buf_r
, 
x
->

);

492 
	`ADVANCE
(
x
->

);

493 
x
->

 = 0;

495 
	`NEXT_PHASE
(
x
);

500 if(
l
) {

501 
	`ASN_DEBUG
("3sel=%p, wn=%d,=%ld, g=%ld, size=%ld",

502 (*)
l
->
ev
, s->
wt_nus
,

503 ()
l
->

, ()l->
g
, ()
size
);

504 if(
l
->
ev
 || s->
wt_nus
 > 1 || s->

 > 0) {

505 
	`RETURN
(
RC_WMORE
);

512 if(
ty_v
 =
ASN_OSUBV_BIT
) {

513 if(

->
size
) {

514 if(

->
bs_unud
 < 0 || st->bits_unused > 7) {

515 
	`RETURN
(
RC_FAIL
);

518 

->
buf
[->
size
-1] &0xf<< st->
bs_unud
;

520 if(

->
bs_unud
) {

521 
	`RETURN
(
RC_FAIL
);

526 
	`ASN_DEBUG
("Took %ld bytesoncode %s: [%s]:%ld",

527 ()
csumed_mylf
, 
td
->
me
,

528 (
ty_v
 =
ASN_OSUBV_STR
? (*)

->
buf
 : "<data>",

529 ()

->
size
);

532 
	`RETURN
(
RC_OK
);

533 
	}
}

538 
a_c_rv_t


539 
	$OCTET_STRING_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

540 
g_mode
, 
b_v_g_t
 
g
,

541 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

542 
a_c_rv_t
 

 = { 0, 0, 0 };

543 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


544 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


545 : &
a_SPC_OCTET_STRING_ecs
;

546 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

547 
a_OS_Subv
 
ty_v
 = 
ecs
->
subv
;

548 
fix_ϡ_by
 = 0;

550 
	`ASN_DEBUG
("%s %ss OCTET STRING",

551 
cb
?"Eimg":"Encodg", 
td
->
me
);

556 if(
ty_v
 !
ASN_OSUBV_ANY
 || 
g_mode
 == 1) {

557 

.
coded
 = 
	`d_wre_gs
(
td
,

558 (
ty_v
 =
ASN_OSUBV_BIT
+ 

->
size
,

559 
g_mode
, 
ty_v
 =
ASN_OSUBV_ANY
, 
g
,

560 
cb
, 
p_key
);

561 if(

.
coded
 == -1) {

562 

.
ed_ty
 = 
td
;

563 

.
ruu_r
 = 

;

564  

;

568 
	`as
(
ty_v
 !
ASN_OSUBV_ANY
 || 
g_mode
 != -1);

569 

.
coded
 = 0;

572 if(!
cb
) {

573 

.
coded
 +(
ty_v
 =
ASN_OSUBV_BIT
+ 

->
size
;

574 
	`ASN__ENCODED_OK
(

);

580 if(
ty_v
 =
ASN_OSUBV_BIT
) {

581 
ut8_t
 
b
 = 

->
bs_unud
 & 0x07;

582 if(
b
 && 

->
size

fix_ϡ_by
 = 1;

583 
	`ASN__CALLBACK
(&
b
, 1);

587 
	`ASN__CALLBACK
(

->
buf
, st->
size
 - 
fix_ϡ_by
);

590 if(
fix_ϡ_by
) {

591 
ut8_t
 
b
 = 

->
buf
[->
size
-1] & (0xf<< st->
bs_unud
);

592 
	`ASN__CALLBACK
(&
b
, 1);

595 
	`ASN__ENCODED_OK
(

);

596 
cb_ed
:

597 
ASN__ENCODE_FAILED
;

598 
	}
}

600 
a_c_rv_t


601 
	$OCTET_STRING_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

602 
ev
, 
x_cod_ags_e
 
ags
,

603 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

604 cڡ * cڡ 
h2c
 = "0123456789ABCDEF";

605 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

606 
a_c_rv_t
 

 = { 0, 0, 0 };

607 
sch
[16 * 3 + 4];

608 *
p
 = 
sch
;

609 
ut8_t
 *
buf
;

610 
ut8_t
 *
d
;

611 
size_t
 
i
;

613 if(!

 || (!->
buf
 && st->
size
))

614 
ASN__ENCODE_FAILED
;

616 

.
coded
 = 0;

621 
buf
 = 

->buf;

622 
d
 = 
buf
 + 

->
size
;

623 if(
ags
 & 
XER_F_CANONICAL
) {

624 *
snd
 = 
sch
 + ((scratch) - 2);

625 ; 
buf
 < 
d
; buf++) {

626 if(
p
 >
snd
) {

627 
	`ASN__CALLBACK
(
sch
, 
p
 - scratch);

628 
p
 = 
sch
;

630 *
p
++ = 
h2c
[(*
buf
 >> 4) & 0x0F];

631 *
p
++ = 
h2c
[*
buf
 & 0x0F];

634 
	`ASN__CALLBACK
(
sch
, 
p
-scratch);

636 
i
 = 0; 
buf
 < 
d
; buf++, i++) {

637 if(!(
i
 % 16&& (|| 

->
size
 > 16)) {

638 
	`ASN__CALLBACK
(
sch
, 
p
-scratch);

639 
p
 = 
sch
;

640 
	`ASN__TEXT_INDENT
(1, 
ev
);

642 *
p
++ = 
h2c
[(*
buf
 >> 4) & 0x0F];

643 *
p
++ = 
h2c
[*
buf
 & 0x0F];

644 *
p
++ = 0x20;

646 if(
p
 - 
sch
) {

647 
p
--;

648 
	`ASN__CALLBACK
(
sch
, 
p
-scratch);

649 if(

->
size
 > 16)

650 
	`ASN__TEXT_INDENT
(1, 
ev
-1);

654 
	`ASN__ENCODED_OK
(

);

655 
cb_ed
:

656 
ASN__ENCODE_FAILED
;

657 
	}
}

659 cڡ 
	sOCTET_STRING__x_es_b_s
 {

660 cڡ *
	mrg
;

661 
	msize
;

662 } 
	gOCTET_STRING__x_es_b
[] = {

663 
	#OSXET
(
s
{ s, (s- 1 }

	)

664 
OSXET
("\074\156\165\154\057\076"),

665 
OSXET
("\074\163\157\150\057\076"),

666 
OSXET
("\074\163\164\170\057\076"),

667 
OSXET
("\074\145\164\170\057\076"),

668 
OSXET
("\074\145\157\164\057\076"),

669 
OSXET
("\074\145\156\161\057\076"),

670 
OSXET
("\074\141\143\153\057\076"),

671 
OSXET
("\074\142\145\154\057\076"),

672 
OSXET
("\074\142\163\057\076"),

673 
OSXET
("\011"),

674 
OSXET
("\012"),

675 
OSXET
("\074\166\164\057\076"),

676 
OSXET
("\074\146\146\057\076"),

677 
OSXET
("\015"),

678 
OSXET
("\074\163\157\057\076"),

679 
OSXET
("\074\163\151\057\076"),

680 
OSXET
("\074\144\154\145\057\076"),

681 
OSXET
("\074\144\143\061\057\076"),

682 
OSXET
("\074\144\143\062\057\076"),

683 
OSXET
("\074\144\143\063\057\076"),

684 
OSXET
("\074\144\143\064\057\076"),

685 
OSXET
("\074\156\141\153\057\076"),

686 
OSXET
("\074\163\171\156\057\076"),

687 
OSXET
("\074\145\164\142\057\076"),

688 
OSXET
("\074\143\141\156\057\076"),

689 
OSXET
("\074\145\155\057\076"),

690 
OSXET
("\074\163\165\142\057\076"),

691 
OSXET
("\074\145\163\143\057\076"),

692 
OSXET
("\074\151\163\064\057\076"),

693 
OSXET
("\074\151\163\063\057\076"),

694 
OSXET
("\074\151\163\062\057\076"),

695 
OSXET
("\074\151\163\061\057\076"),

702 
OSXET
("\046\141\155\160\073"),

707 
OSXET
("\046\154\164\073"),

709 
OSXET
("\046\147\164\073"),

713 
	$OS__check_esd_cڌ_ch
(cڡ *
buf
, 
size
) {

714 
size_t
 
i
;

721 
i
 = 0; i < 32 ; i++) {

722 cڡ 
OCTET_STRING__x_es_b_s
 *

;

723 

 = &
OCTET_STRING__x_es_b
[
i
];

724 if(

->
size
 =siz&& 
	`memcmp
(
buf
,l->
rg
, size) == 0)

725  
i
;

728 
	}
}

731 
	$OCTET_STRING__hd_cڌ_chs
(*
ru_r
, cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

737 
cڌ_ch
 = 
	`OS__check_esd_cڌ_ch
(
chunk_buf
,
chunk_size
);

738 if(
cڌ_ch
 >= 0) {

739 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)
ru_r
;

740 *
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 2);

741 if(
p
) {

742 

->
buf
 = (
ut8_t
 *)
p
;

743 

->
buf
[->
size
++] = 
cڌ_ch
;

744 

->
buf
[->
size
] = '\0';

750 
	}
}

752 
a_c_rv_t


753 
	$OCTET_STRING_code_x_utf8
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

754 
ev
, 
x_cod_ags_e
 
ags
,

755 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

756 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

757 
a_c_rv_t
 

 = { 0, 0, 0 };

758 
ut8_t
 *
buf
, *
d
;

759 
ut8_t
 *
ss
;

760 
ssize_t
 
coded_n
 = 0;

762 ()
ev
;

763 ()
ags
;

765 if(!

 || (!->
buf
 && st->
size
))

766 
ASN__ENCODE_FAILED
;

768 
buf
 = 

->buf;

769 
d
 = 
buf
 + 

->
size
;

770 
ss
 = 
buf
; bu< 
d
; buf++) {

771 
ch
 = *
buf
;

772 
s_n
;

777 if(
ch
 < (
OCTET_STRING__x_es_b
)

778 /(
OCTET_STRING__x_es_b
[0])

779 && (
s_n
 = 
OCTET_STRING__x_es_b
[
ch
].
size
)) {

780 if(((
buf
 - 
ss
&& 
	`cb
(ss, bu- ss, 
p_key
) < 0)

781 || 
	`cb
(
OCTET_STRING__x_es_b
[
ch
].
rg
, 
s_n
,

782 
p_key
) < 0)

783 
ASN__ENCODE_FAILED
;

784 
coded_n
 +(
buf
 - 
ss
+ 
s_n
;

785 
ss
 = 
buf
 + 1;

789 
coded_n
 +(
buf
 - 
ss
);

790 if((
buf
 - 
ss
&& 
	`cb
(ss, bu- ss, 
p_key
) < 0)

791 
ASN__ENCODE_FAILED
;

793 

.
coded
 = 
coded_n
;

794 
	`ASN__ENCODED_OK
(

);

795 
	}
}

800 
ssize_t
 
	$OCTET_STRING__cvt_hexadecim
(*

, cڡ *
chunk_buf
, 
size_t
 
chunk_size
, 
have_me
) {

801 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)

;

802 cڡ *
chunk_
 = (cڡ *)
chunk_buf
;

803 cڡ *
p
 = 
chunk_
;

804 cڡ *
nd
 = 
p
 + 
chunk_size
;

805 
v
 = 0;

806 
hf
 = 0;

807 
ut8_t
 *
buf
;

810 
size_t
 
w_size
 = 

->
size
 + (
chunk_size
 + 1) / 2;

811 *
Ō
 = 
	`REALLOC
(

->
buf
, 
w_size
 + 1);

812 if(!
Ō
)  -1;

813 

->
buf
 = (
ut8_t
 *)
Ō
;

814 
buf
 = 

->bu+ st->
size
;

821 ; 
p
 < 
nd
;++) {

822 
ch
 = *(cڡ *)
p
;

823 
ch
) {

830 
v
 = (v << 4+ (
ch
 - 0x30);

834 
v
 = (v << 4+ (
ch
 - 0x41 + 10);

838 
v
 = (v << 4+ (
ch
 - 0x61 + 10);

841 *
buf
 = 0;

844 if(
hf
++) {

845 
hf
 = 0;

846 *
buf
++ = 
v
;

847 
chunk_
 = 
p
 + 1;

854 if(
hf
) {

855 if(
have_me
) {

860 *
buf
++ = 
v
 << 4;

861 
chunk_
 = 
p
;

864 
chunk_
 = 
p
;

867 

->
size
 = 
buf
 - st->buf;

868 
	`as
(

->
size
 <
w_size
);

869 

->
buf
[->
size
] = 0;

871  (
chunk_
 - (cڡ *)
chunk_buf
);

872 
	}
}

877 
ssize_t
 
	$OCTET_STRING__cvt_by
(*

, cڡ *
chunk_buf
, 
size_t
 
chunk_size
, 
have_me
) {

878 
BIT_STRING_t
 *

 = (BIT_STRING_*)

;

879 cڡ *
p
 = (cڡ *)
chunk_buf
;

880 cڡ *
nd
 = 
p
 + 
chunk_size
;

881 
bs_unud
 = 

->bits_unused & 0x7;

882 
ut8_t
 *
buf
;

885 
size_t
 
w_size
 = 

->
size
 + (
chunk_size
 + 7) / 8;

886 *
Ō
 = 
	`REALLOC
(

->
buf
, 
w_size
 + 1);

887 if(!
Ō
)  -1;

888 

->
buf
 = (
ut8_t
 *)
Ō
;

889 
buf
 = 

->bu+ st->
size
;

891 ()
have_me
;

893 if(
bs_unud
 == 0)

894 
bs_unud
 = 8;

895 if(

->
size
)

896 
buf
--;

901 ; 
p
 < 
nd
;++) {

902 
ch
 = *(cڡ *)
p
;

903 
ch
) {

910 if(
bs_unud
-- <= 0) {

911 *++
buf
 = 0;

912 
bs_unud
 = 7;

914 *
buf
 |(
ch
&1<< 
bs_unud
;

917 

->
bs_unud
 = bits_unused;

922 if(
bs_unud
 == 8) {

923 

->
size
 = 
buf
 - st->buf;

924 

->
bs_unud
 = 0;

926 

->
size
 = 
buf
 - st->buf + 1;

927 

->
bs_unud
 = bits_unused;

930 
	`as
(

->
size
 <
w_size
);

931 

->
buf
[->
size
] = 0;

933  
chunk_size
;

934 
	}
}

940 
	$OS__
(
ba
, cڡ *
buf
, cڡ *
d
, 
t32_t
 *
t_vue
) {

941 cڡ 
t32_t
 
ϡ_unicode_codot
 = 0x10ffff;

942 
t32_t
 
v
 = 0;

943 cڡ *
p
;

945 
p
 = 
buf
; < 
d
;++) {

946 
ch
 = *
p
;

948 
ch
) {

951 
v
 = v * 
ba
 + (
ch
 - 0x30);

955 
v
 = v * 
ba
 + (
ch
 - 0x41 + 10);

959 
v
 = v * 
ba
 + (
ch
 - 0x61 + 10);

962 *
t_vue
 = 
v
;

963  (
p
 - 
buf
) + 1;

969 if(
v
 > 
ϡ_unicode_codot
) {

974 *
t_vue
 = -1;

975  (
p
 - 
buf
);

976 
	}
}

981 
ssize_t


982 
	$OCTET_STRING__cvt_efs
(*

, cڡ *
chunk_buf
,

983 
size_t
 
chunk_size
, 
have_me
) {

984 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)

;

985 cڡ *
p
 = (cڡ *)
chunk_buf
;

986 cڡ *
nd
 = 
p
 + 
chunk_size
;

987 
ut8_t
 *
buf
;

990 
size_t
 
w_size
 = 

->
size
 + 
chunk_size
;

991 *
Ō
 = 
	`REALLOC
(

->
buf
, 
w_size
 + 1);

992 if(!
Ō
)  -1;

993 

->
buf
 = (
ut8_t
 *)
Ō
;

994 
buf
 = 

->bu+ st->
size
;

999 ; 
p
 < 
nd
;++) {

1000 
ch
 = *(cڡ *)
p
;

1001 
n
;

1003 if(
ch
 != 0x26 ) {

1004 *
buf
++ = 
ch
;

1011 
n
 = 
chunk_size
 - (
p
 - (cڡ *)
chunk_buf
);

1012 if(
n
 =1 ) 
wt_me
;

1013 if(
p
[1] == 0x23 ) {

1014 cڡ *
pv
;

1015 
t32_t
 
v
 = 0;

1016 
ba
;

1018 if(
n
 =2 ) 
wt_me
;

1019 if(
p
[2] == 0x78 )

1020 
pv
 = 
p
 + 3, 
ba
 = 16;

1022 
pv
 = 
p
 + 2, 
ba
 = 10;

1023 
n
 = 
	`OS__
(
ba
, 
pv
, 
p
 +, &
v
);

1024 if(
n
 == -1) {

1026 *
buf
++ = 
ch
;

1029 if(!
n
 || 
pv
[n-1] !0x3b
wt_me
;

1030 
	`as
(
v
 > 0);

1031 
p
 +(
pv
 -+ 
n
 - 1;

1033 if(
v
 < 0x80) {

1034 *
buf
++ = ()
v
;

1035 } if(
v
 < 0x800) {

1036 *
buf
++ = 0xc0 | ((
v
 >> 6));

1037 *
buf
++ = 0x80 | ((
v
 & 0x3f));

1038 } if(
v
 < 0x10000) {

1039 *
buf
++ = 0xe0 | ((
v
 >> 12));

1040 *
buf
++ = 0x80 | ((
v
 >> 6) & 0x3f);

1041 *
buf
++ = 0x80 | ((
v
 & 0x3f));

1042 } if(
v
 < 0x200000) {

1043 *
buf
++ = 0xf0 | ((
v
 >> 18));

1044 *
buf
++ = 0x80 | ((
v
 >> 12) & 0x3f);

1045 *
buf
++ = 0x80 | ((
v
 >> 6) & 0x3f);

1046 *
buf
++ = 0x80 | ((
v
 & 0x3f));

1047 } if(
v
 < 0x4000000) {

1048 *
buf
++ = 0xf8 | ((
v
 >> 24));

1049 *
buf
++ = 0x80 | ((
v
 >> 18) & 0x3f);

1050 *
buf
++ = 0x80 | ((
v
 >> 12) & 0x3f);

1051 *
buf
++ = 0x80 | ((
v
 >> 6) & 0x3f);

1052 *
buf
++ = 0x80 | ((
v
 & 0x3f));

1054 *
buf
++ = 0xf| ((
v
 >> 30) & 0x1);

1055 *
buf
++ = 0x80 | ((
v
 >> 24) & 0x3f);

1056 *
buf
++ = 0x80 | ((
v
 >> 18) & 0x3f);

1057 *
buf
++ = 0x80 | ((
v
 >> 12) & 0x3f);

1058 *
buf
++ = 0x80 | ((
v
 >> 6) & 0x3f);

1059 *
buf
++ = 0x80 | ((
v
 & 0x3f));

1065 *
sc
 = (*)
	`memchr
(
p
, 0x3b, 
n
 > 5 ? 5 :en);

1066 if(!
sc

wt_me
;

1067 if((
sc
 - 
p
) == 4

1068 && 
p
[1] == 0x61

1069 && 
p
[2] == 0x6d

1070 && 
p
[3] == 0x70 ) {

1071 *
buf
++ = 0x26;

1072 
p
 = 
sc
;

1075 if((
sc
 - 
p
) == 3) {

1076 if(
p
[1] == 0x6c) {

1077 *
buf
 = 0x3c;

1078 } if(
p
[1] == 0x67) {

1079 *
buf
 = 0x3e;

1082 *
buf
++ = 
ch
;

1085 if(
p
[2] != 0x74) {

1087 *
buf
++ = 
ch
;

1090 
buf
++;

1091 
p
 = 
sc
;

1095 *
buf
++ = 
ch
;

1099 
wt_me
:

1100 if(
have_me
) {

1105 *
buf
++ = 
ch
;

1108 
chunk_size
 = (
p
 - (cڡ *)
chunk_buf
);

1113 

->
size
 = 
buf
 - st->buf;

1114 
	`as
(

->
size
 <
w_size
);

1115 

->
buf
[->
size
] = 0;

1117  
chunk_size
;

1118 
	}
}

1123 
a_dec_rv_t


1124 
	$OCTET_STRING__decode_x
(

1125 cڡ 
a_codec_x_t
 *
t_codec_x
, cڡ 
a_TYPE_dest_t
 *
td
,

1126 **

, cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
,

1127 (*
t_uxed_g_decod
)(*
ru_r
, cڡ *
chunk_buf
,

1128 
size_t
 
chunk_size
),

1129 
	$ssize_t
 (*
body_iv
)(*
ru_r
, cڡ *
chunk_buf
,

1130 
size_t
 
chunk_size
, 
have_me
)) {

1131 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)*

;

1132 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


1133 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


1134 : &
a_SPC_OCTET_STRING_ecs
;

1135 cڡ *
xml_g
 = 
t_mme
 ? o_mm: 
td
->xml_tag;

1136 
a_ru_x_t
 *
x
;

1137 
a_dec_rv_t
 
rv
;

1138 
_lod
;

1143 if(!

) {

1144 

 = (
OCTET_STRING_t
 *)
	`CALLOC
(1, 
ecs
->
ru_size
);

1145 *

 = (*)

;

1146 if(!


a_ed
;

1147 
_lod
 = 1;

1149 
_lod
 = 0;

1151 if(!

->
buf
) {

1153 

->
buf
 = (
ut8_t
 *)
	`CALLOC
(1, 1);

1154 if(!

->
buf
) {

1155 if(
_lod
) {

1156 *

 = 0;

1157 
b_ed
;

1159 
a_ed
;

1165 
x
 = (
a_ru_x_t
 *)(((*)*

+ 
ecs
->
x_offt
);

1167  
	`x_decode_g
(
t_codec_x
, 
x
, *

, 
xml_g
,

1168 
buf_r
, 
size
, 
t_uxed_g_decod
, 
body_iv
);

1170 
b_ed
:

1171 
	`FREEMEM
(

);

1172 
a_ed
:

1173 
rv
.
code
 = 
RC_FAIL
;

1174 
rv
.
csumed
 = 0;

1175  
rv
;

1176 
	}
}

1181 
a_dec_rv_t


1182 
	$OCTET_STRING_decode_x_hex
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1183 cڡ 
a_TYPE_dest_t
 *
td
, **

,

1184 cڡ *
t_mme
, cڡ *
buf_r
,

1185 
size_t
 
size
) {

1186  
	`OCTET_STRING__decode_x
(
t_codec_x
, 
td
, 

, 
t_mme
,

1187 
buf_r
, 
size
, 0, 
OCTET_STRING__cvt_hexadecim
);

1188 
	}
}

1193 
a_dec_rv_t


1194 
	$OCTET_STRING_decode_x_by
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1195 cڡ 
a_TYPE_dest_t
 *
td
, **

,

1196 cڡ *
t_mme
, cڡ *
buf_r
,

1197 
size_t
 
size
) {

1198  
	`OCTET_STRING__decode_x
(
t_codec_x
, 
td
, 

, 
t_mme
,

1199 
buf_r
, 
size
, 0, 
OCTET_STRING__cvt_by
);

1200 
	}
}

1205 
a_dec_rv_t


1206 
	$OCTET_STRING_decode_x_utf8
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1207 cڡ 
a_TYPE_dest_t
 *
td
, **

,

1208 cڡ *
t_mme
, cڡ *
buf_r
,

1209 
size_t
 
size
) {

1210  
	`OCTET_STRING__decode_x
(
t_codec_x
, 
td
, 

, 
t_mme
,

1211 
buf_r
, 
size
,

1212 
OCTET_STRING__hd_cڌ_chs
,

1213 
OCTET_STRING__cvt_efs
);

1214 
	}
}

1216 #ide 
ASN_DISABLE_PER_SUPPORT


1219 
	$OCTET_STRING_r_g_chas
(
a_r_da_t
 *
po
, 
ut8_t
 *
buf
,

1220 
size_t
 
uns
, 
bpc
, 
un_bs
,

1221 
lb
, 
ub
, cڡ 
a_r_cڡts_t
 *
pc
) {

1222 
ut8_t
 *
d
 = 
buf
 + 
uns
 * 
bpc
;

1224 
	`ASN_DEBUG
("Expanding %d characters into (%ld..%ld):%d",

1225 ()
uns
, 
lb
, 
ub
, 
un_bs
);

1228 if(()
ub
 <(()2 << (
un_bs
 - 1))) {

1230 
lb
 = 0;

1231 } if(
pc
 &&c->
code2vue
) {

1232 if(
un_bs
 > 16)

1236 ; 
buf
 < 
d
; bu+
bpc
) {

1237 
vue
;

1238 
code
 = 
	`r_g_w_bs
(
po
, 
un_bs
);

1239 if(
code
 < 0)  -1;

1240 
vue
 = 
pc
->
	`code2vue
(
code
);

1241 if(
vue
 < 0) {

1242 
	`ASN_DEBUG
("Code %d (0x%02x) is"

1244 
code
, code, 
lb
, 
ub
);

1247 
bpc
) {

1248 1: *
buf
 = 
vue
; ;

1249 2: 
buf
[0] = 
vue
 >> 8; buf[1] = value; ;

1250 4: 
buf
[0] = 
vue
 >> 24; buf[1] = value >> 16;

1251 
buf
[2] = 
vue
 >> 8; buf[3] = value; ;

1258 if(
lb
 =0 && (
un_bs
 =8 * 
bpc
)) {

1259  
	`r_g_my_bs
(
po
, 
buf
, 0, 
un_bs
 * 
uns
);

1262 ; 
buf
 < 
d
; bu+
bpc
) {

1263 
t32_t
 
code
 = 
	`r_g_w_bs
(
po
, 
un_bs
);

1264 
t32_t
 
ch
 = 
code
 + 
lb
;

1265 if(
code
 < 0)  -1;

1266 if(
ch
 > 
ub
) {

1267 
	`ASN_DEBUG
("Code %d is out ofange (%ld..%ld)",

1268 
ch
, 
lb
, 
ub
);

1271 
bpc
) {

1272 1: *
buf
 = 
ch
; ;

1273 2: 
buf
[0] = 
ch
 >> 8; buf[1] = ch; ;

1274 4: 
buf
[0] = 
ch
 >> 24; buf[1] = ch >> 16;

1275 
buf
[2] = 
ch
 >> 8; buf[3] = ch; ;

1280 
	}
}

1283 
	$OCTET_STRING_r_put_chas
(
a_r_ou_t
 *
po
, cڡ 
ut8_t
 *
buf
,

1284 
size_t
 
uns
, 
bpc
, 
un_bs
,

1285 
lb
, 
ub
, cڡ 
a_r_cڡts_t
 *
pc
) {

1286 cڡ 
ut8_t
 *
d
 = 
buf
 + 
uns
 * 
bpc
;

1288 
	`ASN_DEBUG
("Squeezing %d characters into (%ld..%ld):%d (%d bpc)",

1289 ()
uns
, 
lb
, 
ub
, 
un_bs
, 
bpc
);

1292 if(()
ub
 <(()2 << (
un_bs
 - 1))) {

1294 
lb
 = 0;

1295 } if(
pc
 &&c->
vue2code
) {

1296 ; 
buf
 < 
d
; bu+
bpc
) {

1297 
code
;

1298 
ut32_t
 
vue
;

1299 
bpc
) {

1300 1: 
vue
 = *(cڡ 
ut8_t
 *)
buf
; ;

1301 2: 
vue
 = (
buf
[0] << 8) | buf[1]; ;

1302 4: 
vue
 = (
buf
[0] << 24) | (buf[1] << 16)

1303 | (
buf
[2] << 8) | buf[3]; ;

1306 
code
 = 
pc
->
	`vue2code
(
vue
);

1307 if(
code
 < 0) {

1308 
	`ASN_DEBUG
("Character %d (0x%02x) is"

1310 *
buf
, *buf, 
lb
, 
ub
);

1313 if(
	`r_put_w_bs
(
po
, 
code
, 
un_bs
))

1319 if(
lb
 =0 && (
un_bs
 =8 * 
bpc
)) {

1320  
	`r_put_my_bs
(
po
, 
buf
, 
un_bs
 * 
uns
);

1323 
ub
 -
lb
; 
buf
 < 
d
; bu+
bpc
) {

1324 
ch
;

1325 
ut32_t
 
vue
;

1326 
bpc
) {

1328 
vue
 = *(cڡ 
ut8_t
 *)
buf
;

1331 
vue
 = (
buf
[0] << 8) | buf[1];

1334 
vue
 = (
buf
[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];

1339 
ch
 = 
vue
 - 
lb
;

1340 if(
ch
 < 0 || ch > 
ub
) {

1341 
	`ASN_DEBUG
("Cha %d (0x%02xiouong(%ld..%ld)", *
buf
,

1342 
vue
, 
lb
, 
ub
 +b);

1345 if(
	`r_put_w_bs
(
po
, 
ch
, 
un_bs
))  -1;

1349 
	}
}

1351 
a_r_cڡts_t
 
	ga_DEF_OCTET_STRING_cڡts
 = {

1352 { 
APC_CONSTRAINED
, 8, 8, 0, 255 },

1353 { 
APC_SEMI_CONSTRAINED
, -1, -1, 0, 0 },

1357 
a_dec_rv_t


1358 
	$OCTET_STRING_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1359 cڡ 
a_TYPE_dest_t
 *
td
,

1360 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

1361 
a_r_da_t
 *
pd
) {

1362 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


1363 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


1364 : &
a_SPC_OCTET_STRING_ecs
;

1365 cڡ 
a_r_cڡts_t
 *
pc
 =

1366 
cڡts
 ? cڡt: 
td
->
codg_cڡts
.
r_cڡts
;

1367 cڡ 
a_r_cڡt_t
 *
cv
;

1368 cڡ 
a_r_cڡt_t
 *
csiz
;

1369 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

1370 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)*

;

1371 
ssize_t
 
csumed_mylf
 = 0;

1372 

;

1374 
OS__BPC_CHAR
 = 1,

1375 
OS__BPC_U16
 = 2,

1376 
OS__BPC_U32
 = 4

1377 } 
bpc
;

1378 
un_bs
;

1379 
nil_un_bs
;

1381 ()
t_codec_x
;

1383 if(
pc
) {

1384 
cv
 = &
pc
->
vue
;

1385 
csiz
 = &
pc
->
size
;

1387 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1388 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1391 
ecs
->
subv
) {

1393 
ASN_OSUBV_ANY
:

1394 
ASN_OSUBV_BIT
:

1395 
	`ASN_DEBUG
("Uecognized subv %d", 
ecs
->
subv
);

1396 
	`RETURN
(
RC_FAIL
);

1398 
ASN_OSUBV_STR
:

1399 
nil_un_bs
 = 
un_bs
 = 8;

1400 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1401 
un_bs
 = 
cv
->
nge_bs
;

1402 
bpc
 = 
OS__BPC_CHAR
;

1404 
ASN_OSUBV_U16
:

1405 
nil_un_bs
 = 
un_bs
 = 16;

1406 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1407 
un_bs
 = 
cv
->
nge_bs
;

1408 
bpc
 = 
OS__BPC_U16
;

1410 
ASN_OSUBV_U32
:

1411 
nil_un_bs
 = 
un_bs
 = 32;

1412 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1413 
un_bs
 = 
cv
->
nge_bs
;

1414 
bpc
 = 
OS__BPC_U32
;

1421 if(!

) {

1422 

 = (
OCTET_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

1423 if(!


	`RETURN
(
RC_FAIL
);

1426 
	`ASN_DEBUG
("PER Decoding %s size %ld .. %ld bits %d",

1427 
csiz
->
ags
 & 
APC_EXTENSIBLE
 ? "extensible" : "non-extensible",

1428 
csiz
->
low_bound
, csiz->
u_bound
, csiz->
efive_bs
);

1430 if(
csiz
->
ags
 & 
APC_EXTENSIBLE
) {

1431 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

1432 if(
ext
 < 0
	`RETURN
(
RC_WMORE
);

1433 if(
ext
) {

1434 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1435 
un_bs
 = 
nil_un_bs
;

1439 if(
csiz
->
efive_bs
 >= 0) {

1440 
	`FREEMEM
(

->
buf
);

1441 if(
bpc
) {

1442 

->
size
 = 
csiz
->
u_bound
 * 
bpc
;

1444 

->
size
 = (
csiz
->
u_bound
 + 7) >> 3;

1446 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(->
size
 + 1);

1447 if(!

->
buf
{ st->
size
 = 0; 
	`RETURN
(
RC_FAIL
); }

1453 if(
csiz
->
efive_bs
 == 0) {

1454 
t
;

1455 if(
bpc
) {

1456 
	`ASN_DEBUG
("Encoding OCTET STRING size %ld",

1457 
csiz
->
u_bound
);

1458 
t
 = 
	`OCTET_STRING_r_g_chas
(
pd
, 

->
buf
,

1459 
csiz
->
u_bound
, 
bpc
, 
un_bs
,

1460 
cv
->
low_bound
, cv->
u_bound
, 
pc
);

1461 if(
t
 > 0
	`RETURN
(
RC_FAIL
);

1463 
	`ASN_DEBUG
("Encoding BIT STRING size %ld",

1464 
csiz
->
u_bound
);

1465 
t
 = 
	`r_g_my_bs
(
pd
, 

->
buf
, 0,

1466 
un_bs
 * 
csiz
->
u_bound
);

1468 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

1469 
csumed_mylf
 +
un_bs
 * 
csiz
->
u_bound
;

1470 

->
buf
[->
size
] = 0;

1471 
	`RETURN
(
RC_OK
);

1474 

->
size
 = 0;

1476 
ssize_t
 
w_n
;

1477 
ssize_t
 
n_bys
;

1478 *
p
;

1479 
t
;

1482 
w_n
 = 
	`ur_g_ngth
(
pd
, 
csiz
->
efive_bs
, csiz->
low_bound
,

1483 &

);

1484 if(
w_n
 < 0
	`RETURN
(
RC_WMORE
);

1485 if(
w_n
 =0 && 

->
buf
) ;

1487 
	`ASN_DEBUG
("Got PERengthb %ld,en %ld, %s (%s)",

1488 ()
csiz
->
efive_bs
, ()
w_n
,

1489 

 ? "" : "", 
td
->
me
);

1490 
n_bys
 = 
w_n
 * 
bpc
;

1491 
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 
n_bys
 + 1);

1492 if(!
p

	`RETURN
(
RC_FAIL
);

1493 

->
buf
 = (
ut8_t
 *)
p
;

1495 
t
 = 
	`OCTET_STRING_r_g_chas
(
pd
, &

->
buf
[->
size
], 
w_n
,

1496 
bpc
, 
un_bs
, 
cv
->
low_bound
,

1497 
cv
->
u_bound
, 
pc
);

1498 if(
t
 > 0
	`RETURN
(
RC_FAIL
);

1499 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

1500 

->
size
 +
n_bys
;

1501 } 

);

1502 

->
buf
[->
size
] = 0;

1504  
rv
;

1505 
	}
}

1507 
a_c_rv_t


1508 
	$OCTET_STRING_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

1509 cڡ 
a_r_cڡts_t
 *
cڡts
,

1510 cڡ *

, 
a_r_ou_t
 *
po
) {

1511 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


1512 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


1513 : &
a_SPC_OCTET_STRING_ecs
;

1514 cڡ 
a_r_cڡts_t
 *
pc
 = 
cڡts
 ? constraints

1515 : 
td
->
codg_cڡts
.
r_cڡts
;

1516 cڡ 
a_r_cڡt_t
 *
cv
;

1517 cڡ 
a_r_cڡt_t
 *
csiz
;

1518 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

1519 
a_c_rv_t
 

 = { 0, 0, 0 };

1520 
ext
 = 0;

1521 
un_bs
;

1522 
nil_un_bs
;

1523 
size_t
 
size__uns
;

1524 cڡ 
ut8_t
 *
buf
;

1525 
t
;

1527 
OS__BPC_CHAR
 = 1,

1528 
OS__BPC_U16
 = 2,

1529 
OS__BPC_U32
 = 4

1530 } 
bpc
;

1531 
_exnsib
;

1533 if(!

 || (!->
buf
 && st->
size
))

1534 
ASN__ENCODE_FAILED
;

1536 if(
pc
) {

1537 
cv
 = &
pc
->
vue
;

1538 
csiz
 = &
pc
->
size
;

1540 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1541 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1543 
_exnsib
 = 
csiz
->
ags
 & 
APC_EXTENSIBLE
;

1545 
ecs
->
subv
) {

1547 
ASN_OSUBV_ANY
:

1548 
ASN_OSUBV_BIT
:

1549 
ASN__ENCODE_FAILED
;

1550 
ASN_OSUBV_STR
:

1551 
nil_un_bs
 = 
un_bs
 = 8;

1552 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1553 
un_bs
 = 
cv
->
nge_bs
;

1554 
bpc
 = 
OS__BPC_CHAR
;

1555 
size__uns
 = 

->
size
;

1557 
ASN_OSUBV_U16
:

1558 
nil_un_bs
 = 
un_bs
 = 16;

1559 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1560 
un_bs
 = 
cv
->
nge_bs
;

1561 
bpc
 = 
OS__BPC_U16
;

1562 
size__uns
 = 

->
size
 >> 1;

1563 if(

->
size
 & 1) {

1564 
	`ASN_DEBUG
("%rg sizin modul2", 
td
->
me
);

1565 
ASN__ENCODE_FAILED
;

1568 
ASN_OSUBV_U32
:

1569 
nil_un_bs
 = 
un_bs
 = 32;

1570 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1571 
un_bs
 = 
cv
->
nge_bs
;

1572 
bpc
 = 
OS__BPC_U32
;

1573 
size__uns
 = 

->
size
 >> 2;

1574 if(

->
size
 & 3) {

1575 
	`ASN_DEBUG
("%rg sizin modul4", 
td
->
me
);

1576 
ASN__ENCODE_FAILED
;

1581 
	`ASN_DEBUG
("Encodg %t%" 
ASN_PRI_SIZE
 " units of %d bits"

1583 
td
->
me
, 
size__uns
, 
un_bs
,

1584 
csiz
->
low_bound
, csiz->
u_bound
,

1585 
csiz
->
efive_bs
, 
_exnsib
 ? " EXT" : "");

1589 if(
csiz
->
efive_bs
 >= 0) {

1590 if((
ssize_t
)
size__uns
 < 
csiz
->
low_bound


1591 || (
ssize_t
)
size__uns
 > 
csiz
->
u_bound
) {

1592 if(
_exnsib
) {

1593 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1594 
un_bs
 = 
nil_un_bs
;

1595 
ext
 = 1;

1597 
ASN__ENCODE_FAILED
;

1601 
ext
 = 0;

1604 if(
_exnsib
) {

1606 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

1607 
ASN__ENCODE_FAILED
;

1610 if(
csiz
->
efive_bs
 >0 && !
ext
) {

1611 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SIZE
 " by(%ld),gth i%d bs", 

->
size
,

1612 
size__uns
 - 
csiz
->
low_bound
, csiz->
efive_bs
);

1613 
t
 = 
	`r_put_w_bs
(
po
, 
size__uns
 - 
csiz
->
low_bound
,

1614 
csiz
->
efive_bs
);

1615 if(
t

ASN__ENCODE_FAILED
;

1616 
t
 = 
	`OCTET_STRING_r_put_chas
(
po
, 

->
buf
, 
size__uns
, 
bpc
,

1617 
un_bs
, 
cv
->
low_bound
,

1618 
cv
->
u_bound
, 
pc
);

1619 if(
t

ASN__ENCODE_FAILED
;

1620 
	`ASN__ENCODED_OK
(

);

1623 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SIZE
 " bys", 

->
size
);

1625 
buf
 = 

->buf;

1626 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SIZE
 " iuns", 
size__uns
);

1628 
ed_eom
 = 0;

1629 
ssize_t
 
may_ve
 = 
	`ur_put_ngth
(
po
, 
size__uns
, &
ed_eom
);

1630 if(
may_ve
 < 0
ASN__ENCODE_FAILED
;

1632 
	`ASN_DEBUG
("Encodg %" 
ASN_PRI_SSIZE
 " o%" 
ASN_PRI_SIZE
 "%s", 
may_ve
, 
size__uns
,

1633 
ed_eom
 ? ",+EOM" : "");

1635 
t
 = 
	`OCTET_STRING_r_put_chas
(
po
, 
buf
, 
may_ve
, 
bpc
, 
un_bs
,

1636 
cv
->
low_bound
,

1637 
cv
->
u_bound
, 
pc
);

1638 if(
t

ASN__ENCODE_FAILED
;

1640 
buf
 +
may_ve
 * 
bpc
;

1641 
size__uns
 -
may_ve
;

1642 
	`as
(!(
may_ve
 & 0x07|| !
size__uns
);

1643 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0))

1644 
ASN__ENCODE_FAILED
;

1645 } 
size__uns
);

1647 
	`ASN__ENCODED_OK
(

);

1648 
	}
}

1650 
a_dec_rv_t


1651 
	$OCTET_STRING_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1652 cڡ 
a_TYPE_dest_t
 *
td
,

1653 cڡ 
a_r_cڡts_t
 *
cڡts
,

1654 **

, 
a_r_da_t
 *
pd
) {

1656 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


1657 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


1658 : &
a_SPC_OCTET_STRING_ecs
;

1659 cڡ 
a_r_cڡts_t
 *
pc
 = 
cڡts
 ? constraints

1660 : 
td
->
codg_cڡts
.
r_cڡts
;

1661 cڡ 
a_r_cڡt_t
 *
cv
;

1662 cڡ 
a_r_cڡt_t
 *
csiz
;

1663 
a_dec_rv_t
 
rv
 = { 
RC_OK
, 0 };

1664 
BIT_STRING_t
 *

 = (BIT_STRING_*)*

;

1665 
ssize_t
 
csumed_mylf
 = 0;

1666 

;

1668 
OS__BPC_BIT
 = 0,

1669 
OS__BPC_CHAR
 = 1,

1670 
OS__BPC_U16
 = 2,

1671 
OS__BPC_U32
 = 4

1672 } 
bpc
;

1673 
un_bs
;

1674 
nil_un_bs
;

1676 ()
t_codec_x
;

1678 if(
pc
) {

1679 
cv
 = &
pc
->
vue
;

1680 
csiz
 = &
pc
->
size
;

1682 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1683 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1686 
ecs
->
subv
) {

1692 
ASN_OSUBV_BIT
:

1693 
nil_un_bs
 = 
un_bs
 = 1;

1694 
bpc
 = 
OS__BPC_BIT
;

1696 
ASN_OSUBV_ANY
:

1697 
ASN_OSUBV_STR
:

1698 
nil_un_bs
 = 
un_bs
 = 8;

1702 
bpc
 = 
OS__BPC_CHAR
;

1704 
ASN_OSUBV_U16
:

1705 
nil_un_bs
 = 
un_bs
 = 16;

1706 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1707 
un_bs
 = 
cv
->
nge_bs
;

1708 
bpc
 = 
OS__BPC_U16
;

1710 
ASN_OSUBV_U32
:

1711 
nil_un_bs
 = 
un_bs
 = 32;

1712 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1713 
un_bs
 = 
cv
->
nge_bs
;

1714 
bpc
 = 
OS__BPC_U32
;

1721 if(!

) {

1722 

 = (
BIT_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

1723 if(!


	`RETURN
(
RC_FAIL
);

1726 
	`ASN_DEBUG
("PER Decoding %s size %ld .. %ld bits %d",

1727 
csiz
->
ags
 & 
APC_EXTENSIBLE
 ? "extensible" : "non-extensible",

1728 
csiz
->
low_bound
, csiz->
u_bound
, csiz->
efive_bs
);

1730 if(
csiz
->
ags
 & 
APC_EXTENSIBLE
) {

1731 
ext
 = 
	`r_g_w_bs
(
pd
, 1);

1732 if(
ext
 < 0
	`RETURN
(
RC_WMORE
);

1733 if(
ext
) {

1734 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1735 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1736 
un_bs
 = 
nil_un_bs
;

1740 if(
csiz
->
efive_bs
 >= 0) {

1741 
	`FREEMEM
(

->
buf
);

1742 if(
bpc
) {

1743 

->
size
 = 
csiz
->
u_bound
 * 
bpc
;

1745 

->
size
 = (
csiz
->
u_bound
 + 7) >> 3;

1747 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(->
size
 + 1);

1748 if(!

->
buf
{ st->
size
 = 0; 
	`RETURN
(
RC_FAIL
); }

1754 if(
csiz
->
efive_bs
 == 0) {

1755 
t
;

1756 i(

->
size
 > 2) {

1757 i(
	`_g_ign
(
pd
) < 0)

1758 
	`RETURN
(
RC_FAIL
);

1760 if(
bpc
) {

1761 
	`ASN_DEBUG
("Decoding OCTET STRING size %ld",

1762 
csiz
->
u_bound
);

1763 
t
 = 
	`OCTET_STRING_r_g_chas
(
pd
, 

->
buf
,

1764 
csiz
->
u_bound
, 
bpc
, 
un_bs
,

1765 
cv
->
low_bound
, cv->
u_bound
, 
pc
);

1766 if(
t
 > 0
	`RETURN
(
RC_FAIL
);

1768 
	`ASN_DEBUG
("Decoding BIT STRING size %ld",

1769 
csiz
->
u_bound
);

1770 
t
 = 
	`r_g_my_bs
(
pd
, 

->
buf
, 0,

1771 
un_bs
 * 
csiz
->
u_bound
);

1773 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

1774 
csumed_mylf
 +
un_bs
 * 
csiz
->
u_bound
;

1775 

->
buf
[->
size
] = 0;

1776 if(
bpc
 == 0) {

1777 
ubs
 = (
csiz
->
u_bound
 & 0x7);

1778 

->
bs_unud
 = 
ubs
 ? 8 - ubs : 0;

1780 
	`RETURN
(
RC_OK
);

1783 

->
size
 = 0;

1785 
ssize_t
 
w_n
;

1786 
ssize_t
 
n_bys
;

1787 
ssize_t
 
n_bs
;

1788 *
p
;

1789 
t
;

1792 i(
csiz
->
u_bound
 - csiz->
low_bound
 == 0)

1794 
w_n
 = 
	`_g_ngth
(
pd
, -1, 
csiz
->
efive_bs
, &

);

1796 
w_n
 = 
	`_g_ngth
(
pd
, 
csiz
->
u_bound
 - csiz->
low_bound
 + 1, csiz->
efive_bs
, &

);

1797 

 = 0;

1798 if(
w_n
 < 0
	`RETURN
(
RC_WMORE
);

1799 
w_n
 +
csiz
->
low_bound
;

1801 
	`ASN_DEBUG
("Got PERengthb %ld,en %ld, %s (%s)",

1802 ()
csiz
->
efive_bs
, ()
w_n
,

1803 

 ? "" : "", 
td
->
me
);

1805 i(
w_n
 > 2) {

1806 i(
	`_g_ign
(
pd
) < 0)

1807 
	`RETURN
(
RC_FAIL
);

1810 if(
bpc
) {

1811 
n_bys
 = 
w_n
 * 
bpc
;

1812 
n_bs
 = 
n_bys
 * 
un_bs
;

1814 
n_bs
 = 
w_n
;

1815 
n_bys
 = (
n_bs
 + 7) >> 3;

1816 if(
n_bs
 & 0x7)

1817 

->
bs_unud
 = 8 - (
n_bs
 & 0x7);

1820 
p
 = 
	`REALLOC
(

->
buf
, st->
size
 + 
n_bys
 + 1);

1821 if(!
p

	`RETURN
(
RC_FAIL
);

1822 

->
buf
 = (
ut8_t
 *)
p
;

1824 if(
bpc
) {

1825 
t
 = 
	`OCTET_STRING_r_g_chas
(
pd
,

1826 &

->
buf
[->
size
], 
w_n
, 
bpc
, 
un_bs
,

1827 
cv
->
low_bound
, cv->
u_bound
, 
pc
);

1828 if(
t
 > 0
	`RETURN
(
RC_FAIL
);

1830 
t
 = 
	`r_g_my_bs
(
pd
, &

->
buf
[->
size
],

1831 0, 
n_bs
);

1833 if(
t
 < 0
	`RETURN
(
RC_WMORE
);

1834 

->
size
 +
n_bys
;

1835 } 

);

1836 

->
buf
[->
size
] = 0;

1838  
rv
;

1839 
	}
}

1841 
a_c_rv_t


1842 
	$OCTET_STRING_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

1843 cڡ 
a_r_cڡts_t
 *
cڡts
,

1844 cڡ *

, 
a_r_ou_t
 *
po
) {

1846 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


1847 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


1848 : &
a_SPC_OCTET_STRING_ecs
;

1849 cڡ 
a_r_cڡts_t
 *
pc
 = 
cڡts
 ? constraints

1850 : 
td
->
codg_cڡts
.
r_cڡts
;

1851 cڡ 
a_r_cڡt_t
 *
cv
;

1852 cڡ 
a_r_cڡt_t
 *
csiz
;

1853 cڡ 
BIT_STRING_t
 *

 = (cڡ BIT_STRING_*)

;

1854 
a_c_rv_t
 

 = { 0, 0, 0 };

1855 
ext
 = 0;

1856 
un_bs
;

1857 
nil_un_bs
;

1858 
sizeuns
;

1859 cڡ 
ut8_t
 *
buf
;

1860 
t
;

1862 
OS__BPC_BIT
 = 0,

1863 
OS__BPC_CHAR
 = 1,

1864 
OS__BPC_U16
 = 2,

1865 
OS__BPC_U32
 = 4

1866 } 
bpc
;

1867 
_exnsib
;

1869 if(!

 || (!->
buf
 && st->
size
))

1870 
ASN__ENCODE_FAILED
;

1872 if(
pc
) {

1873 
cv
 = &
pc
->
vue
;

1874 
csiz
 = &
pc
->
size
;

1876 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1877 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1879 
_exnsib
 = 
csiz
->
ags
 & 
APC_EXTENSIBLE
;

1881 
ecs
->
subv
) {

1886 
ASN_OSUBV_BIT
:

1887 
nil_un_bs
 = 
un_bs
 = 1;

1888 
bpc
 = 
OS__BPC_BIT
;

1889 
sizeuns
 = 

->
size
 * 8 - (->
bs_unud
 & 0x07);

1890 
	`ASN_DEBUG
("BIT STRING of %d bytes",

1891 
sizeuns
);

1893 
ASN_OSUBV_ANY
:

1894 
ASN_OSUBV_STR
:

1895 
nil_un_bs
 = 
un_bs
 = 8;

1899 
bpc
 = 
OS__BPC_CHAR
;

1900 
sizeuns
 = 

->
size
;

1902 
ASN_OSUBV_U16
:

1903 
nil_un_bs
 = 
un_bs
 = 16;

1904 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1905 
un_bs
 = 
cv
->
nge_bs
;

1906 
bpc
 = 
OS__BPC_U16
;

1907 
sizeuns
 = 

->
size
 / 2;

1909 
ASN_OSUBV_U32
:

1910 
nil_un_bs
 = 
un_bs
 = 32;

1911 if(
cv
->
ags
 & 
APC_CONSTRAINED
)

1912 
un_bs
 = 
cv
->
nge_bs
;

1913 
bpc
 = 
OS__BPC_U32
;

1914 
sizeuns
 = 

->
size
 / 4;

1918 
	`ASN_DEBUG
("Encoding %s into %d units of %d bits"

1920 
td
->
me
, 
sizeuns
, 
un_bs
,

1921 
csiz
->
low_bound
, csiz->
u_bound
,

1922 
csiz
->
efive_bs
, 
_exnsib
 ? " EXT" : "");

1926 if(
csiz
->
efive_bs
 >= 0) {

1927 if(()
sizeuns
 < 
csiz
->
low_bound


1928 || ()
sizeuns
 > 
csiz
->
u_bound
) {

1929 if(
_exnsib
) {

1930 
cv
 = &
a_DEF_OCTET_STRING_cڡts
.
vue
;

1931 
csiz
 = &
a_DEF_OCTET_STRING_cڡts
.
size
;

1932 
un_bs
 = 
nil_un_bs
;

1933 
ext
 = 1;

1935 
ASN__ENCODE_FAILED
;

1938 
ext
 = 0;

1942 if(
_exnsib
) {

1944 if(
	`r_put_w_bs
(
po
, 
ext
, 1))

1945 
ASN__ENCODE_FAILED
;

1951 if(
csiz
->
efive_bs
 >= 0) {

1952 
	`ASN_DEBUG
("Encoding %lu bytes (%ld),ength in %d bits",

1953 

->
size
, 
sizeuns
 - 
csiz
->
low_bound
,

1954 
csiz
->
efive_bs
);

1955 i(
csiz
->
efive_bs
 > 0) {

1956 
t
 = 
	`_put_ngth
(
po
, 
csiz
->
u_bound
 - csiz->
low_bound
 + 1, 
sizeuns
 - csiz->lower_bound);

1957 if(
t

ASN__ENCODE_FAILED
;

1961 i((

->
size
 > 2|| (
csiz
->
low_bound
 !csiz->
u_bound
)) {

1962 i(
	`_put_ign
(
po
) < 0)

1963 
ASN__ENCODE_FAILED
;

1965 if(
bpc
) {

1966 
t
 = 
	`OCTET_STRING_r_put_chas
(
po
, 

->
buf
,

1967 
sizeuns
, 
bpc
, 
un_bs
,

1968 
cv
->
low_bound
, cv->
u_bound
, 
pc
);

1970 
t
 = 
	`r_put_my_bs
(
po
, 

->
buf
,

1971 
sizeuns
 * 
un_bs
);

1973 if(
t

ASN__ENCODE_FAILED
;

1974 
	`ASN__ENCODED_OK
(

);

1977 
	`ASN_DEBUG
("Encodg %lu bys", 

->
size
);

1979 if(
sizeuns
 == 0) {

1980 if(
	`_put_ngth
(
po
, -1, 0))

1981 
ASN__ENCODE_FAILED
;

1982 
	`ASN__ENCODED_OK
(

);

1985 
buf
 = 

->buf;

1986 
sizeuns
) {

1987 
ssize_t
 
maySave
 = 
	`_put_ngth
(
po
, -1, 
sizeuns
);

1989 if(
maySave
 < 0
ASN__ENCODE_FAILED
;

1991 
	`ASN_DEBUG
("Encoding %ld of %ld",

1992 ()
maySave
, ()
sizeuns
);

1994 if(
bpc
) {

1995 
t
 = 
	`OCTET_STRING_r_put_chas
(
po
, 
buf
,

1996 
maySave
, 
bpc
, 
un_bs
,

1997 
cv
->
low_bound
, cv->
u_bound
, 
pc
);

1999 
t
 = 
	`r_put_my_bs
(
po
, 
buf
, 
maySave
 * 
un_bs
);

2001 if(
t

ASN__ENCODE_FAILED
;

2003 if(
bpc
)

2004 
buf
 +
maySave
 * 
bpc
;

2006 
buf
 +
maySave
 >> 3;

2007 
sizeuns
 -
maySave
;

2008 
	`as
(!(
maySave
 & 0x07|| !
sizeuns
);

2011 
	`ASN__ENCODED_OK
(

);

2012 
	}
}

2017 
	$OCTET_STRING_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

2018 
ev
, 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

2019 cڡ * cڡ 
h2c
 = "0123456789ABCDEF";

2020 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

2021 
sch
[16 * 3 + 4];

2022 *
p
 = 
sch
;

2023 
ut8_t
 *
buf
;

2024 
ut8_t
 *
d
;

2025 
size_t
 
i
;

2027 ()
td
;

2029 if(!

 || (!->
buf
 && st->
size
))

2030  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

2035 
buf
 = 

->buf;

2036 
d
 = 
buf
 + 

->
size
;

2037 
i
 = 0; 
buf
 < 
d
; buf++, i++) {

2038 if(!(
i
 % 16&& (|| 

->
size
 > 16)) {

2039 if(
	`cb
(
sch
, 
p
 - sch, 
p_key
) < 0)

2041 
	`_i_INDENT
(1);

2042 
p
 = 
sch
;

2044 *
p
++ = 
h2c
[(*
buf
 >> 4) & 0x0F];

2045 *
p
++ = 
h2c
[*
buf
 & 0x0F];

2046 *
p
++ = 0x20;

2049 if(
p
 > 
sch
) {

2050 
p
--;

2051 if(
	`cb
(
sch
, 
p
 - sch, 
p_key
) < 0)

2056 
	}
}

2059 
	$OCTET_STRING_t_utf8
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

2060 
ev
, 
a_p_csume_bys_f
 *
cb
,

2061 *
p_key
) {

2062 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

2064 ()
td
;

2065 ()
ev
;

2067 if(

 && (->
buf
 || !->
size
)) {

2068  (
	`cb
(

->
buf
, st->
size
, 
p_key
) < 0) ? -1 : 0;

2070  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

2072 
	}
}

2075 
	$OCTET_STRING_
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

2076 
a_ru__mhod
 
mhod
) {

2077 
OCTET_STRING_t
 *

 = (OCTET_STRING_*)

;

2078 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
;

2079 
a_ru_x_t
 *
x
;

2080 
_ack
 *
ck
;

2082 if(!
td
 || !

)

2085 
ecs
 = 
td
->
ecifics


2086 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


2087 : &
a_SPC_OCTET_STRING_ecs
;

2088 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

2090 
	`ASN_DEBUG
("Feg %aOCTET STRING", 
td
->
me
);

2092 if(

->
buf
) {

2093 
	`FREEMEM
(

->
buf
);

2094 

->
buf
 = 0;

2100 
ck
 = (
_ack
 *)
x
->
r
;

2101 if(
ck
) {

2102 
ck
->

) {

2103 
_ack_
 *
l
 = 
ck
->

;

2104 
ck
->

 = 
l
->
ev
;

2105 
	`FREEMEM
(
l
);

2107 
	`FREEMEM
(
ck
);

2110 
mhod
) {

2111 
ASFM_FREE_EVERYTHING
:

2112 
	`FREEMEM
(

);

2114 
ASFM_FREE_UNDERLYING
:

2116 
ASFM_FREE_UNDERLYING_AND_RESET
:

2117 
	`memt
(

, 0,

2118 
td
->
ecifics


2119 ? ((cڡ 
a_OCTET_STRING_ecifics_t
 *)(
td
->
ecifics
))

2120 ->
ru_size


2121 : (
OCTET_STRING_t
));

2124 
	}
}

2130 
	$OCTET_STRING_omBuf
(
OCTET_STRING_t
 *

, cڡ *
r
, 
n
) {

2131 *
buf
;

2133 if(

 =0 || (
r
 =0 && 
n
)) {

2134 
o
 = 
EINVAL
;

2141 if(
r
 =
NULL
) {

2142 
	`FREEMEM
(

->
buf
);

2143 

->
buf
 = 0;

2144 

->
size
 = 0;

2149 if(
n
 < 0)

2150 
n
 = 
	`
(
r
);

2153 
buf
 = 
	`MALLOC
(
n
 + 1);

2154 if(
buf
 =
NULL
)

2157 
	`memy
(
buf
, 
r
, 
n
);

2158 ((
ut8_t
 *)
buf
)[
n
] = '\0';

2159 
	`FREEMEM
(

->
buf
);

2160 

->
buf
 = (
ut8_t
 *)buf;

2161 

->
size
 = 
n
;

2164 
	}
}

2166 
OCTET_STRING_t
 *

2167 
	$OCTET_STRING_w_omBuf
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
r
,

2168 
n
) {

2169 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 =

2170 
td
->
ecifics
 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)td->specifics

2171 : &
a_SPC_OCTET_STRING_ecs
;

2172 
OCTET_STRING_t
 *

;

2174 

 = (
OCTET_STRING_t
 *)
	`CALLOC
(1, 
ecs
->
ru_size
);

2175 if(

 && 
r
 && 
	`OCTET_STRING_omBuf
(, s, 
n
)) {

2176 
	`FREEMEM
(

);

2177 

 = 
NULL
;

2180  

;

2181 
	}
}

2188 
	$OCTET_STRING_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

2189 cڡ *
br
) {

2190 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics
;

2191 cڡ 
OCTET_STRING_t
 *
a
 = 

;

2192 cڡ 
OCTET_STRING_t
 *
b
 = 
br
;

2194 
	`as
(!
ecs
 || scs->
subv
 !
ASN_OSUBV_BIT
);

2196 if(
a
 && 
b
) {

2197 
size_t
 
comm_efix_size
 = 
a
->
size
 <
b
->size ?->size : b->size;

2198 
t
 = 
	`memcmp
(
a
->
buf
, 
b
->buf, 
comm_efix_size
);

2199 if(
t
 == 0) {

2201 if(
a
->
size
 < 
b
->size) {

2203 } if(
a
->
size
 > 
b
->size) {

2209  
t
 < 0 ? -1 : 1;

2211 } if(!
a
 && !
b
) {

2213 } if(!
a
) {

2219 
	}
}

2224 
ut32_t


2225 
	$OCTET_STRING__ndom_ch
(
lb
, 
ub
) {

2226 
	`as
(
lb
 <
ub
);

2227 
	`a_ndom_bwn
(0, 16)) {

2229 if(
lb
 < 
ub
) b + 1;

2232  
lb
;

2234 if(
lb
 < 
ub
)  ub - 1;

2237  
ub
;

2239  
	`a_ndom_bwn
(
lb
, 
ub
);

2241 
	}
}

2244 
size_t


2245 
	$OCTET_STRING_ndom_ngth_cڡed
(

2246 cڡ 
a_TYPE_dest_t
 *
td
,

2247 cڡ 
a_codg_cڡts_t
 *
cڡts
, 
size_t
 
max_ngth
) {

2248 cڡ 
ngths
[] = {0, 1, 2, 3, 4, 8,

2251 
size_t
 
d_n
;

2254 
d_n
 = 
ngths
[
	`a_ndom_bwn
(

2255 0, (
ngths
) / (lengths[0]) - 1)];

2257 if(!
cڡts
 || !cڡts->
r_cڡts
)

2258 
cڡts
 = &
td
->
codg_cڡts
;

2259 if(
cڡts
->
r_cڡts
) {

2260 cڡ 
a_r_cڡt_t
 *
pc
 = &
cڡts
->
r_cڡts
->
size
;

2261 if(
pc
->
ags
 & 
APC_CONSTRAINED
) {

2262 
suggeed_u_bound
 = 
pc
->
u_bound
 < (
ssize_t
)
max_ngth


2263 ? 
pc
->
u_bound


2264 : (
ssize_t
)
max_ngth
;

2265 if(
max_ngth
 <(
size_t
)
pc
->
low_bound
) {

2266  
pc
->
low_bound
;

2268 if(
pc
->
ags
 & 
APC_EXTENSIBLE
) {

2269 
	`a_ndom_bwn
(0, 5)) {

2271 if(
pc
->
low_bound
 > 0) {

2272 
d_n
 = 
pc
->
low_bound
 - 1;

2277 
d_n
 = 
pc
->
u_bound
 + 1;

2281 if(
d_n
 <
max_ngth
) {

2286 
d_n
 = 
	`a_ndom_bwn
(
pc
->
low_bound
,

2287 
suggeed_u_bound
);

2290 
d_n
 =

2291 
	`a_ndom_bwn
(
pc
->
low_bound
, 
suggeed_u_bound
);

2294 
d_n
 = 
	`a_ndom_bwn
(0, 
max_ngth
);

2296 } if(
d_n
 > 
max_ngth
) {

2297 
d_n
 = 
	`a_ndom_bwn
(0, 
max_ngth
);

2300  
d_n
;

2301 
	}
}

2303 
a_ndom_fl_su_t


2304 
	$OCTET_STRING_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

2305 cڡ 
a_codg_cڡts_t
 *
cڡts
,

2306 
size_t
 
max_ngth
) {

2307 cڡ 
a_OCTET_STRING_ecifics_t
 *
ecs
 = 
td
->
ecifics


2308 ? (cڡ 
a_OCTET_STRING_ecifics_t
 *)
td
->
ecifics


2309 : &
a_SPC_OCTET_STRING_ecs
;

2310 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

2311 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

2312 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

2313 
un_bys
 = 1;

2314 
b
 = 0;

2315 
cub
 = 255;

2316 
ut8_t
 *
buf
;

2317 
ut8_t
 *
bd
;

2318 
ut8_t
 *
b
;

2319 
size_t
 
d_n
;

2320 
OCTET_STRING_t
 *

;

2322 if(
max_ngth
 =0 && !*

 
su_skd
;

2324 
ecs
->
subv
) {

2326 
ASN_OSUBV_ANY
:

2327  
su_ed
;

2328 
ASN_OSUBV_BIT
:

2330  
su_ed
;

2331 
ASN_OSUBV_STR
:

2332 
un_bys
 = 1;

2333 
b
 = 0;

2334 
cub
 = 255;

2336 
ASN_OSUBV_U16
:

2337 
un_bys
 = 2;

2338 
b
 = 0;

2339 
cub
 = 65535;

2341 
ASN_OSUBV_U32
:

2342 
un_bys
 = 4;

2343 
b
 = 0;

2344 
cub
 = 0x10FFFF;

2348 if(!
cڡts
 || !cڡts->
r_cڡts
)

2349 
cڡts
 = &
td
->
codg_cڡts
;

2350 if(
cڡts
->
r_cڡts
) {

2351 cڡ 
a_r_cڡt_t
 *
pc
 = &
cڡts
->
r_cڡts
->
vue
;

2352 if(
pc
->
ags
 & 
APC_SEMI_CONSTRAINED
) {

2353 
b
 = 
pc
->
low_bound
;

2354 } if(
pc
->
ags
 & 
APC_CONSTRAINED
) {

2355 
b
 = 
pc
->
low_bound
;

2356 
cub
 = 
pc
->
u_bound
;

2360 
d_n
 =

2361 
	`OCTET_STRING_ndom_ngth_cڡed
(
td
, 
cڡts
, 
max_ngth
);

2363 
buf
 = 
	`CALLOC
(
un_bys
, 
d_n
 + 1);

2364 if(!
buf
 
su_ed
;

2366 
bd
 = &
buf
[
un_bys
 * 
d_n
];

2368 
un_bys
) {

2370 
b
 = 
buf
; b < 
bd
; b +
un_bys
) {

2371 *(
ut8_t
 *)
b
 = 
	`OCTET_STRING__ndom_ch
(
b
, 
cub
);

2373 *(
ut8_t
 *)
b
 = 0;

2376 
b
 = 
buf
; b < 
bd
; b +
un_bys
) {

2377 
ut32_t
 
code
 = 
	`OCTET_STRING__ndom_ch
(
b
, 
cub
);

2378 
b
[0] = 
code
 >> 8;

2379 
b
[1] = 
code
;

2381 *(
ut16_t
 *)
b
 = 0;

2384 
b
 = 
buf
; b < 
bd
; b +
un_bys
) {

2385 
ut32_t
 
code
 = 
	`OCTET_STRING__ndom_ch
(
b
, 
cub
);

2386 
b
[0] = 
code
 >> 24;

2387 
b
[1] = 
code
 >> 16;

2388 
b
[2] = 
code
 >> 8;

2389 
b
[3] = 
code
;

2391 *(
ut32_t
 *)
b
 = 0;

2395 if(*

) {

2396 

 = *

;

2397 
	`FREEMEM
(

->
buf
);

2399 

 = (
OCTET_STRING_t
 *)(*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

2400 if(!

) {

2401 
	`FREEMEM
(
buf
);

2402  
su_ed
;

2406 

->
buf
 = buf;

2407 

->
size
 = 
un_bys
 * 
d_n
;

2409 
su_ok
.
ngth
 = 

->
size
;

2410  
su_ok
;

2411 
	}
}

	@OPEN_TYPE.c

5 
	~<a_.h
>

6 
	~<OPEN_TYPE.h
>

7 
	~<cڡr_CHOICE.h
>

8 
	~<r_ݒty.h
>

9 
	~<o.h
>

11 
a_TYPE_ݔi_t
 
	ga_OP_OPEN_TYPE
 = {

12 
OPEN_TYPE_
,

13 
OPEN_TYPE_t
,

14 
OPEN_TYPE_com
,

15 
OPEN_TYPE_decode_b
,

16 
OPEN_TYPE_code_d
,

17 
OPEN_TYPE_decode_x
,

18 
OPEN_TYPE_code_x
,

19 #ifde
ASN_DISABLE_OER_SUPPORT


22 
OPEN_TYPE_decode_r
,

23 
OPEN_TYPE_code_r
,

25 #ifde
ASN_DISABLE_PER_SUPPORT


28 
OPEN_TYPE_decode_ur
,

29 
OPEN_TYPE_code_ur
,

30 
OPEN_TYPE_decode_
,

31 
OPEN_TYPE_code_
,

37 #unde
ADVANCE


38 
	#ADVANCE
(
num_bys
) \

40 
size_t
 
num
 = 
num_bys
; \

41 
r
 = ((cڡ *+ 
num
; \

42 
size
 -
num
; \

43 
csumed_mylf
 +
num
; \

44 } 0)

	)

46 
a_dec_rv_t


47 
	$OPEN_TYPE_b_g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

48 cڡ 
a_TYPE_dest_t
 *
td
, *

,

49 cڡ 
a_TYPE_memb_t
 *
m
, cڡ *
r
, 
size_t
 
size
) {

50 
size_t
 
csumed_mylf
 = 0;

51 
a_ty__su_t
 
ed
;

52 *
memb_r
;

53 **
memb_r2
;

54 *
r_vue
;

55 
a_dec_rv_t
 
rv
;

57 if(!(
m
->
ags
 & 
ATF_OPEN_TYPE
)) {

58 
ASN__DECODE_FAILED
;

61 if(!
m
->
ty_
) {

62 
	`ASN_DEBUG
("Type selector isot defined for Open Type %s->%s->%s",

63 
td
->
me
, 
m
->me,lm->
ty
->name);

64 
ASN__DECODE_FAILED
;

67 
ed
 = 
m
->
	`ty_
(
td
, 

);

68 if(!
ed
.
en_dex
) {

69 
ASN__DECODE_FAILED
;

73 if(
m
->
ags
 & 
ATF_POINTER
) {

74 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

76 
memb_r
 = (*)

 + 
m
->
memb_offt
;

77 
memb_r2
 = &
memb_r
;

79 if(*
memb_r2
 !
NULL
) {

81 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
, 0) != 0) {

82 
ASN__DECODE_FAILED
;

86 
r_vue
 =

87 (*)*
memb_r2


88 + 
m
->
ty
->
emts
[
ed
.
en_dex
 - 1].
memb_offt
;

90 
	`ASN_DEBUG
("en %d\n", 
ed
.
en_dex
);

92 
rv
 = 
ed
.
ty_dest
->

->
	`b_decod
(

93 
t_codec_x
, 
ed
.
ty_dest
, &
r_vue
, 
r
, 
size
,

94 
m
->
g_mode
);

95 
	`ADVANCE
(
rv
.
csumed
);

96 
rv
.
csumed
 = 0;

97 
rv
.
code
) {

98 
RC_OK
:

99 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
,

100 
ed
.
en_dex
)

102 
rv
.
code
 = 
RC_OK
;

103 
rv
.
csumed
 = 
csumed_mylf
;

104  
rv
;

109 
RC_FAIL
:

110 
rv
.
csumed
 = 
csumed_mylf
;

112 
RC_WMORE
:

116 if(*
memb_r2
) {

117 if(
m
->
ags
 & 
ATF_POINTER
) {

118 
	`ASN_STRUCT_FREE
(*
ed
.
ty_dest
, 
r_vue
);

119 *
memb_r2
 = 
NULL
;

121 
	`ASN_STRUCT_RESET
(*
ed
.
ty_dest
,

122 
r_vue
);

125  
rv
;

126 
	}
}

128 
a_dec_rv_t


129 
	$OPEN_TYPE_x_g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

130 cڡ 
a_TYPE_dest_t
 *
td
, *

,

131 cڡ 
a_TYPE_memb_t
 *
m
, cڡ *
r
, 
size_t
 
size
) {

132 
size_t
 
csumed_mylf
 = 0;

133 
a_ty__su_t
 
ed
;

134 *
memb_r
;

135 **
memb_r2
;

136 *
r_vue
;

137 
a_dec_rv_t
 
rv
;

139 
x_cڋxt
 = 0;

140 
ssize_t
 
ch_size
;

141 
px_chunk_ty_e
 
ch_ty
;

143 if(!(
m
->
ags
 & 
ATF_OPEN_TYPE
)) {

144 
ASN__DECODE_FAILED
;

147 if(!
m
->
ty_
) {

148 
	`ASN_DEBUG
("Type selector isot defined for Open Type %s->%s->%s",

149 
td
->
me
, 
m
->me,lm->
ty
->name);

150 
ASN__DECODE_FAILED
;

153 
ed
 = 
m
->
	`ty_
(
td
, 

);

154 if(!
ed
.
en_dex
) {

155 
ASN__DECODE_FAILED
;

159 
	`as
(
m
->
ags
 =
ATF_OPEN_TYPE
);

160 if(
m
->
ags
 & 
ATF_POINTER
) {

161 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

163 
memb_r
 = (*)

 + 
m
->
memb_offt
;

164 
memb_r2
 = &
memb_r
;

166 if(*
memb_r2
 !
NULL
) {

168 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
, 0)

170 
ASN__DECODE_FAILED
;

178 
ch_size
 = 
	`x_xt_tok
(&
x_cڋxt
, 
r
, 
size
, &
ch_ty
);

179 if(
ch_size
 < 0) {

180 
ASN__DECODE_FAILED
;

182 
ch_ty
) {

183 
PXER_WMORE
:

184 
ASN__DECODE_STARVED
;

185 
PXER_COMMENT
:

186 
PXER_TEXT
:

187 
	`ADVANCE
(
ch_size
);

189 
PXER_TAG
:

199 
	`x_check_g
(
r
, 
ch_size
, 
m
->
me
)) {

200 
XCT_OPENING
:

201 
	`ADVANCE
(
ch_size
);

203 
XCT_BROKEN
:

205 
ASN__DECODE_FAILED
;

208 
r_vue
 =

209 (*)*
memb_r2


210 + 
m
->
ty
->
emts
[
ed
.
en_dex
 - 1].
memb_offt
;

212 
rv
 = 
ed
.
ty_dest
->

->
	`x_decod
(

213 
t_codec_x
, 
ed
.
ty_dest
, &
r_vue
, 
NULL
, 
r
, 
size
);

214 
	`ADVANCE
(
rv
.
csumed
);

215 
rv
.
csumed
 = 0;

216 
rv
.
code
) {

217 
RC_OK
:

218 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
,

219 
ed
.
en_dex
)

223 
rv
.
code
 = 
RC_FAIL
;

226 
RC_FAIL
:

228 
rv
.
csumed
 = 
csumed_mylf
;

230 
RC_WMORE
:

235 if(*
memb_r2
) {

236 if(
m
->
ags
 & 
ATF_POINTER
) {

237 
	`ASN_STRUCT_FREE
(*
ed
.
ty_dest
, 
r_vue
);

238 *
memb_r2
 = 
NULL
;

240 
	`ASN_STRUCT_RESET
(*
ed
.
ty_dest
,

241 
r_vue
);

244  
rv
;

251 
ch_size
 = 
	`x_xt_tok
(&
x_cڋxt
, 
r
, 
size
, &
ch_ty
);

252 if(
ch_size
 < 0) {

253 
ASN__DECODE_FAILED
;

255 
ch_ty
) {

256 
PXER_WMORE
:

257 
ASN__DECODE_STARVED
;

258 
PXER_COMMENT
:

259 
PXER_TEXT
:

260 
	`ADVANCE
(
ch_size
);

262 
PXER_TAG
:

272 
	`x_check_g
(
r
, 
ch_size
, 
m
->
me
)) {

273 
XCT_CLOSING
:

274 
	`ADVANCE
(
ch_size
);

276 
XCT_BROKEN
:

278 
ASN__DECODE_FAILED
;

281 
rv
.
csumed
 +
csumed_mylf
;

283  
rv
;

284 
	}
}

287 #ide 
ASN_DISABLE_PER_SUPPORT


289 
a_dec_rv_t


290 
	$OPEN_TYPE_ur_g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

291 cڡ 
a_TYPE_dest_t
 *
td
, *

,

292 cڡ 
a_TYPE_memb_t
 *
m
, 
a_r_da_t
 *
pd
) {

293 
a_ty__su_t
 
ed
;

294 *
memb_r
;

295 **
memb_r2
;

296 *
r_vue
;

297 
a_dec_rv_t
 
rv
;

299 if(!(
m
->
ags
 & 
ATF_OPEN_TYPE
)) {

300 
ASN__DECODE_FAILED
;

303 if(!
m
->
ty_
) {

304 
	`ASN_DEBUG
("Type selector isot defined for Open Type %s->%s->%s",

305 
td
->
me
, 
m
->me,lm->
ty
->name);

306 
ASN__DECODE_FAILED
;

309 
ed
 = 
m
->
	`ty_
(
td
, 

);

310 if(!
ed
.
en_dex
) {

311 
ASN__DECODE_FAILED
;

315 
	`as
(
m
->
ags
 =
ATF_OPEN_TYPE
);

316 if(
m
->
ags
 & 
ATF_POINTER
) {

317 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

319 
memb_r
 = (*)

 + 
m
->
memb_offt
;

320 
memb_r2
 = &
memb_r
;

322 if(*
memb_r2
 !
NULL
) {

324 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
, 0)

326 
ASN__DECODE_FAILED
;

330 
r_vue
 =

331 (*)*
memb_r2


332 + 
m
->
ty
->
emts
[
ed
.
en_dex
 - 1].
memb_offt
;

334 
rv
 = 
	`ur_ݒ_ty_g
(
t_codec_x
, 
ed
.
ty_dest
, 
NULL
,

335 &
r_vue
, 
pd
);

336 
rv
.
code
) {

337 
RC_OK
:

338 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
,

339 
ed
.
en_dex
)

343 
rv
.
code
 = 
RC_FAIL
;

346 
RC_WMORE
:

347 
RC_FAIL
:

348 if(*
memb_r2
) {

349 if(
m
->
ags
 & 
ATF_POINTER
) {

350 
	`ASN_STRUCT_FREE
(*
ed
.
ty_dest
, 
r_vue
);

351 *
memb_r2
 = 
NULL
;

353 
	`ASN_STRUCT_RESET
(*
ed
.
ty_dest
,

354 
r_vue
);

358  
rv
;

359 
	}
}

361 
a_c_rv_t


362 
	$OPEN_TYPE_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

363 cڡ 
a_r_cڡts_t
 *
cڡts
,

364 cڡ *

, 
a_r_ou_t
 *
po
) {

365 cڡ *
memb_r
;

366 
a_TYPE_memb_t
 *
m
;

367 
a_c_rv_t
 

 = {0,0,0};

368 
e
;

370 ()
cڡts
;

372 
e
 = 
	`CHOICE_v_g_en
(
td
, 

);

373 if(
e
 =0 || > 
td
->
emts_cou
) {

374 
ASN__ENCODE_FAILED
;

376 
e
--;

379 
	`ASN_DEBUG
("Encodg %OPEN TYPEm%d", 
td
->
me
, 
e
);

381 
m
 = &
td
->
emts
[
e
];

382 if(
m
->
ags
 & 
ATF_POINTER
) {

384 
memb_r
 =

385 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

386 if(!
memb_r

ASN__ENCODE_FAILED
;

388 
memb_r
 = (cڡ *)

 + 
m
->
memb_offt
;

391 if(
	`ur_ݒ_ty_put
(
m
->
ty
, 
NULL
, 
memb_r
, 
po
) < 0) {

392 
ASN__ENCODE_FAILED
;

395 

.
coded
 = 0;

396 
	`ASN__ENCODED_OK
(

);

397 
	}
}

399 
a_dec_rv_t


400 
	$OPEN_TYPE__g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

401 cڡ 
a_TYPE_dest_t
 *
td
, *

,

402 cڡ 
a_TYPE_memb_t
 *
m
, 
a_r_da_t
 *
pd
) {

403 
a_ty__su_t
 
ed
;

404 *
memb_r
;

405 **
memb_r2
;

406 *
r_vue
;

407 
a_dec_rv_t
 
rv
;

409 if(!(
m
->
ags
 & 
ATF_OPEN_TYPE
)) {

410 
ASN__DECODE_FAILED
;

413 if(!
m
->
ty_
) {

414 
	`ASN_DEBUG
("Type selector isot defined for Open Type %s->%s->%s",

415 
td
->
me
, 
m
->me,lm->
ty
->name);

416 
ASN__DECODE_FAILED
;

419 
ed
 = 
m
->
	`ty_
(
td
, 

);

420 if(!
ed
.
en_dex
) {

421 
ASN__DECODE_FAILED
;

425 
	`as
(
m
->
ags
 =
ATF_OPEN_TYPE
);

426 if(
m
->
ags
 & 
ATF_POINTER
) {

427 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

429 
memb_r
 = (*)

 + 
m
->
memb_offt
;

430 
memb_r2
 = &
memb_r
;

432 if(*
memb_r2
 !
NULL
) {

434 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
, 0)

436 
ASN__DECODE_FAILED
;

440 
r_vue
 =

441 (*)*
memb_r2


442 + 
m
->
ty
->
emts
[
ed
.
en_dex
 - 1].
memb_offt
;

444 
rv
 = 
	`_ݒ_ty_g
(
t_codec_x
, 
ed
.
ty_dest
, 
NULL
,

445 &
r_vue
, 
pd
);

446 
rv
.
code
) {

447 
RC_OK
:

448 if(
	`CHOICE_v_t_en
(
m
->
ty
, *
memb_r2
,

449 
ed
.
en_dex
)

453 
rv
.
code
 = 
RC_FAIL
;

456 
RC_WMORE
:

457 
RC_FAIL
:

458 if(*
memb_r2
) {

459 if(
m
->
ags
 & 
ATF_POINTER
) {

460 
	`ASN_STRUCT_FREE
(*
ed
.
ty_dest
, 
r_vue
);

461 *
memb_r2
 = 
NULL
;

463 
	`ASN_STRUCT_RESET
(*
ed
.
ty_dest
,

464 
r_vue
);

468  
rv
;

469 
	}
}

471 
a_c_rv_t


472 
	$OPEN_TYPE_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

473 cڡ 
a_r_cڡts_t
 *
cڡts
,

474 cڡ *

, 
a_r_ou_t
 *
po
) {

475 cڡ *
memb_r
;

476 
a_TYPE_memb_t
 *
m
;

477 
a_c_rv_t
 

 = {0,0,0};

478 
e
;

480 ()
cڡts
;

482 
e
 = 
	`CHOICE_v_g_en
(
td
, 

);

483 if(
e
 =0 || > 
td
->
emts_cou
) {

484 
ASN__ENCODE_FAILED
;

486 
e
--;

489 
	`ASN_DEBUG
("Encodg %OPEN TYPEm%d", 
td
->
me
, 
e
);

491 
m
 = &
td
->
emts
[
e
];

492 if(
m
->
ags
 & 
ATF_POINTER
) {

494 
memb_r
 =

495 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

496 if(!
memb_r

ASN__ENCODE_FAILED
;

498 
memb_r
 = (cڡ *)

 + 
m
->
memb_offt
;

501 if(
	`_ݒ_ty_put
(
m
->
ty
, 
NULL
, 
memb_r
, 
po
) < 0) {

502 
ASN__ENCODE_FAILED
;

505 

.
coded
 = 0;

506 
	`ASN__ENCODED_OK
(

);

507 
	}
}

	@PLMNIdentity.c

8 
	~"PLMNIdty.h
"

11 
	$PLMNIdty_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 3)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_PLMNIdty_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 3, 3 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_PLMNIdty_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_PLMNIdty
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_PLMNIdty_gs_1
,

53 (
a_DEF_PLMNIdty_gs_1
)

54 /(
a_DEF_PLMNIdty_gs_1
[0]),

55 
a_DEF_PLMNIdty_gs_1
,

56 (
a_DEF_PLMNIdty_gs_1
)

57 /(
a_DEF_PLMNIdty_gs_1
[0]),

58 { 0, &
a_PER_ty_PLMNIdty_cڡr_1
, 
PLMNIdty_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@PrintableString.c

6 
	~<a_.h
>

7 
	~<PrbSg.h
>

12 cڡ 
	g_PrbSg_phab
[256] = {

22 cڡ 
	g_PrbSg_code2vue
[74] = {

32 cڡ 
b_v_g_t
 
	ga_DEF_PrbSg_gs
[] = {

33 (
ASN_TAG_CLASS_UNIVERSAL
 | (19 << 2)),

34 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

36 
	$a_DEF_PrbSg_v2c
(
vue
) {

37  
_PrbSg_phab
[
vue
 > 255 ? 0 : value] - 1;

38 
	}
}

39 
	$a_DEF_PrbSg_c2v
(
code
) {

40 if(
code
 < 74)

41  
_PrbSg_code2vue
[
code
];

43 
	}
}

44 
a_r_cڡts_t
 
	ga_DEF_PrbSg_r_cڡts
 = {

45 { 
APC_CONSTRAINED
, 4, 4, 0x20, 0x39 },

46 { 
APC_SEMI_CONSTRAINED
, -1, -1, 0, 0 },

47 
a_DEF_PrbSg_v2c
,

48 
a_DEF_PrbSg_c2v


50 
a_TYPE_ݔi_t
 
	ga_OP_PrbSg
 = {

51 
OCTET_STRING_
,

52 
OCTET_STRING_t_utf8
,

53 
OCTET_STRING_com
,

54 
OCTET_STRING_decode_b
,

55 
OCTET_STRING_code_d
,

56 
OCTET_STRING_decode_x_utf8
,

57 
OCTET_STRING_code_x_utf8
,

58 #ifdef 
ASN_DISABLE_OER_SUPPORT


62 
OCTET_STRING_decode_r
,

63 
OCTET_STRING_code_r
,

65 #ifdef 
ASN_DISABLE_PER_SUPPORT


71 
OCTET_STRING_decode_ur
,

72 
OCTET_STRING_code_ur
,

73 
OCTET_STRING_decode_
,

74 
OCTET_STRING_code_
,

76 
OCTET_STRING_ndom_fl
,

79 
a_TYPE_dest_t
 
	ga_DEF_PrbSg
 = {

82 &
a_OP_PrbSg
,

83 
a_DEF_PrbSg_gs
,

84 (
a_DEF_PrbSg_gs
)

85 / (
a_DEF_PrbSg_gs
[0]) - 1,

86 
a_DEF_PrbSg_gs
,

87 (
a_DEF_PrbSg_gs
)

88 / (
a_DEF_PrbSg_gs
[0]),

89 { 0, &
a_DEF_PrbSg_r_cڡts
, 
PrbSg_cڡt
 },

96 
	$PrbSg_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

97 
a_p_cڡt_ed_f
 *
cb
,

98 *
p_key
) {

99 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

101 if(

 && st->
buf
) {

102 
ut8_t
 *
buf
 = 

->buf;

103 
ut8_t
 *
d
 = 
buf
 + 

->
size
;

109 ; 
buf
 < 
d
; buf++) {

110 if(!
_PrbSg_phab
[*
buf
]) {

111 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

115 
td
->
me
,

116 ()((
buf
 - 

->buf) + 1),

117 *
buf
,

118 
__FILE__
, 
__LINE__
);

123 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

125 
td
->
me
, 
__FILE__
, 
__LINE__
);

130 
	}
}

	@QCI.c

8 
	~"QCI.h
"

11 
	$QCI_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 255)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_QCI_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 8, 8, 0, 255 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_QCI_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_QCI
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_QCI_gs_1
,

52 (
a_DEF_QCI_gs_1
)

53 /(
a_DEF_QCI_gs_1
[0]),

54 
a_DEF_QCI_gs_1
,

55 (
a_DEF_QCI_gs_1
)

56 /(
a_DEF_QCI_gs_1
[0]),

57 { 0, &
a_PER_ty_QCI_cڡr_1
, 
QCI_cڡt
 },

	@QoSID.c

8 
	~"QoSID.h
"

10 
a_r_cڡts_t
 
a_PER_ty_QoSID_cڡr_1
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_QoSID_1
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
QoSID
, 
choi
.
fiveGC
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_FiveQI
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
QoSID
, 
choi
.
ePC
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_QCI
,

35 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_QoSID_g2_1
[] = {

36 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

37 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

39 
a_CHOICE_ecifics_t
 
	ga_SPC_QoSID_ecs_1
 = {

40 (
QoSID
),

41 
offtof
(
QoSID
, 
_a_x
),

42 
offtof
(
QoSID
, 
e
),

43 (((
QoSID
 *)0)->
e
),

44 
a_MAP_QoSID_g2_1
,

49 
a_TYPE_dest_t
 
	ga_DEF_QoSID
 = {

52 &
a_OP_CHOICE
,

57 { 0, &
a_PER_ty_QoSID_cڡr_1
, 
CHOICE_cڡt
 },

58 
a_MBR_QoSID_1
,

60 &
a_SPC_QoSID_ecs_1


	@QosFlowIdentifier.c

8 
	~"QosFlowIdtifr.h
"

11 
	$QosFlowIdtifr_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 0 && value <= 63)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_QosFlowIdtifr_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 6, 6, 0, 63 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_QosFlowIdtifr_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_QosFlowIdtifr
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_QosFlowIdtifr_gs_1
,

52 (
a_DEF_QosFlowIdtifr_gs_1
)

53 /(
a_DEF_QosFlowIdtifr_gs_1
[0]),

54 
a_DEF_QosFlowIdtifr_gs_1
,

55 (
a_DEF_QosFlowIdtifr_gs_1
)

56 /(
a_DEF_QosFlowIdtifr_gs_1
[0]),

57 { 0, &
a_PER_ty_QosFlowIdtifr_cڡr_1
, 
QosFlowIdtifr_cڡt
 },

	@RANUEID.c

8 
	~"RANUEID.h
"

11 
	$RANUEID_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 8)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_RANUEID_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 8, 8 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_RANUEID_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_RANUEID
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_RANUEID_gs_1
,

53 (
a_DEF_RANUEID_gs_1
)

54 /(
a_DEF_RANUEID_gs_1
[0]),

55 
a_DEF_RANUEID_gs_1
,

56 (
a_DEF_RANUEID_gs_1
)

57 /(
a_DEF_RANUEID_gs_1
[0]),

58 { 0, &
a_PER_ty_RANUEID_cڡr_1
, 
RANUEID_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@RANfunction-Name.c

8 
	~"RANfuni-Name.h
"

10 cڡ 
	grmd_phab_b_2
[256] = {

20 cڡ 
	grmd_phab_code2vue_2
[74] = {

28 
	$check_rmd_phab_2
(cڡ *

) {

29 cڡ *
b
 = 
rmd_phab_b_2
;

31 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

32 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

33 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

35 ; 
ch
 < 
d
; ch++) {

36 
ut8_t
 
cv
 = *
ch
;

37 if(!
b
[
cv
])  -1;

40 
	}
}

42 cڡ 
	grmd_phab_b_3
[256] = {

52 cڡ 
	grmd_phab_code2vue_3
[74] = {

60 
	$check_rmd_phab_3
(cڡ *

) {

61 cڡ *
b
 = 
rmd_phab_b_3
;

63 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

64 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

65 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

67 ; 
ch
 < 
d
; ch++) {

68 
ut8_t
 
cv
 = *
ch
;

69 if(!
b
[
cv
])  -1;

72 
	}
}

74 cڡ 
	grmd_phab_b_4
[256] = {

84 cڡ 
	grmd_phab_code2vue_4
[74] = {

92 
	$check_rmd_phab_4
(cڡ *

) {

93 cڡ *
b
 = 
rmd_phab_b_4
;

95 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

96 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

97 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

99 ; 
ch
 < 
d
; ch++) {

100 
ut8_t
 
cv
 = *
ch
;

101 if(!
b
[
cv
])  -1;

104 
	}
}

107 
	$memb_nFuni_ShtName_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

108 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

109 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

110 
size_t
 
size
;

112 if(!

) {

113 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

115 
td
->
me
, 
__FILE__
, 
__LINE__
);

119 
size
 = 

->size;

121 if((
size
 >= 1 && size <= 150)

122 && !
	`check_rmd_phab_2
(

)) {

126 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

128 
td
->
me
, 
__FILE__
, 
__LINE__
);

131 
	}
}

133 
	$a_PER_MAP_nFuni_ShtName_2_v2c
(
vue
) {

134 if(
vue
 >(
rmd_phab_b_2
)/(permitted_alphabet_table_2[0]))

136  
rmd_phab_b_2
[
vue
] - 1;

137 
	}
}

138 
	$a_PER_MAP_nFuni_ShtName_2_c2v
(
code
) {

139 if(
code
 >(
rmd_phab_code2vue_2
)/(permitted_alphabet_code2value_2[0]))

141  
rmd_phab_code2vue_2
[
code
];

142 
	}
}

144 
	$memb_nFuni_E2SM_OID_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

145 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

146 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

147 
size_t
 
size
;

149 if(!

) {

150 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

152 
td
->
me
, 
__FILE__
, 
__LINE__
);

156 
size
 = 

->size;

158 if((
size
 >= 1 && size <= 1000)

159 && !
	`check_rmd_phab_3
(

)) {

163 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

165 
td
->
me
, 
__FILE__
, 
__LINE__
);

168 
	}
}

170 
	$a_PER_MAP_nFuni_E2SM_OID_3_v2c
(
vue
) {

171 if(
vue
 >(
rmd_phab_b_3
)/(permitted_alphabet_table_3[0]))

173  
rmd_phab_b_3
[
vue
] - 1;

174 
	}
}

175 
	$a_PER_MAP_nFuni_E2SM_OID_3_c2v
(
code
) {

176 if(
code
 >(
rmd_phab_code2vue_3
)/(permitted_alphabet_code2value_3[0]))

178  
rmd_phab_code2vue_3
[
code
];

179 
	}
}

181 
	$memb_nFuni_Desti_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

182 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

183 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

184 
size_t
 
size
;

186 if(!

) {

187 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

189 
td
->
me
, 
__FILE__
, 
__LINE__
);

193 
size
 = 

->size;

195 if((
size
 >= 1 && size <= 150)

196 && !
	`check_rmd_phab_4
(

)) {

200 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

202 
td
->
me
, 
__FILE__
, 
__LINE__
);

205 
	}
}

207 
	$a_PER_MAP_nFuni_Desti_4_v2c
(
vue
) {

208 if(
vue
 >(
rmd_phab_b_4
)/(permitted_alphabet_table_4[0]))

210  
rmd_phab_b_4
[
vue
] - 1;

211 
	}
}

212 
	$a_PER_MAP_nFuni_Desti_4_c2v
(
code
) {

213 if(
code
 >(
rmd_phab_code2vue_4
)/(permitted_alphabet_code2value_4[0]))

215  
rmd_phab_code2vue_4
[
code
];

216 
	}
}

217 
a_r_cڡts_t
 
a_PER_memb_nFuni_ShtName_cڡr_2
 
	gCC_NOTUSED
 = {

218 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

219 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 1, 150 } ,

220 
a_PER_MAP_nFuni_ShtName_2_v2c
,

221 
a_PER_MAP_nFuni_ShtName_2_c2v


223 
a_r_cڡts_t
 
a_PER_memb_nFuni_E2SM_OID_cڡr_3
 
	gCC_NOTUSED
 = {

224 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

225 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 10, 10, 1, 1000 } ,

226 
a_PER_MAP_nFuni_E2SM_OID_3_v2c
,

227 
a_PER_MAP_nFuni_E2SM_OID_3_c2v


229 
a_r_cڡts_t
 
a_PER_memb_nFuni_Desti_cڡr_4
 
	gCC_NOTUSED
 = {

230 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

231 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 1, 150 } ,

232 
a_PER_MAP_nFuni_Desti_4_v2c
,

233 
a_PER_MAP_nFuni_Desti_4_c2v


235 
a_TYPE_memb_t
 
	ga_MBR_RANfuni_Name_1
[] = {

236 { 
ATF_NOFLAGS
, 0, 
offtof
(
RANfuni_Name
, 
nFuni_ShtName
),

237 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

239 &
a_DEF_PrbSg
,

241 { 0, &
a_PER_memb_nFuni_ShtName_cڡr_2
, 
memb_nFuni_ShtName_cڡt_1
 },

245 { 
ATF_NOFLAGS
, 0, 
offtof
(
RANfuni_Name
, 
nFuni_E2SM_OID
),

246 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

248 &
a_DEF_PrbSg
,

250 { 0, &
a_PER_memb_nFuni_E2SM_OID_cڡr_3
, 
memb_nFuni_E2SM_OID_cڡt_1
 },

254 { 
ATF_NOFLAGS
, 0, 
offtof
(
RANfuni_Name
, 
nFuni_Desti
),

255 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

257 &
a_DEF_PrbSg
,

259 { 0, &
a_PER_memb_nFuni_Desti_cڡr_4
, 
memb_nFuni_Desti_cڡt_1
 },

263 { 
ATF_POINTER
, 1, 
offtof
(
RANfuni_Name
, 
nFuni_In
),

264 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

266 &
a_DEF_NiveIeg
,

273 cڡ 
	ga_MAP_RANfuni_Name_oms_1
[] = { 3 };

274 cڡ 
b_v_g_t
 
	ga_DEF_RANfuni_Name_gs_1
[] = {

275 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

277 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_RANfuni_Name_g2_1
[] = {

278 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

279 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

280 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

281 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 }

283 
a_SEQUENCE_ecifics_t
 
	ga_SPC_RANfuni_Name_ecs_1
 = {

284 (
RANfuni_Name
),

285 
offtof
(
RANfuni_Name
, 
_a_x
),

286 
a_MAP_RANfuni_Name_g2_1
,

288 
a_MAP_RANfuni_Name_oms_1
,

292 
a_TYPE_dest_t
 
	ga_DEF_RANfuni_Name
 = {

295 &
a_OP_SEQUENCE
,

296 
a_DEF_RANfuni_Name_gs_1
,

297 (
a_DEF_RANfuni_Name_gs_1
)

298 /(
a_DEF_RANfuni_Name_gs_1
[0]),

299 
a_DEF_RANfuni_Name_gs_1
,

300 (
a_DEF_RANfuni_Name_gs_1
)

301 /(
a_DEF_RANfuni_Name_gs_1
[0]),

302 { 0, 0, 
SEQUENCE_cڡt
 },

303 
a_MBR_RANfuni_Name_1
,

305 &
a_SPC_RANfuni_Name_ecs_1


	@REAL.c

5 
	#_ISOC99_SOURCE


	)

6 #ide
_BSD_SOURCE


7 
	#_BSD_SOURCE


	)

9 
	~<a_.h
>

10 #if 
defed
(
__pha
)

11 
	~<sys/sour.h
>

13 
	~<dlib.h
>

14 
	~<mh.h
>

15 
	~<t.h
>

16 
	~<o.h
>

17 
	~<REAL.h
>

18 
	~<OCTET_STRING.h
>

20 #unde
INT_MAX


21 
	#INT_MAX
 (()((()-1>> 1))

	)

23 #if !(
defed
(
NAN
|| defed(
INFINITY
))

24 vީ
_zo
 
	gCC_NOTUSED
 = 0.0;

26 #idef 
NAN


27 
	#NAN
 (0.0/0.0)

	)

29 #idef 
INFINITY


30 
	#INFINITY
 (1.0/0.0)

	)

33 #i
defed
(
__g__
)

41 #agm
g
 
dgnoic
 
push


42 #agm
g
 
dgnoic
 
igned
 "-Wc11-extensions"

43 
	$a_i
(
d
) {

44  
	`i
(
d
);

45 
	}
}

46 
	$a_isfe
(
d
) {

47 #ifde
isfe


48  
	`isfe
(
d
);

50  
	`fe
(
d
);

52 
	}
}

53 #agm
g
 
dgnoic
 
p


55 
	#a_i
(
v

	`i
(v)

	)

56 #ifde
isfe


57 
	#a_isfe
(
d

	`isfe
(d

	)

59 
	#a_isfe
(
d

	`fe
(d

	)

66 cڡ 
b_v_g_t
 
	ga_DEF_REAL_gs
[] = {

67 (
ASN_TAG_CLASS_UNIVERSAL
 | (9 << 2))

69 
a_TYPE_ݔi_t
 
	ga_OP_REAL
 = {

70 
ASN__PRIMITIVE_TYPE_
,

71 
REAL_t
,

72 
REAL_com
,

73 
b_decode_imive
,

74 
d_code_imive
,

75 
REAL_decode_x
,

76 
REAL_code_x
,

77 #ifdef 
ASN_DISABLE_OER_SUPPORT


81 
REAL_decode_r
,

82 
REAL_code_r
,

84 #ifdef 
ASN_DISABLE_PER_SUPPORT


90 
REAL_decode_ur
,

91 
REAL_code_ur
,

92 
REAL_decode_
,

93 
REAL_code_
,

95 
REAL_ndom_fl
,

98 
a_TYPE_dest_t
 
	ga_DEF_REAL
 = {

101 &
a_OP_REAL
,

102 
a_DEF_REAL_gs
,

103 (
a_DEF_REAL_gs
) / (asn_DEF_REAL_tags[0]),

104 
a_DEF_REAL_gs
,

105 (
a_DEF_REAL_gs
) / (asn_DEF_REAL_tags[0]),

106 { 0, 0, 
a_gic_no_cڡt
 },

112 
	eeclRlVue
 {

113 
	mSRV__NOT_A_NUMBER
,

114 
	mSRV__MINUS_INFINITY
,

115 
	mSRV__PLUS_INFINITY


116 } 
	teclRlVue_e
;

117 
	seclRlVue_s
 {

118 *
	mrg
;

119 
size_t
 
	mngth
;

120 
	mdv
;

121 } 
	geclRlVue
[] = {

122 
	#SRV_SET
(
foo
, 
v
{ foo, (foo- 1, v }

	)

123 
SRV_SET
("<NOT-A-NUMBER/>", 0),

124 
SRV_SET
("<MINUS-INFINITY/>", -1),

125 
SRV_SET
("<PLUS-INFINITY/>", 1),

126 #unde
SRV_SET


129 
ssize_t


130 
	$REAL__dump
(
d
, 
nil
, 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

131 
lol_buf
[64];

132 *
buf
 = 
lol_buf
;

133 
ssize_t
 
bu
 = (
lol_buf
);

134 cڡ *
fmt
 = 
nil
 ? "%.17E" : "%.15f" ;

135 
ssize_t
 
t
;

141 if(
	`a_i
(
d
)) {

142 
buf
 = 
eclRlVue
[
SRV__NOT_A_NUMBER
].
rg
;

143 
bu
 = 
eclRlVue
[
SRV__NOT_A_NUMBER
].
ngth
;

144  (
	`cb
(
buf
, 
bu
, 
p_key
) < 0) ? -1 : buflen;

145 } if(!
	`a_isfe
(
d
)) {

146 if(
	`cysign
(1.0, 
d
) < 0.0) {

147 
buf
 = 
eclRlVue
[
SRV__MINUS_INFINITY
].
rg
;

148 
bu
 = 
eclRlVue
[
SRV__MINUS_INFINITY
].
ngth
;

150 
buf
 = 
eclRlVue
[
SRV__PLUS_INFINITY
].
rg
;

151 
bu
 = 
eclRlVue
[
SRV__PLUS_INFINITY
].
ngth
;

153  (
	`cb
(
buf
, 
bu
, 
p_key
) < 0) ? -1 : buflen;

154 } if(
	`ogb
(
d
<-
INT_MAX
) {

155 if(
	`cysign
(1.0, 
d
) < 0.0) {

156 
buf
 = "-0";

157 
bu
 = 2;

159 
buf
 = "0";

160 
bu
 = 1;

162  (
	`cb
(
buf
, 
bu
, 
p_key
) < 0) ? -1 : buflen;

169 
t
 = 
	`tf
(
buf
, 
bu
, 
fmt
, 
d
);

170 if(
t
 < 0) {

172 
bu
 <<= 1;

173 if(
bu
 > 4096) {

175 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

178 } if(
t
 >
bu
) {

179 
bu
 = 
t
 + 1;

181 
bu
 = 
t
;

184 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

185 
buf
 = (*)
	`MALLOC
(
bu
);

186 if(!
buf
)  -1;

189 if(
nil
) {

194 *
d
;

195 *
d
 = 
buf
 + 
bu
;

196 *
ϡ_zo
;

197 *
f_zo__run
;

198 *
s
;

201 
LZSTATE_NOTHING
,

202 
LZSTATE_ZEROES


203 } 
lz_e
 = 
LZSTATE_NOTHING
;

205 
d
 = (
buf
[0] == 0x2d ) ? (buf + 2) : (buf + 1);

206 if(*
d
 >= 0x30) {

207 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

208 
o
 = 
EINVAL
;

211 *
d
 = 0x2e;

213 
f_zo__run
 = 
ϡ_zo
 = 
s
 = 
d
 + 2; s < 
d
; s++) {

214 *
s
) {

216 if(
lz_e
 =
LZSTATE_ZEROES

ϡ_zo
 = 
f_zo__run
;

219 if(
lz_e
 =
LZSTATE_NOTHING

f_zo__run
 = 
s
;

220 
lz_e
 = 
LZSTATE_ZEROES
;

223 
lz_e
 = 
LZSTATE_NOTHING
;

229 if(
s
 =
d
) {

230 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

231 
o
 = 
EINVAL
;

235 
	`as
(*
s
 == 0x45);

237 *
E
 = 
s
;

238 *
ex
 = ++
E
;

239 *
s
 = 
ex
;

240 
sign
;

242 if(*
ex
 == 0x2b ) {

244 
bu
 -= 1;

245 
sign
 = 0;

247 
sign
 = 1;

248 
s
++;

250 
ex
++;

251 if(
ex
 > 
d
) {

252 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

253 
o
 = 
EINVAL
;

256 if(*
ex
 == 0x30) {

257 
bu
--;

258 
ex
++;

260 if(
lz_e
 =
LZSTATE_ZEROES
) {

261 *
ϡ_zo
 = 0x45;

262 
bu
 -
s
 - (
ϡ_zo
 + 1);

263 
s
 = 
ϡ_zo
 + 1;

264 if(
sign
) {

265 *
s
++ = 0x2d ;

266 
bu
++;

269 ; 
ex
 <
d
; 
s
++,xpptr++)

270 *
s
 = *
ex
;

276 *
d
 = 
buf
 + 
bu
;

277 *
ϡ_zo
 = 
d
;

278 
lookg
 = 0;

279 *
z
;

280 
z
 = 
d
 - 1; z > 
buf
; z--) {

281 *
z
) {

283 if(!
lookg
)

284 
ϡ_zo
 = 
z
;

288 
lookg
 = 1;

295 *
z
 = 0x2e;

296 if(
ϡ_zo
 =
z
 + 1) {

297 
ϡ_zo
++;

299 
bu
 = 
ϡ_zo
 - 
buf
;

300 *
ϡ_zo
 = '\0';

307 
t
 = 
	`cb
(
buf
, 
bu
, 
p_key
);

308 if(
buf
 !
lol_buf

	`FREEMEM
(buf);

309  (
t
 < 0? -1 : 
bu
;

310 
	}
}

313 
	$REAL_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

314 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

315 cڡ 
REAL_t
 *

 = (cڡ REAL_*)

;

316 
ssize_t
 
t
;

317 
d
;

319 ()
td
;

320 ()
ev
;

322 if(!

 || !->
buf
)

323 
t
 = 
	`cb
("<ab>", 8, 
p_key
);

324 if(
	`a_REAL2doub
(

, &
d
))

325 
t
 = 
	`cb
("<r>", 7, 
p_key
);

327 
t
 = 
	`REAL__dump
(
d
, 0, 
cb
, 
p_key
);

329  (
t
 < 0) ? -1 : 0;

330 
	}
}

333 
	$REAL_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

334 cڡ *
br
) {

335 cڡ 
REAL_t
 *
a
 = 

;

336 cڡ 
REAL_t
 *
b
 = 
br
;

338 ()
td
;

340 if(
a
 && 
b
) {

341 
adbl
, 
bdbl
;

342 

, 
rb
;

343 

 = 
	`a_REAL2doub
(
a
, &
adbl
);

344 
rb
 = 
	`a_REAL2doub
(
b
, &
bdbl
);

345 if(

 =0 && 
rb
 == 0) {

346 if(
	`a_i
(
adbl
)) {

347 if(
	`a_i
(
bdbl
)) {

352 } if(
	`a_i
(
bdbl
)) {

356 if(
adbl
 < 
bdbl
) {

358 } if(
adbl
 > 
bdbl
) {

363 } if(

) {

368 } if(!
a
) {

373 
	}
}

375 
a_c_rv_t


376 
	$REAL_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

377 
x_cod_ags_e
 
ags
, 
a_p_csume_bys_f
 *
cb
,

378 *
p_key
) {

379 cڡ 
REAL_t
 *

 = (cڡ REAL_*)

;

380 
a_c_rv_t
 

 = {0,0,0};

381 
d
;

383 ()
ev
;

385 if(!

 || !->
buf
 || 
	`a_REAL2doub
(, &
d
))

386 
ASN__ENCODE_FAILED
;

388 

.
coded
 = 
	`REAL__dump
(
d
, 
ags
 & 
XER_F_CANONICAL
, 
cb
, 
p_key
);

389 if(

.
coded
 < 0
ASN__ENCODE_FAILED
;

391 
	`ASN__ENCODED_OK
(

);

392 
	}
}

398 
x_pbd_rv


399 
	$REAL__x_body_decode
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

400 cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

401 
REAL_t
 *

 = (REAL_*)

;

402 
vue
;

403 cڡ *
xda
 = (cڡ *)
chunk_buf
;

404 *
dr
 = 0;

405 *
b
;

407 ()
td
;

409 if(!
chunk_size
 
XPBD_BROKEN_ENCODING
;

414 if(
xda
[0] == 0x3c ) {

415 
size_t
 
i
;

416 
i
 = 0; i < (
eclRlVue
)

417 / (
eclRlVue
[0]); 
i
++) {

418 
eclRlVue_s
 *
v
 = &
eclRlVue
[
i
];

419 
dv
;

421 if(
v
->
ngth
 !
chunk_size


422 || 
	`memcmp
(
v
->
rg
, 
chunk_buf
, 
chunk_size
))

430 
v
->
dv
) {

431 -1: 
dv
 = - 
INFINITY
; ;

432 0: 
dv
 = 
NAN
; ;

433 1: 
dv
 = 
INFINITY
; ;

434 :  
XPBD_SYSTEM_FAILURE
;

437 if(
	`a_doub2REAL
(

, 
dv
))

438  
XPBD_SYSTEM_FAILURE
;

440  
XPBD_BODY_CONSUMED
;

442 
	`ASN_DEBUG
("Unknown XMLSpecialRealValue");

443  
XPBD_BROKEN_ENCODING
;

449 
b
 = (*)
	`MALLOC
(
chunk_size
 + 1);

450 if(!
b
 
XPBD_SYSTEM_FAILURE
;

451 
	`memy
(
b
, 
chunk_buf
, 
chunk_size
);

452 
b
[
chunk_size
] = 0;

454 
vue
 = 
	`od
(
b
, &
dr
);

455 
	`FREEMEM
(
b
);

456 if(
dr
 =
b
 
XPBD_BROKEN_ENCODING
;

458 if(
	`a_doub2REAL
(

, 
vue
))

459  
XPBD_SYSTEM_FAILURE
;

461  
XPBD_BODY_CONSUMED
;

462 
	}
}

464 
a_dec_rv_t


465 
	$REAL_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

466 cڡ 
a_TYPE_dest_t
 *
td
, **

,

467 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

468  
	`x_decode_imive
(
t_codec_x
, 
td
,

469 

, (
REAL_t
), 
t_mme
,

470 
buf_r
, 
size
, 
REAL__x_body_decode
);

471 
	}
}

474 
	$a_REAL2doub
(cڡ 
REAL_t
 *

, *
dbl_vue
) {

475 
ov
;

477 if(!

 || !->
buf
) {

478 
o
 = 
EINVAL
;

482 if(

->
size
 == 0) {

483 *
dbl_vue
 = 0;

487 
ov
 = 

->
buf
[0];

489 
ov
 & 0xC0) {

498 

->
buf
[0]) {

500 *
dbl_vue
 = 
INFINITY
;

503 *
dbl_vue
 = - 
INFINITY
;

506 *
dbl_vue
 = 
NAN
;

509 *
dbl_vue
 = -0.0;

513 
o
 = 
EINVAL
;

522 
d
;

523 *
sour
 = 0;

524 *
dr
;

525 
ud_mloc
 = 0;

527 if(
ov
 == 0 || (octv & 0x3C)) {

529 
o
 = 
EINVAL
;

539 if(

->
buf
[->
size
] !'\0' || 
	`memchr
(st->buf, ',', st->size)) {

540 cڡ 
ut8_t
 *
p
, *
d
;

541 *
b
;

543 
b
 = 
sour
 = (*)
	`MALLOC
(

->
size
 + 1);

544 if(!
sour
)  -1;

545 
ud_mloc
 = 1;

548 
p
 = 

->
buf
 + 1, 
d
 = st->bu+ st->
size
;

549 
p
 < 
d
; 
b
++,++)

550 *
b
 = (*
p
 == ',') ? '.' : *p;

551 *
b
 = '\0';

553 
sour
 = (*)&

->
buf
[1];

556 
dr
 = 
sour
;

557 
d
 = 
	`od
(
sour
, &
dr
);

558 if(*
dr
 != '\0') {

560 if(
ud_mloc

	`FREEMEM
(
sour
);

561 
o
 = 
EINVAL
;

564 if(
ud_mloc

	`FREEMEM
(
sour
);

565 if(
	`a_isfe
(
d
)) {

566 *
dbl_vue
 = 
d
;

569 
o
 = 
ERANGE
;

579 
m
;

580 
t32_t
 
expv
;

581 

;

582 
sF
;

583 
baF
;

584 
ut8_t
 *
r
;

585 
ut8_t
 *
d
;

586 
sign
;

588 (
ov
 & 0x30) >> 4) {

589 0x00: 
baF
 = 1; ;

590 0x01: 
baF
 = 3; ;

591 0x02: 
baF
 = 4; ;

594 
o
 = 
EINVAL
;

598 
sign
 = (
ov
 & 0x40);

599 
sF
 = (
ov
 & 0x0C) >> 2;

601 if(

->
size
 <1 + (
ov
 & 0x03)) {

602 
o
 = 
EINVAL
;

606 

 = (
ov
 & 0x03);

607 if(

 == 0x03) {

608 

 = 

->
buf
[1];

609 if(

 =0 || 

->
size
 <= (2 +len)) {

610 
o
 = 
EINVAL
;

614 
r
 = &

->
buf
[2];

616 
r
 = &

->
buf
[1];

620 
expv
 = ()(*(
t8_t
 *)
r
);

621 if(

 >(
expv
)-1) {

622 
o
 = 
ERANGE
;

625 
d
 = 
r
 + 

 + 1;

626 
r
++; < 
d
;tr++)

627 
expv
 = (expv * 256+ *
r
;

629 
m
 = 0.0;

632 
d
 = 

->
buf
 + st->
size
;

633 ; 
r
 < 
d
;tr++)

634 
m
 = 
	`ldexp
(m, 8+ *
r
;

637 
	`ASN_DEBUG
("m=%.10f, scF=%d, bF=%d,xpval=%d,dexp()=%f,dexp()=%f\n",

638 
m
, 
sF
, 
baF
, 
expv
,

639 
	`ldexp
(
m
, 
expv
 * 
baF
 + 
sF
),

640 
	`ldexp
(
m
, 
sF
* 
	`pow
ow(2, 
baF
), 
expv
)

648 
m
 = 
	`ldexp
(m, 
expv
 * 
baF
 + 
sF
);

649 if(
	`a_isfe
(
m
)) {

650 *
dbl_vue
 = 
sign
 ? -
m
 : m;

652 
o
 = 
ERANGE
;

659 
	}
}

666 
	$a_doub2REAL
(
REAL_t
 *

, 
dbl_vue
) {

667 

 = -0.0;

668 
t_big_dn
 = *(cڡ *)&

 != 0;

669 
ut8_t
 
buf
[16];

670 
ut8_t
 
ds
[(
dbl_vue
)];

672 
asi_bufr1
[9 - (
dbl_vue
)] 
CC_NOTUSED
;

673 
asi_bufr2
[(
dbl_vue
- 7] 
CC_NOTUSED
;

674 
ut8_t
 *
r
 = 
buf
;

675 
ut8_t
 *
m
;

676 
mv
;

677 
bmsign
;

678 
bu
;

679 
accum
;

680 
expv
;

682 if(!

) {

683 
o
 = 
EINVAL
;

692 
expv
 = 
	`ogb
(
dbl_vue
);

693 if(
expv
 <-
INT_MAX


694 || 
expv
 =
INT_MAX


696 if(!

->
buf
 || st->
size
 < 2) {

697 
r
 = (
ut8_t
 *)
	`MALLOC
(2);

698 if(!
r
)  -1;

699 if(

->
buf

	`FREEMEM
(st->buf);

700 

->
buf
 = 
r
;

703 if(
	`a_i
(
dbl_vue
)) {

704 

->
buf
[0] = 0x42;

705 

->
buf
[1] = 0;

706 

->
size
 = 1;

707 } if(!
	`a_isfe
(
dbl_vue
)) {

708 if(
	`cysign
(1.0, 
dbl_vue
) < 0.0) {

709 

->
buf
[0] = 0x41;

711 

->
buf
[0] = 0x40;

713 

->
buf
[1] = 0;

714 

->
size
 = 1;

716 if(
	`cysign
(1.0, 
dbl_vue
) >= 0.0) {

718 

->
buf
[0] = 0;

719 

->
size
 = 0;

722 

->
buf
[0] = 0x43;

723 

->
buf
[1] = 0;

724 

->
size
 = 1;

730 if(
t_big_dn
) {

731 
ut8_t
 *
s
 = ((ut8_*)&
dbl_vue
) + 1;

732 
ut8_t
 *
d
 = ((ut8_*)&
dbl_vue
) + ();

733 
ut8_t
 *
d
;

735 
bmsign
 = 0x80 | ((
s
[-1] >> 1) & 0x40);

736 
m
 = 
d
 = 
ds
; 
s
 < 
d
; d++, s++) {

737 *
d
 = *
s
;

738 if(*
d

m
 = d;

741 
ut8_t
 *
s
 = ((ut8_*)&
dbl_vue
) + (dbl_value) - 2;

742 
ut8_t
 *
t
 = ((ut8_*)&
dbl_vue
);

743 
ut8_t
 *
d
;

745 
bmsign
 = 0x80 | ((
s
[1] >> 1) & 0x40);

746 
m
 = 
d
 = 
ds
; 
s
 >
t
; d++, s--) {

747 *
d
 = *
s
;

748 if(*
d

m
 = d;

753 
ds
[0] = 0x10 | (dscr[0] & 0x0f);

756 
expv
 -8 * ((
m
 - 
ds
) + 1) - 4;

759 
mv
 = *
m
;

760 if(
mv
 && !(mval & 1)) {

761 
shi_cou
 = 1;

762 
ishi
;

763 
ut8_t
 *
mr
;

768 if(!(
mv
 & 0x0f))

769 
shi_cou
 = 4;

770 ((
mv
 >> 
shi_cou
) & 1) == 0)

771 
shi_cou
++;

773 
ishi
 = 8 - 
shi_cou
;

774 
accum
 = 0;

777 
mr
 = 
ds
; m<
m
; mptr++) {

778 
mv
 = *
mr
;

779 *
mr
 = 
accum
 | (
mv
 >> 
shi_cou
);

780 
accum
 = 
mv
 << 
ishi
;

784 
expv
 +
shi_cou
;

787 if(
expv
 < 0) {

788 if((
expv
 >> 7) == -1) {

789 *
r
++ = 
bmsign
 | 0x00;

790 *
r
++ = 
expv
;

791 } if((
expv
 >> 15) == -1) {

792 *
r
++ = 
bmsign
 | 0x01;

793 *
r
++ = 
expv
 >> 8;

794 *
r
++ = 
expv
;

796 *
r
++ = 
bmsign
 | 0x02;

797 *
r
++ = 
expv
 >> 16;

798 *
r
++ = 
expv
 >> 8;

799 *
r
++ = 
expv
;

801 } if(
expv
 <= 0x7f) {

802 *
r
++ = 
bmsign
 | 0x00;

803 *
r
++ = 
expv
;

804 } if(
expv
 <= 0x7fff) {

805 *
r
++ = 
bmsign
 | 0x01;

806 *
r
++ = 
expv
 >> 8;

807 *
r
++ = 
expv
;

809 
	`as
(
expv
 <= 0x7fffff);

810 *
r
++ = 
bmsign
 | 0x02;

811 *
r
++ = 
expv
 >> 16;

812 *
r
++ = 
expv
 >> 8;

813 *
r
++ = 
expv
;

816 
bu
 = (
m
 - 
ds
) + 1;

817 
	`memy
(
r
, 
ds
, 
bu
);

818 
r
 +
bu
;

819 
bu
 = 
r
 - 
buf
;

821 
r
 = (
ut8_t
 *)
	`MALLOC
(
bu
 + 1);

822 if(!
r
)  -1;

824 
	`memy
(
r
, 
buf
, 
bu
);

825 
buf
[
bu
] = 0;

827 if(

->
buf

	`FREEMEM
(st->buf);

828 

->
buf
 = 
r
;

829 

->
size
 = 
bu
;

832 
	}
}

834 
CC_ATTR_NO_SANITIZE
("float-cast-overflow")

835 
	$a_doub2t
(
d
, *
outcome
) {

836 
f
 = 
d
;

838 *
outcome
 = 
f
;

840 if(
	`a_isfe
(
d
=a_isfe(
f
)) {

845 
	}
}

847 #ide
ASN_DISABLE_OER_SUPPORT


852 
a_c_rv_t


853 
	$REAL_code_r
(cڡ 
a_TYPE_dest_t
 *
td
,

854 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

855 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

856 cڡ 
REAL_t
 *

 = 

;

857 
a_c_rv_t
 

 = {0,0,0};

858 
ssize_t
 
n_n
;

860 if(!

 || !->
buf
 || !
td
)

861 
ASN__ENCODE_FAILED
;

863 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

864 if(
cڡts
 && cڡts->
vue
.
width
 != 0) {

867 
ASN__ENCODE_FAILED
;

871 
n_n
 = 
	`r_rlize_ngth
(

->
size
, 
cb
, 
p_key
);

872 if(
n_n
 < 0 || 
	`cb
(

->
buf
, st->
size
, 
p_key
) < 0) {

873 
ASN__ENCODE_FAILED
;

875 

.
coded
 = 
n_n
 + 

->
size
;

876 
	`ASN__ENCODED_OK
(

);

878 
	}
}

880 
a_dec_rv_t


881 
	$REAL_decode_r
(cڡ 
a_codec_x_t
 *
t_codec_x
,

882 cڡ 
a_TYPE_dest_t
 *
td
,

883 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

884 cڡ *
r
, 
size_t
 
size
) {

885 
a_dec_rv_t
 
ok
 = {
RC_OK
, 0};

886 
REAL_t
 *

;

887 
ut8_t
 *
buf
;

888 
ssize_t
 
n_n
;

889 
size_t
 
_body_n
;

891 ()
t_codec_x
;

893 if(!
cڡts
cڡt
td
->
codg_cڡts
.
r_cڡts
;

894 if(
cڡts
 && cڡts->
vue
.
width
 != 0) {

897 
ASN__DECODE_FAILED
;

900 
n_n
 = 
	`r_tch_ngth
(
r
, 
size
, &
_body_n
);

901 if(
n_n
 < 0
ASN__DECODE_FAILED
;

902 if(
n_n
 =0
ASN__DECODE_STARVED
;

904 
r
 = (cڡ * + 
n_n
;

905 
size
 -
n_n
;

907 if(
_body_n
 > 
size

ASN__DECODE_STARVED
;

909 
buf
 = 
	`CALLOC
(1, 
_body_n
 + 1);

910 if(!
buf

ASN__DECODE_FAILED
;

912 if(!(

 = *

)) {

913 

 = (*

 = 
	`CALLOC
(1, (
REAL_t
)));

914 if(!

) {

915 
	`FREEMEM
(
buf
);

916 
ASN__DECODE_FAILED
;

919 
	`FREEMEM
(

->
buf
);

922 
	`memy
(
buf
, 
r
, 
_body_n
);

923 
buf
[
_body_n
] = '\0';

925 

->
buf
 = buf;

926 

->
size
 = 
_body_n
;

928 
ok
.
csumed
 = 
n_n
 + 
_body_n
;

929  
ok
;

930 
	}
}

934 #ide
ASN_DISABLE_PER_SUPPORT


936 
a_dec_rv_t


937 
	$REAL_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

938 cڡ 
a_TYPE_dest_t
 *
td
,

939 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

940 
a_r_da_t
 *
pd
) {

941 ()
cڡts
;

942  
	`OCTET_STRING_decode_ur
(
t_codec_x
, 
td
, 0, 

, 
pd
);

943 
	}
}

945 
a_c_rv_t


946 
	$REAL_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

947 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

948 
a_r_ou_t
 *
po
) {

949 ()
cڡts
;

950  
	`OCTET_STRING_code_ur
(
td
, 0, 

, 
po
);

951 
	}
}

953 
a_dec_rv_t


954 
	$REAL_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

955 cڡ 
a_TYPE_dest_t
 *
td
,

956 cڡ 
a_r_cڡts_t
 *
cڡts
,

957 **

, 
a_r_da_t
 *
pd
) {

958 ()
cڡts
;

959  
	`OCTET_STRING_decode_
(
t_codec_x
, 
td
, 0, 

, 
pd
);

960 
	}
}

962 
a_c_rv_t


963 
	$REAL_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

964 cڡ 
a_r_cڡts_t
 *
cڡts
,

965 cڡ *

, 
a_r_ou_t
 *
po
) {

966 ()
cڡts
;

967  
	`OCTET_STRING_code_
(
td
, 0, 

, 
po
);

968 
	}
}

972 
a_ndom_fl_su_t


973 
	$REAL_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

974 cڡ 
a_codg_cڡts_t
 *
cڡts
,

975 
size_t
 
max_ngth
) {

976 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 1};

977 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

978 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

979 cڡ 
vues
[] = {

980 0, -0.0, -1, 1, -
M_E
, M_E, -3.14, 3.14, -
M_PI
, M_PI, -255, 255,

987 -
FLT_MIN
, FLT_MIN,

988 -
FLT_MAX
, FLT_MAX,

989 -
DBL_MIN
, DBL_MIN,

990 -
DBL_MAX
, DBL_MAX,

991 #ifde 
FLT_TRUE_MIN


992 -
FLT_TRUE_MIN
, FLT_TRUE_MIN,

994 #ifde 
DBL_TRUE_MIN


995 -
DBL_TRUE_MIN
, DBL_TRUE_MIN,

997 
INFINITY
, -INFINITY, 
NAN
};

998 
REAL_t
 *

;

999 
d
;

1001 ()
cڡts
;

1003 if(
max_ngth
 =0 
su_skd
;

1005 
d
 = 
vues
[
	`a_ndom_bwn
(0, (values) / (values[0]) - 1)];

1007 if(*

) {

1008 

 = *

;

1010 

 = (
REAL_t
*)(*

 = 
	`CALLOC
(1, (REAL_t)));

1011 if(!

) {

1012  
su_ed
;

1016 if(
	`a_doub2REAL
(

, 
d
)) {

1017 if(

 =*

) {

1018 
	`ASN_STRUCT_RESET
(*
td
, 

);

1020 
	`ASN_STRUCT_FREE
(*
td
, 

);

1022  
su_ed
;

1025 
su_ok
.
ngth
 = 

->
size
;

1026  
su_ok
;

1027 
	}
}

	@RIC-EventTriggerStyle-Item.c

8 
	~"RIC-EvtTriggSty-Im.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_RIC_EvtTriggSty_Im_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_EvtTriggSty_Im
, 
ric_EvtTriggSty_Ty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_RIC_Sty_Ty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_EvtTriggSty_Im
, 
ric_EvtTriggSty_Name
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_RIC_Sty_Name
,

29 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_EvtTriggSty_Im
, 
ric_EvtTriggFm_Ty
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_RIC_Fm_Ty
,

39 cڡ 
b_v_g_t
 
	ga_DEF_RIC_EvtTriggSty_Im_gs_1
[] = {

40 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

42 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_RIC_EvtTriggSty_Im_g2_1
[] = {

43 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

44 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

45 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

47 
a_SEQUENCE_ecifics_t
 
	ga_SPC_RIC_EvtTriggSty_Im_ecs_1
 = {

48 (
RIC_EvtTriggSty_Im
),

49 
offtof
(
RIC_EvtTriggSty_Im
, 
_a_x
),

50 
a_MAP_RIC_EvtTriggSty_Im_g2_1
,

55 
a_TYPE_dest_t
 
	ga_DEF_RIC_EvtTriggSty_Im
 = {

58 &
a_OP_SEQUENCE
,

59 
a_DEF_RIC_EvtTriggSty_Im_gs_1
,

60 (
a_DEF_RIC_EvtTriggSty_Im_gs_1
)

61 /(
a_DEF_RIC_EvtTriggSty_Im_gs_1
[0]),

62 
a_DEF_RIC_EvtTriggSty_Im_gs_1
,

63 (
a_DEF_RIC_EvtTriggSty_Im_gs_1
)

64 /(
a_DEF_RIC_EvtTriggSty_Im_gs_1
[0]),

65 { 0, 0, 
SEQUENCE_cڡt
 },

66 
a_MBR_RIC_EvtTriggSty_Im_1
,

68 &
a_SPC_RIC_EvtTriggSty_Im_ecs_1


	@RIC-Format-Type.c

8 
	~"RIC-Fm-Ty.h
"

14 cڡ 
b_v_g_t
 
	ga_DEF_RIC_Fm_Ty_gs_1
[] = {

15 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

17 
a_TYPE_dest_t
 
	ga_DEF_RIC_Fm_Ty
 = {

20 &
a_OP_NiveIeg
,

21 
a_DEF_RIC_Fm_Ty_gs_1
,

22 (
a_DEF_RIC_Fm_Ty_gs_1
)

23 /(
a_DEF_RIC_Fm_Ty_gs_1
[0]),

24 
a_DEF_RIC_Fm_Ty_gs_1
,

25 (
a_DEF_RIC_Fm_Ty_gs_1
)

26 /(
a_DEF_RIC_Fm_Ty_gs_1
[0]),

27 { 0, 0, 
NiveIeg_cڡt
 },

	@RIC-ReportStyle-Item.c

8 
	~"RIC-RtSty-Im.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_RIC_RtSty_Im_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
ric_RtSty_Ty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_RIC_Sty_Ty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
ric_RtSty_Name
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_RIC_Sty_Name
,

29 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
ric_AiFm_Ty
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_RIC_Fm_Ty
,

38 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
msInfo_Ai_Li
),

39 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

41 &
a_DEF_MsumtInfo_Ai_Li
,

47 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
ric_InditiHdFm_Ty
),

48 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

50 &
a_DEF_RIC_Fm_Ty
,

56 { 
ATF_NOFLAGS
, 0, 
offtof
(
RIC_RtSty_Im
, 
ric_InditiMesgeFm_Ty
),

57 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

59 &
a_DEF_RIC_Fm_Ty
,

66 cڡ 
b_v_g_t
 
	ga_DEF_RIC_RtSty_Im_gs_1
[] = {

67 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

69 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_RIC_RtSty_Im_g2_1
[] = {

70 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

71 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

72 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

73 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

74 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

75 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 }

77 
a_SEQUENCE_ecifics_t
 
	ga_SPC_RIC_RtSty_Im_ecs_1
 = {

78 (
RIC_RtSty_Im
),

79 
offtof
(
RIC_RtSty_Im
, 
_a_x
),

80 
a_MAP_RIC_RtSty_Im_g2_1
,

85 
a_TYPE_dest_t
 
	ga_DEF_RIC_RtSty_Im
 = {

88 &
a_OP_SEQUENCE
,

89 
a_DEF_RIC_RtSty_Im_gs_1
,

90 (
a_DEF_RIC_RtSty_Im_gs_1
)

91 /(
a_DEF_RIC_RtSty_Im_gs_1
[0]),

92 
a_DEF_RIC_RtSty_Im_gs_1
,

93 (
a_DEF_RIC_RtSty_Im_gs_1
)

94 /(
a_DEF_RIC_RtSty_Im_gs_1
[0]),

95 { 0, 0, 
SEQUENCE_cڡt
 },

96 
a_MBR_RIC_RtSty_Im_1
,

98 &
a_SPC_RIC_RtSty_Im_ecs_1


	@RIC-Style-Name.c

8 
	~"RIC-Sty-Name.h
"

10 cڡ 
	grmd_phab_b_1
[256] = {

20 cڡ 
	grmd_phab_code2vue_1
[74] = {

28 
	$check_rmd_phab_1
(cڡ *

) {

29 cڡ *
b
 = 
rmd_phab_b_1
;

31 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

32 cڡ 
ut8_t
 *
ch
 = 

->
buf
;

33 cڡ 
ut8_t
 *
d
 = 
ch
 + 

->
size
;

35 ; 
ch
 < 
d
; ch++) {

36 
ut8_t
 
cv
 = *
ch
;

37 if(!
b
[
cv
])  -1;

40 
	}
}

43 
	$RIC_Sty_Name_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

44 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

45 cڡ 
PrbSg_t
 *

 = (cڡ PrbSg_*)

;

46 
size_t
 
size
;

48 if(!

) {

49 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

51 
td
->
me
, 
__FILE__
, 
__LINE__
);

55 
size
 = 

->size;

57 if((
size
 >= 1 && size <= 150)

58 && !
	`check_rmd_phab_1
(

)) {

62 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

64 
td
->
me
, 
__FILE__
, 
__LINE__
);

67 
	}
}

69 
	$a_PER_MAP_RIC_Sty_Name_1_v2c
(
vue
) {

70 if(
vue
 >(
rmd_phab_b_1
)/(permitted_alphabet_table_1[0]))

72  
rmd_phab_b_1
[
vue
] - 1;

73 
	}
}

74 
	$a_PER_MAP_RIC_Sty_Name_1_c2v
(
code
) {

75 if(
code
 >(
rmd_phab_code2vue_1
)/(permitted_alphabet_code2value_1[0]))

77  
rmd_phab_code2vue_1
[
code
];

78 
	}
}

83 
a_r_cڡts_t
 
a_PER_ty_RIC_Sty_Name_cڡr_1
 
	gCC_NOTUSED
 = {

84 { 
APC_CONSTRAINED
, 7, 7, 32, 122 } ,

85 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 8, 8, 1, 150 } ,

86 
a_PER_MAP_RIC_Sty_Name_1_v2c
,

87 
a_PER_MAP_RIC_Sty_Name_1_c2v


89 cڡ 
b_v_g_t
 
	ga_DEF_RIC_Sty_Name_gs_1
[] = {

90 (
ASN_TAG_CLASS_UNIVERSAL
 | (19 << 2))

92 
a_TYPE_dest_t
 
	ga_DEF_RIC_Sty_Name
 = {

95 &
a_OP_PrbSg
,

96 
a_DEF_RIC_Sty_Name_gs_1
,

97 (
a_DEF_RIC_Sty_Name_gs_1
)

98 /(
a_DEF_RIC_Sty_Name_gs_1
[0]),

99 
a_DEF_RIC_Sty_Name_gs_1
,

100 (
a_DEF_RIC_Sty_Name_gs_1
)

101 /(
a_DEF_RIC_Sty_Name_gs_1
[0]),

102 { 0, &
a_PER_ty_RIC_Sty_Name_cڡr_1
, 
RIC_Sty_Name_cڡt
 },

	@RIC-Style-Type.c

8 
	~"RIC-Sty-Ty.h
"

14 cڡ 
b_v_g_t
 
	ga_DEF_RIC_Sty_Ty_gs_1
[] = {

15 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

17 
a_TYPE_dest_t
 
	ga_DEF_RIC_Sty_Ty
 = {

20 &
a_OP_NiveIeg
,

21 
a_DEF_RIC_Sty_Ty_gs_1
,

22 (
a_DEF_RIC_Sty_Ty_gs_1
)

23 /(
a_DEF_RIC_Sty_Ty_gs_1
[0]),

24 
a_DEF_RIC_Sty_Ty_gs_1
,

25 (
a_DEF_RIC_Sty_Ty_gs_1
)

26 /(
a_DEF_RIC_Sty_Ty_gs_1
[0]),

27 { 0, 0, 
NiveIeg_cڡt
 },

	@RRC-MessageID.c

8 
	~"RRC-MesgeID.h
"

10 
a_r_cڡts_t
 
a_PER_ty_cTy_cڡr_2
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_cTy_2
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
RRC_MesgeID__cTy
, 
choi
.
lTE
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_RRCass_LTE
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
RRC_MesgeID__cTy
, 
choi
.
nR
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_RRCass_NR
,

35 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_cTy_g2_2
[] = {

36 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

37 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

39 
a_CHOICE_ecifics_t
 
	ga_SPC_cTy_ecs_2
 = {

40 (
RRC_MesgeID__cTy
),

41 
offtof
(
RRC_MesgeID__cTy
, 
_a_x
),

42 
offtof
(
RRC_MesgeID__cTy
, 
e
),

43 (((
RRC_MesgeID__cTy
 *)0)->
e
),

44 
a_MAP_cTy_g2_2
,

50 
a_TYPE_dest_t
 
	ga_DEF_cTy_2
 = {

53 &
a_OP_CHOICE
,

58 { 0, &
a_PER_ty_cTy_cڡr_2
, 
CHOICE_cڡt
 },

59 
a_MBR_cTy_2
,

61 &
a_SPC_cTy_ecs_2


64 
a_TYPE_memb_t
 
	ga_MBR_RRC_MesgeID_1
[] = {

65 { 
ATF_NOFLAGS
, 0, 
offtof
(
RRC_MesgeID
, 
cTy
),

66 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

68 &
a_DEF_cTy_2
,

74 { 
ATF_NOFLAGS
, 0, 
offtof
(
RRC_MesgeID
, 
mesgeID
),

75 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

77 &
a_DEF_NiveIeg
,

84 cڡ 
b_v_g_t
 
	ga_DEF_RRC_MesgeID_gs_1
[] = {

85 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

87 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_RRC_MesgeID_g2_1
[] = {

88 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

89 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

91 
a_SEQUENCE_ecifics_t
 
	ga_SPC_RRC_MesgeID_ecs_1
 = {

92 (
RRC_MesgeID
),

93 
offtof
(
RRC_MesgeID
, 
_a_x
),

94 
a_MAP_RRC_MesgeID_g2_1
,

99 
a_TYPE_dest_t
 
	ga_DEF_RRC_MesgeID
 = {

102 &
a_OP_SEQUENCE
,

103 
a_DEF_RRC_MesgeID_gs_1
,

104 (
a_DEF_RRC_MesgeID_gs_1
)

105 /(
a_DEF_RRC_MesgeID_gs_1
[0]),

106 
a_DEF_RRC_MesgeID_gs_1
,

107 (
a_DEF_RRC_MesgeID_gs_1
)

108 /(
a_DEF_RRC_MesgeID_gs_1
[0]),

109 { 0, 0, 
SEQUENCE_cڡt
 },

110 
a_MBR_RRC_MesgeID_1
,

112 &
a_SPC_RRC_MesgeID_ecs_1


	@RRCclass-LTE.c

8 
	~"RRCass-LTE.h
"

14 
a_r_cڡts_t
 
a_PER_ty_RRCass_LTE_cڡr_1
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 4, 4, 0, 11 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_RRCass_LTE_vue2um_1
[] = {

34 cڡ 
	ga_MAP_RRCass_LTE_um2vue_1
[] = {

49 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_RRCass_LTE_ecs_1
 = {

50 
a_MAP_RRCass_LTE_vue2um_1
,

51 
a_MAP_RRCass_LTE_um2vue_1
,

58 cڡ 
b_v_g_t
 
	ga_DEF_RRCass_LTE_gs_1
[] = {

59 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

61 
a_TYPE_dest_t
 
	ga_DEF_RRCass_LTE
 = {

64 &
a_OP_NiveEnumed
,

65 
a_DEF_RRCass_LTE_gs_1
,

66 (
a_DEF_RRCass_LTE_gs_1
)

67 /(
a_DEF_RRCass_LTE_gs_1
[0]),

68 
a_DEF_RRCass_LTE_gs_1
,

69 (
a_DEF_RRCass_LTE_gs_1
)

70 /(
a_DEF_RRCass_LTE_gs_1
[0]),

71 { 0, &
a_PER_ty_RRCass_LTE_cڡr_1
, 
NiveEnumed_cڡt
 },

73 &
a_SPC_RRCass_LTE_ecs_1


	@RRCclass-NR.c

8 
	~"RRCass-NR.h
"

14 
a_r_cڡts_t
 
a_PER_ty_RRCass_NR_cڡr_1
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 7 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_RRCass_NR_vue2um_1
[] = {

30 cڡ 
	ga_MAP_RRCass_NR_um2vue_1
[] = {

41 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_RRCass_NR_ecs_1
 = {

42 
a_MAP_RRCass_NR_vue2um_1
,

43 
a_MAP_RRCass_NR_um2vue_1
,

50 cڡ 
b_v_g_t
 
	ga_DEF_RRCass_NR_gs_1
[] = {

51 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

53 
a_TYPE_dest_t
 
	ga_DEF_RRCass_NR
 = {

56 &
a_OP_NiveEnumed
,

57 
a_DEF_RRCass_NR_gs_1
,

58 (
a_DEF_RRCass_NR_gs_1
)

59 /(
a_DEF_RRCass_NR_gs_1
[0]),

60 
a_DEF_RRCass_NR_gs_1
,

61 (
a_DEF_RRCass_NR_gs_1
)

62 /(
a_DEF_RRCass_NR_gs_1
[0]),

63 { 0, &
a_PER_ty_RRCass_NR_cڡr_1
, 
NiveEnumed_cڡt
 },

65 &
a_SPC_RRCass_NR_ecs_1


	@S-NSSAI.c

8 
	~"S-NSSAI.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_S_NSSAI_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
S_NSSAI
, 
sST
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_SST
,

20 { 
ATF_POINTER
, 1, 
offtof
(
S_NSSAI
, 
sD
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_SD
,

30 cڡ 
	ga_MAP_S_NSSAI_oms_1
[] = { 1 };

31 cڡ 
b_v_g_t
 
	ga_DEF_S_NSSAI_gs_1
[] = {

32 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

34 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_S_NSSAI_g2_1
[] = {

35 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

36 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

38 
a_SEQUENCE_ecifics_t
 
	ga_SPC_S_NSSAI_ecs_1
 = {

39 (
S_NSSAI
),

40 
offtof
(
S_NSSAI
, 
_a_x
),

41 
a_MAP_S_NSSAI_g2_1
,

43 
a_MAP_S_NSSAI_oms_1
,

47 
a_TYPE_dest_t
 
	ga_DEF_S_NSSAI
 = {

50 &
a_OP_SEQUENCE
,

51 
a_DEF_S_NSSAI_gs_1
,

52 (
a_DEF_S_NSSAI_gs_1
)

53 /(
a_DEF_S_NSSAI_gs_1
[0]),

54 
a_DEF_S_NSSAI_gs_1
,

55 (
a_DEF_S_NSSAI_gs_1
)

56 /(
a_DEF_S_NSSAI_gs_1
[0]),

57 { 0, 0, 
SEQUENCE_cڡt
 },

58 
a_MBR_S_NSSAI_1
,

60 &
a_SPC_S_NSSAI_ecs_1


	@SD.c

8 
	~"SD.h
"

11 
	$SD_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 3)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_SD_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 3, 3 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_SD_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_SD
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_SD_gs_1
,

53 (
a_DEF_SD_gs_1
)

54 /(
a_DEF_SD_gs_1
[0]),

55 
a_DEF_SD_gs_1
,

56 (
a_DEF_SD_gs_1
)

57 /(
a_DEF_SD_gs_1
[0]),

58 { 0, &
a_PER_ty_SD_cڡr_1
, 
SD_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@SST.c

8 
	~"SST.h
"

11 
	$SST_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 1)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_SST_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 1, 1 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_SST_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_SST
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_SST_gs_1
,

53 (
a_DEF_SST_gs_1
)

54 /(
a_DEF_SST_gs_1
[0]),

55 
a_DEF_SST_gs_1
,

56 (
a_DEF_SST_gs_1
)

57 /(
a_DEF_SST_gs_1
[0]),

58 { 0, &
a_PER_ty_SST_cڡr_1
, 
SST_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@ServingCell-ARFCN.c

8 
	~"SvgCl-ARFCN.h
"

10 
	~"NR-ARFCN.h
"

11 
a_r_cڡts_t
 
a_PER_ty_SvgCl_ARFCN_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

13 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

16 
a_TYPE_memb_t
 
	ga_MBR_SvgCl_ARFCN_1
[] = {

17 { 
ATF_POINTER
, 0, 
offtof
(
SvgCl_ARFCN
, 
choi
.
nR
),

18 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

20 &
a_DEF_NR_ARFCN
,

26 { 
ATF_NOFLAGS
, 0, 
offtof
(
SvgCl_ARFCN
, 
choi
.
eUTRA
),

27 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

29 &
a_DEF_E_UTRA_ARFCN
,

36 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_SvgCl_ARFCN_g2_1
[] = {

37 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

38 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

40 
a_CHOICE_ecifics_t
 
	ga_SPC_SvgCl_ARFCN_ecs_1
 = {

41 (
SvgCl_ARFCN
),

42 
offtof
(
SvgCl_ARFCN
, 
_a_x
),

43 
offtof
(
SvgCl_ARFCN
, 
e
),

44 (((
SvgCl_ARFCN
 *)0)->
e
),

45 
a_MAP_SvgCl_ARFCN_g2_1
,

50 
a_TYPE_dest_t
 
	ga_DEF_SvgCl_ARFCN
 = {

53 &
a_OP_CHOICE
,

58 { 0, &
a_PER_ty_SvgCl_ARFCN_cڡr_1
, 
CHOICE_cڡt
 },

59 
a_MBR_SvgCl_ARFCN_1
,

61 &
a_SPC_SvgCl_ARFCN_ecs_1


	@ServingCell-PCI.c

8 
	~"SvgCl-PCI.h
"

10 
a_r_cڡts_t
 
a_PER_ty_SvgCl_PCI_cڡr_1
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 1, 1, 0, 1 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_SvgCl_PCI_1
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
SvgCl_PCI
, 
choi
.
nR
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_NR_PCI
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
SvgCl_PCI
, 
choi
.
eUTRA
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_E_UTRA_PCI
,

35 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_SvgCl_PCI_g2_1
[] = {

36 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

37 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

39 
a_CHOICE_ecifics_t
 
	ga_SPC_SvgCl_PCI_ecs_1
 = {

40 (
SvgCl_PCI
),

41 
offtof
(
SvgCl_PCI
, 
_a_x
),

42 
offtof
(
SvgCl_PCI
, 
e
),

43 (((
SvgCl_PCI
 *)0)->
e
),

44 
a_MAP_SvgCl_PCI_g2_1
,

49 
a_TYPE_dest_t
 
	ga_DEF_SvgCl_PCI
 = {

52 &
a_OP_CHOICE
,

57 { 0, &
a_PER_ty_SvgCl_PCI_cڡr_1
, 
CHOICE_cڡt
 },

58 
a_MBR_SvgCl_PCI_1
,

60 &
a_SPC_SvgCl_PCI_ecs_1


	@SubscriberProfileIDforRFP.c

8 
	~"SubsibProfeIDfRFP.h
"

11 
	$SubsibProfeIDfRFP_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 256)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

39 
a_r_cڡts_t
 
a_PER_ty_SubsibProfeIDfRFP_cڡr_1
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
, 8, 8, 1, 256 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 cڡ 
b_v_g_t
 
	ga_DEF_SubsibProfeIDfRFP_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (2 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_SubsibProfeIDfRFP
 = {

50 &
a_OP_NiveIeg
,

51 
a_DEF_SubsibProfeIDfRFP_gs_1
,

52 (
a_DEF_SubsibProfeIDfRFP_gs_1
)

53 /(
a_DEF_SubsibProfeIDfRFP_gs_1
[0]),

54 
a_DEF_SubsibProfeIDfRFP_gs_1
,

55 (
a_DEF_SubsibProfeIDfRFP_gs_1
)

56 /(
a_DEF_SubsibProfeIDfRFP_gs_1
[0]),

57 { 0, &
a_PER_ty_SubsibProfeIDfRFP_cڡr_1
, 
SubsibProfeIDfRFP_cڡt
 },

	@SupportedSULBandList.c

8 
	~"Su܋dSULBdLi.h
"

10 
	~"Su܋dSULFqBdIm.h
"

11 
a_r_cڡts_t
 
a_PER_ty_Su܋dSULBdLi_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 6, 6, 0, 32 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_Su܋dSULBdLi_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_Su܋dSULFqBdIm
,

27 cڡ 
b_v_g_t
 
	ga_DEF_Su܋dSULBdLi_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_Su܋dSULBdLi_ecs_1
 = {

31 (
Su܋dSULBdLi
),

32 
offtof
(
Su܋dSULBdLi
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_Su܋dSULBdLi
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_Su܋dSULBdLi_gs_1
,

40 (
a_DEF_Su܋dSULBdLi_gs_1
)

41 /(
a_DEF_Su܋dSULBdLi_gs_1
[0]),

42 
a_DEF_Su܋dSULBdLi_gs_1
,

43 (
a_DEF_Su܋dSULBdLi_gs_1
)

44 /(
a_DEF_Su܋dSULBdLi_gs_1
[0]),

45 { 0, &
a_PER_ty_Su܋dSULBdLi_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_Su܋dSULBdLi_1
,

48 &
a_SPC_Su܋dSULBdLi_ecs_1


	@SupportedSULFreqBandItem.c

8 
	~"Su܋dSULFqBdIm.h
"

11 
	$memb_eqBdInditNr_cڡt_1
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 
vue
;

15 if(!

) {

16 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

18 
td
->
me
, 
__FILE__
, 
__LINE__
);

22 
vue
 = *(cڡ *)

;

24 if((
vue
 >= 1 && value <= 1024)) {

28 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

30 
td
->
me
, 
__FILE__
, 
__LINE__
);

33 
	}
}

35 
a_r_cڡts_t
 
a_PER_memb_eqBdInditNr_cڡr_2
 
	gCC_NOTUSED
 = {

36 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 10, 10, 1, 1024 } ,

37 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

40 
a_TYPE_memb_t
 
	ga_MBR_Su܋dSULFqBdIm_1
[] = {

41 { 
ATF_NOFLAGS
, 0, 
offtof
(
Su܋dSULFqBdIm
, 
eqBdInditNr
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

44 &
a_DEF_NiveIeg
,

46 { 0, &
a_PER_memb_eqBdInditNr_cڡr_2
, 
memb_eqBdInditNr_cڡt_1
 },

51 cڡ 
b_v_g_t
 
	ga_DEF_Su܋dSULFqBdIm_gs_1
[] = {

52 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

54 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_Su܋dSULFqBdIm_g2_1
[] = {

55 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

57 
a_SEQUENCE_ecifics_t
 
	ga_SPC_Su܋dSULFqBdIm_ecs_1
 = {

58 (
Su܋dSULFqBdIm
),

59 
offtof
(
Su܋dSULFqBdIm
, 
_a_x
),

60 
a_MAP_Su܋dSULFqBdIm_g2_1
,

65 
a_TYPE_dest_t
 
	ga_DEF_Su܋dSULFqBdIm
 = {

68 &
a_OP_SEQUENCE
,

69 
a_DEF_Su܋dSULFqBdIm_gs_1
,

70 (
a_DEF_Su܋dSULFqBdIm_gs_1
)

71 /(
a_DEF_Su܋dSULFqBdIm_gs_1
[0]),

72 
a_DEF_Su܋dSULFqBdIm_gs_1
,

73 (
a_DEF_Su܋dSULFqBdIm_gs_1
)

74 /(
a_DEF_Su܋dSULFqBdIm_gs_1
[0]),

75 { 0, 0, 
SEQUENCE_cڡt
 },

76 
a_MBR_Su܋dSULFqBdIm_1
,

78 &
a_SPC_Su܋dSULFqBdIm_ecs_1


	@TestCond-Expression.c

8 
	~"TeCd-Exessi.h
"

14 
a_r_cڡts_t
 
a_PER_ty_TeCd_Exessi_cڡr_1
 
	gCC_NOTUSED
 = {

15 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 4 } ,

16 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

19 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_TeCd_Exessi_vue2um_1
[] = {

27 cڡ 
	ga_MAP_TeCd_Exessi_um2vue_1
[] = {

35 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_TeCd_Exessi_ecs_1
 = {

36 
a_MAP_TeCd_Exessi_vue2um_1
,

37 
a_MAP_TeCd_Exessi_um2vue_1
,

44 cڡ 
b_v_g_t
 
	ga_DEF_TeCd_Exessi_gs_1
[] = {

45 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

47 
a_TYPE_dest_t
 
	ga_DEF_TeCd_Exessi
 = {

50 &
a_OP_NiveEnumed
,

51 
a_DEF_TeCd_Exessi_gs_1
,

52 (
a_DEF_TeCd_Exessi_gs_1
)

53 /(
a_DEF_TeCd_Exessi_gs_1
[0]),

54 
a_DEF_TeCd_Exessi_gs_1
,

55 (
a_DEF_TeCd_Exessi_gs_1
)

56 /(
a_DEF_TeCd_Exessi_gs_1
[0]),

57 { 0, &
a_PER_ty_TeCd_Exessi_cڡr_1
, 
NiveEnumed_cڡt
 },

59 &
a_SPC_TeCd_Exessi_ecs_1


	@TestCond-Type.c

8 
	~"TeCd-Ty.h
"

34 
a_r_cڡts_t
 
a_PER_ty_gBR_cڡr_2
 
	gCC_NOTUSED
 = {

35 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

36 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

39 
a_r_cڡts_t
 
a_PER_ty_aMBR_cڡr_5
 
	gCC_NOTUSED
 = {

40 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

44 
a_r_cڡts_t
 
a_PER_ty_isSt_cڡr_8
 
	gCC_NOTUSED
 = {

45 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

46 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

49 
a_r_cڡts_t
 
a_PER_ty_isCM_cڡr_11
 
	gCC_NOTUSED
 = {

50 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

51 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

54 
a_r_cڡts_t
 
a_PER_ty_rSRP_cڡr_14
 
	gCC_NOTUSED
 = {

55 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

56 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

59 
a_r_cڡts_t
 
a_PER_ty_rSRQ_cڡr_17
 
	gCC_NOTUSED
 = {

60 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 0, 0, 0, 0 } ,

61 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

64 
a_r_cڡts_t
 
a_PER_ty_TeCd_Ty_cڡr_1
 
	gCC_NOTUSED
 = {

65 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 5 } ,

66 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

69 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_gBR_vue2um_2
[] = {

73 cڡ 
	ga_MAP_gBR_um2vue_2
[] = {

77 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_gBR_ecs_2
 = {

78 
a_MAP_gBR_vue2um_2
,

79 
a_MAP_gBR_um2vue_2
,

86 cڡ 
b_v_g_t
 
	ga_DEF_gBR_gs_2
[] = {

87 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

88 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

91 
a_TYPE_dest_t
 
	ga_DEF_gBR_2
 = {

94 &
a_OP_NiveEnumed
,

95 
a_DEF_gBR_gs_2
,

96 (
a_DEF_gBR_gs_2
)

97 /(
a_DEF_gBR_gs_2
[0]) - 1,

98 
a_DEF_gBR_gs_2
,

99 (
a_DEF_gBR_gs_2
)

100 /(
a_DEF_gBR_gs_2
[0]),

101 { 0, &
a_PER_ty_gBR_cڡr_2
, 
NiveEnumed_cڡt
 },

103 &
a_SPC_gBR_ecs_2


106 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_aMBR_vue2um_5
[] = {

110 cڡ 
	ga_MAP_aMBR_um2vue_5
[] = {

114 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_aMBR_ecs_5
 = {

115 
a_MAP_aMBR_vue2um_5
,

116 
a_MAP_aMBR_um2vue_5
,

123 cڡ 
b_v_g_t
 
	ga_DEF_aMBR_gs_5
[] = {

124 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

125 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

128 
a_TYPE_dest_t
 
	ga_DEF_aMBR_5
 = {

131 &
a_OP_NiveEnumed
,

132 
a_DEF_aMBR_gs_5
,

133 (
a_DEF_aMBR_gs_5
)

134 /(
a_DEF_aMBR_gs_5
[0]) - 1,

135 
a_DEF_aMBR_gs_5
,

136 (
a_DEF_aMBR_gs_5
)

137 /(
a_DEF_aMBR_gs_5
[0]),

138 { 0, &
a_PER_ty_aMBR_cڡr_5
, 
NiveEnumed_cڡt
 },

140 &
a_SPC_aMBR_ecs_5


143 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_isSt_vue2um_8
[] = {

147 cڡ 
	ga_MAP_isSt_um2vue_8
[] = {

151 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_isSt_ecs_8
 = {

152 
a_MAP_isSt_vue2um_8
,

153 
a_MAP_isSt_um2vue_8
,

160 cڡ 
b_v_g_t
 
	ga_DEF_isSt_gs_8
[] = {

161 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

162 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

165 
a_TYPE_dest_t
 
	ga_DEF_isSt_8
 = {

168 &
a_OP_NiveEnumed
,

169 
a_DEF_isSt_gs_8
,

170 (
a_DEF_isSt_gs_8
)

171 /(
a_DEF_isSt_gs_8
[0]) - 1,

172 
a_DEF_isSt_gs_8
,

173 (
a_DEF_isSt_gs_8
)

174 /(
a_DEF_isSt_gs_8
[0]),

175 { 0, &
a_PER_ty_isSt_cڡr_8
, 
NiveEnumed_cڡt
 },

177 &
a_SPC_isSt_ecs_8


180 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_isCM_vue2um_11
[] = {

184 cڡ 
	ga_MAP_isCM_um2vue_11
[] = {

188 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_isCM_ecs_11
 = {

189 
a_MAP_isCM_vue2um_11
,

190 
a_MAP_isCM_um2vue_11
,

197 cڡ 
b_v_g_t
 
	ga_DEF_isCM_gs_11
[] = {

198 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

199 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

202 
a_TYPE_dest_t
 
	ga_DEF_isCM_11
 = {

205 &
a_OP_NiveEnumed
,

206 
a_DEF_isCM_gs_11
,

207 (
a_DEF_isCM_gs_11
)

208 /(
a_DEF_isCM_gs_11
[0]) - 1,

209 
a_DEF_isCM_gs_11
,

210 (
a_DEF_isCM_gs_11
)

211 /(
a_DEF_isCM_gs_11
[0]),

212 { 0, &
a_PER_ty_isCM_cڡr_11
, 
NiveEnumed_cڡt
 },

214 &
a_SPC_isCM_ecs_11


217 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_rSRP_vue2um_14
[] = {

221 cڡ 
	ga_MAP_rSRP_um2vue_14
[] = {

225 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_rSRP_ecs_14
 = {

226 
a_MAP_rSRP_vue2um_14
,

227 
a_MAP_rSRP_um2vue_14
,

234 cڡ 
b_v_g_t
 
	ga_DEF_rSRP_gs_14
[] = {

235 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

236 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

239 
a_TYPE_dest_t
 
	ga_DEF_rSRP_14
 = {

242 &
a_OP_NiveEnumed
,

243 
a_DEF_rSRP_gs_14
,

244 (
a_DEF_rSRP_gs_14
)

245 /(
a_DEF_rSRP_gs_14
[0]) - 1,

246 
a_DEF_rSRP_gs_14
,

247 (
a_DEF_rSRP_gs_14
)

248 /(
a_DEF_rSRP_gs_14
[0]),

249 { 0, &
a_PER_ty_rSRP_cڡr_14
, 
NiveEnumed_cڡt
 },

251 &
a_SPC_rSRP_ecs_14


254 cڡ 
a_INTEGER_um_m_t
 
	ga_MAP_rSRQ_vue2um_17
[] = {

258 cڡ 
	ga_MAP_rSRQ_um2vue_17
[] = {

262 cڡ 
a_INTEGER_ecifics_t
 
	ga_SPC_rSRQ_ecs_17
 = {

263 
a_MAP_rSRQ_vue2um_17
,

264 
a_MAP_rSRQ_um2vue_17
,

271 cڡ 
b_v_g_t
 
	ga_DEF_rSRQ_gs_17
[] = {

272 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

273 (
ASN_TAG_CLASS_UNIVERSAL
 | (10 << 2))

276 
a_TYPE_dest_t
 
	ga_DEF_rSRQ_17
 = {

279 &
a_OP_NiveEnumed
,

280 
a_DEF_rSRQ_gs_17
,

281 (
a_DEF_rSRQ_gs_17
)

282 /(
a_DEF_rSRQ_gs_17
[0]) - 1,

283 
a_DEF_rSRQ_gs_17
,

284 (
a_DEF_rSRQ_gs_17
)

285 /(
a_DEF_rSRQ_gs_17
[0]),

286 { 0, &
a_PER_ty_rSRQ_cڡr_17
, 
NiveEnumed_cڡt
 },

288 &
a_SPC_rSRQ_ecs_17


291 
a_TYPE_memb_t
 
	ga_MBR_TeCd_Ty_1
[] = {

292 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
gBR
),

293 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

295 &
a_DEF_gBR_2
,

301 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
aMBR
),

302 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

304 &
a_DEF_aMBR_5
,

310 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
isSt
),

311 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

313 &
a_DEF_isSt_8
,

319 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
isCM
),

320 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

322 &
a_DEF_isCM_11
,

328 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
rSRP
),

329 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

331 &
a_DEF_rSRP_14
,

337 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Ty
, 
choi
.
rSRQ
),

338 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

340 &
a_DEF_rSRQ_17
,

347 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_TeCd_Ty_g2_1
[] = {

348 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

349 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

350 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

351 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

352 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

353 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 }

355 
a_CHOICE_ecifics_t
 
	ga_SPC_TeCd_Ty_ecs_1
 = {

356 (
TeCd_Ty
),

357 
offtof
(
TeCd_Ty
, 
_a_x
),

358 
offtof
(
TeCd_Ty
, 
e
),

359 (((
TeCd_Ty
 *)0)->
e
),

360 
a_MAP_TeCd_Ty_g2_1
,

365 
a_TYPE_dest_t
 
	ga_DEF_TeCd_Ty
 = {

368 &
a_OP_CHOICE
,

373 { 0, &
a_PER_ty_TeCd_Ty_cڡr_1
, 
CHOICE_cڡt
 },

374 
a_MBR_TeCd_Ty_1
,

376 &
a_SPC_TeCd_Ty_ecs_1


	@TestCond-Value.c

8 
	~"TeCd-Vue.h
"

10 
a_r_cڡts_t
 
a_PER_ty_TeCd_Vue_cڡr_1
 
	gCC_NOTUSED
 = {

11 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 5 } ,

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

15 
a_TYPE_memb_t
 
	ga_MBR_TeCd_Vue_1
[] = {

16 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vueI
),

17 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

19 &
a_DEF_NiveIeg
,

25 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vueEnum
),

26 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

28 &
a_DEF_NiveIeg
,

34 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vueBo
),

35 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

37 &
a_DEF_BOOLEAN
,

43 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vueBS
),

44 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

46 &
a_DEF_BIT_STRING
,

52 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vueOS
),

53 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

55 &
a_DEF_OCTET_STRING
,

61 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCd_Vue
, 
choi
.
vuePS
),

62 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

64 &
a_DEF_PrbSg
,

71 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_TeCd_Vue_g2_1
[] = {

72 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

73 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

74 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

75 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

76 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

77 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 }

79 
a_CHOICE_ecifics_t
 
	ga_SPC_TeCd_Vue_ecs_1
 = {

80 (
TeCd_Vue
),

81 
offtof
(
TeCd_Vue
, 
_a_x
),

82 
offtof
(
TeCd_Vue
, 
e
),

83 (((
TeCd_Vue
 *)0)->
e
),

84 
a_MAP_TeCd_Vue_g2_1
,

89 
a_TYPE_dest_t
 
	ga_DEF_TeCd_Vue
 = {

92 &
a_OP_CHOICE
,

97 { 0, &
a_PER_ty_TeCd_Vue_cڡr_1
, 
CHOICE_cڡt
 },

98 
a_MBR_TeCd_Vue_1
,

100 &
a_SPC_TeCd_Vue_ecs_1


	@TestCondInfo.c

8 
	~"TeCdInfo.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_TeCdInfo_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCdInfo
, 
Ty
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_TeCd_Ty
,

20 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCdInfo
, 
Ex
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_TeCd_Exessi
,

29 { 
ATF_NOFLAGS
, 0, 
offtof
(
TeCdInfo
, 
Vue
),

30 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

32 &
a_DEF_TeCd_Vue
,

39 cڡ 
b_v_g_t
 
	ga_DEF_TeCdInfo_gs_1
[] = {

40 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

42 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_TeCdInfo_g2_1
[] = {

43 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

44 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

45 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 }

47 
a_SEQUENCE_ecifics_t
 
	ga_SPC_TeCdInfo_ecs_1
 = {

48 (
TeCdInfo
),

49 
offtof
(
TeCdInfo
, 
_a_x
),

50 
a_MAP_TeCdInfo_g2_1
,

55 
a_TYPE_dest_t
 
	ga_DEF_TeCdInfo
 = {

58 &
a_OP_SEQUENCE
,

59 
a_DEF_TeCdInfo_gs_1
,

60 (
a_DEF_TeCdInfo_gs_1
)

61 /(
a_DEF_TeCdInfo_gs_1
[0]),

62 
a_DEF_TeCdInfo_gs_1
,

63 (
a_DEF_TeCdInfo_gs_1
)

64 /(
a_DEF_TeCdInfo_gs_1
[0]),

65 { 0, 0, 
SEQUENCE_cڡt
 },

66 
a_MBR_TeCdInfo_1
,

68 &
a_SPC_TeCdInfo_ecs_1


	@TimeStamp.c

8 
	~"TimeSmp.h
"

11 
	$TimeSmp_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

12 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

13 cڡ 
OCTET_STRING_t
 *

 = (cڡ OCTET_STRING_*)

;

14 
size_t
 
size
;

16 if(!

) {

17 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

19 
td
->
me
, 
__FILE__
, 
__LINE__
);

23 
size
 = 

->size;

25 if((
size
 == 4)) {

29 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

31 
td
->
me
, 
__FILE__
, 
__LINE__
);

34 
	}
}

40 
a_r_cڡts_t
 
a_PER_ty_TimeSmp_cڡr_1
 
	gCC_NOTUSED
 = {

41 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

42 { 
APC_CONSTRAINED
, 0, 0, 4, 4 } ,

45 cڡ 
b_v_g_t
 
	ga_DEF_TimeSmp_gs_1
[] = {

46 (
ASN_TAG_CLASS_UNIVERSAL
 | (4 << 2))

48 
a_TYPE_dest_t
 
	ga_DEF_TimeSmp
 = {

51 &
a_OP_OCTET_STRING
,

52 
a_DEF_TimeSmp_gs_1
,

53 (
a_DEF_TimeSmp_gs_1
)

54 /(
a_DEF_TimeSmp_gs_1
[0]),

55 
a_DEF_TimeSmp_gs_1
,

56 (
a_DEF_TimeSmp_gs_1
)

57 /(
a_DEF_TimeSmp_gs_1
[0]),

58 { 0, &
a_PER_ty_TimeSmp_cڡr_1
, 
TimeSmp_cڡt
 },

60 &
a_SPC_OCTET_STRING_ecs


	@UEID-EN-GNB.c

8 
	~"UEID-EN-GNB.h
"

10 
	~"UEID-GNB-CU-CP-E1AP-ID-Li.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_UEID_EN_GNB_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_EN_GNB
, 
m_eNB_UE_X2AP_ID
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_ENB_UE_X2AP_ID
,

21 { 
ATF_POINTER
, 1, 
offtof
(
UEID_EN_GNB
, 
m_eNB_UE_X2AP_ID_Exnsi
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_ENB_UE_X2AP_ID_Exnsi
,

30 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_EN_GNB
, 
globENB_ID
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_GlobENB_ID
,

39 { 
ATF_POINTER
, 3, 
offtof
(
UEID_EN_GNB
, 
gNB_CU_UE_F1AP_ID
),

40 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

42 &
a_DEF_GNB_CU_UE_F1AP_ID
,

48 { 
ATF_POINTER
, 2, 
offtof
(
UEID_EN_GNB
, 
gNB_CU_CP_UE_E1AP_ID_Li
),

49 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

51 &
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li
,

57 { 
ATF_POINTER
, 1, 
offtof
(
UEID_EN_GNB
, 
n_UEID
),

58 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

60 &
a_DEF_RANUEID
,

67 cڡ 
	ga_MAP_UEID_EN_GNB_oms_1
[] = { 1, 3, 4, 5 };

68 cڡ 
b_v_g_t
 
	ga_DEF_UEID_EN_GNB_gs_1
[] = {

69 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

71 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_EN_GNB_g2_1
[] = {

72 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

73 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

74 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

75 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

76 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

77 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 }

79 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_EN_GNB_ecs_1
 = {

80 (
UEID_EN_GNB
),

81 
offtof
(
UEID_EN_GNB
, 
_a_x
),

82 
a_MAP_UEID_EN_GNB_g2_1
,

84 
a_MAP_UEID_EN_GNB_oms_1
,

88 
a_TYPE_dest_t
 
	ga_DEF_UEID_EN_GNB
 = {

91 &
a_OP_SEQUENCE
,

92 
a_DEF_UEID_EN_GNB_gs_1
,

93 (
a_DEF_UEID_EN_GNB_gs_1
)

94 /(
a_DEF_UEID_EN_GNB_gs_1
[0]),

95 
a_DEF_UEID_EN_GNB_gs_1
,

96 (
a_DEF_UEID_EN_GNB_gs_1
)

97 /(
a_DEF_UEID_EN_GNB_gs_1
[0]),

98 { 0, 0, 
SEQUENCE_cڡt
 },

99 
a_MBR_UEID_EN_GNB_1
,

101 &
a_SPC_UEID_EN_GNB_ecs_1


	@UEID-ENB.c

8 
	~"UEID-ENB.h
"

10 
	~"GlobENB-ID.h
"

11 
a_TYPE_memb_t
 
	ga_MBR_UEID_ENB_1
[] = {

12 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_ENB
, 
mME_UE_S1AP_ID
),

13 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

15 &
a_DEF_MME_UE_S1AP_ID
,

21 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_ENB
, 
gUMMEI
),

22 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

24 &
a_DEF_GUMMEI
,

30 { 
ATF_POINTER
, 3, 
offtof
(
UEID_ENB
, 
m_eNB_UE_X2AP_ID
),

31 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

33 &
a_DEF_ENB_UE_X2AP_ID
,

39 { 
ATF_POINTER
, 2, 
offtof
(
UEID_ENB
, 
m_eNB_UE_X2AP_ID_Exnsi
),

40 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

42 &
a_DEF_ENB_UE_X2AP_ID_Exnsi
,

48 { 
ATF_POINTER
, 1, 
offtof
(
UEID_ENB
, 
globENB_ID
),

49 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

51 &
a_DEF_GlobENB_ID
,

58 cڡ 
	ga_MAP_UEID_ENB_oms_1
[] = { 2, 3, 4 };

59 cڡ 
b_v_g_t
 
	ga_DEF_UEID_ENB_gs_1
[] = {

60 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

62 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_ENB_g2_1
[] = {

63 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

64 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

65 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

66 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

67 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 }

69 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_ENB_ecs_1
 = {

70 (
UEID_ENB
),

71 
offtof
(
UEID_ENB
, 
_a_x
),

72 
a_MAP_UEID_ENB_g2_1
,

74 
a_MAP_UEID_ENB_oms_1
,

78 
a_TYPE_dest_t
 
	ga_DEF_UEID_ENB
 = {

81 &
a_OP_SEQUENCE
,

82 
a_DEF_UEID_ENB_gs_1
,

83 (
a_DEF_UEID_ENB_gs_1
)

84 /(
a_DEF_UEID_ENB_gs_1
[0]),

85 
a_DEF_UEID_ENB_gs_1
,

86 (
a_DEF_UEID_ENB_gs_1
)

87 /(
a_DEF_UEID_ENB_gs_1
[0]),

88 { 0, 0, 
SEQUENCE_cڡt
 },

89 
a_MBR_UEID_ENB_1
,

91 &
a_SPC_UEID_ENB_ecs_1


	@UEID-GNB-CU-CP-E1AP-ID-Item.c

8 
	~"UEID-GNB-CU-CP-E1AP-ID-Im.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_CU_CP_E1AP_ID_Im_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB_CU_CP_E1AP_ID_Im
, 
gNB_CU_CP_UE_E1AP_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GNB_CU_CP_UE_E1AP_ID
,

21 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_GNB_CU_CP_E1AP_ID_Im_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_GNB_CU_CP_E1AP_ID_Im_ecs_1
 = {

28 (
UEID_GNB_CU_CP_E1AP_ID_Im
),

29 
offtof
(
UEID_GNB_CU_CP_E1AP_ID_Im
, 
_a_x
),

30 
a_MAP_UEID_GNB_CU_CP_E1AP_ID_Im_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_CU_CP_E1AP_ID_Im
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
,

40 (
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
)

41 /(
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
[0]),

42 
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
,

43 (
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
)

44 /(
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_UEID_GNB_CU_CP_E1AP_ID_Im_1
,

48 &
a_SPC_UEID_GNB_CU_CP_E1AP_ID_Im_ecs_1


	@UEID-GNB-CU-CP-E1AP-ID-List.c

8 
	~"UEID-GNB-CU-CP-E1AP-ID-Li.h
"

10 
	~"UEID-GNB-CU-CP-E1AP-ID-Im.h
"

11 
a_r_cڡts_t
 
a_PER_ty_UEID_GNB_CU_CP_E1AP_ID_Li_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 16, 16, 1, 65535 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_CU_CP_E1AP_ID_Li_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Im
,

27 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_UEID_GNB_CU_CP_E1AP_ID_Li_ecs_1
 = {

31 (
UEID_GNB_CU_CP_E1AP_ID_Li
),

32 
offtof
(
UEID_GNB_CU_CP_E1AP_ID_Li
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_CU_CP_E1AP_ID_Li
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
,

40 (
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
)

41 /(
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
[0]),

42 
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
,

43 (
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
)

44 /(
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li_gs_1
[0]),

45 { 0, &
a_PER_ty_UEID_GNB_CU_CP_E1AP_ID_Li_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_UEID_GNB_CU_CP_E1AP_ID_Li_1
,

48 &
a_SPC_UEID_GNB_CU_CP_E1AP_ID_Li_ecs_1


	@UEID-GNB-CU-CP-F1AP-ID-Item.c

8 
	~"UEID-GNB-CU-CP-F1AP-ID-Im.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_CU_CP_F1AP_ID_Im_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB_CU_CP_F1AP_ID_Im
, 
gNB_CU_UE_F1AP_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GNB_CU_UE_F1AP_ID
,

21 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_GNB_CU_CP_F1AP_ID_Im_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_GNB_CU_CP_F1AP_ID_Im_ecs_1
 = {

28 (
UEID_GNB_CU_CP_F1AP_ID_Im
),

29 
offtof
(
UEID_GNB_CU_CP_F1AP_ID_Im
, 
_a_x
),

30 
a_MAP_UEID_GNB_CU_CP_F1AP_ID_Im_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_CU_CP_F1AP_ID_Im
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
,

40 (
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
)

41 /(
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
[0]),

42 
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
,

43 (
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
)

44 /(
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_UEID_GNB_CU_CP_F1AP_ID_Im_1
,

48 &
a_SPC_UEID_GNB_CU_CP_F1AP_ID_Im_ecs_1


	@UEID-GNB-CU-F1AP-ID-List.c

8 
	~"UEID-GNB-CU-F1AP-ID-Li.h
"

10 
	~"UEID-GNB-CU-CP-F1AP-ID-Im.h
"

11 
a_r_cڡts_t
 
a_PER_ty_UEID_GNB_CU_F1AP_ID_Li_cڡr_1
 
	gCC_NOTUSED
 = {

12 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

13 { 
APC_CONSTRAINED
, 2, 2, 1, 4 } ,

16 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_CU_F1AP_ID_Li_1
[] = {

17 { 
ATF_POINTER
, 0, 0,

18 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2)),

20 &
a_DEF_UEID_GNB_CU_CP_F1AP_ID_Im
,

27 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
[] = {

28 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

30 
a_SET_OF_ecifics_t
 
	ga_SPC_UEID_GNB_CU_F1AP_ID_Li_ecs_1
 = {

31 (
UEID_GNB_CU_F1AP_ID_Li
),

32 
offtof
(
UEID_GNB_CU_F1AP_ID_Li
, 
_a_x
),

35 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_CU_F1AP_ID_Li
 = {

38 &
a_OP_SEQUENCE_OF
,

39 
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
,

40 (
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
)

41 /(
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
[0]),

42 
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
,

43 (
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
)

44 /(
a_DEF_UEID_GNB_CU_F1AP_ID_Li_gs_1
[0]),

45 { 0, &
a_PER_ty_UEID_GNB_CU_F1AP_ID_Li_cڡr_1
, 
SEQUENCE_OF_cڡt
 },

46 
a_MBR_UEID_GNB_CU_F1AP_ID_Li_1
,

48 &
a_SPC_UEID_GNB_CU_F1AP_ID_Li_ecs_1


	@UEID-GNB-CU-UP.c

8 
	~"UEID-GNB-CU-UP.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_CU_UP_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB_CU_UP
, 
gNB_CU_CP_UE_E1AP_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GNB_CU_CP_UE_E1AP_ID
,

20 { 
ATF_POINTER
, 1, 
offtof
(
UEID_GNB_CU_UP
, 
n_UEID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_RANUEID
,

30 cڡ 
	ga_MAP_UEID_GNB_CU_UP_oms_1
[] = { 1 };

31 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_CU_UP_gs_1
[] = {

32 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

34 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_GNB_CU_UP_g2_1
[] = {

35 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

36 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

38 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_GNB_CU_UP_ecs_1
 = {

39 (
UEID_GNB_CU_UP
),

40 
offtof
(
UEID_GNB_CU_UP
, 
_a_x
),

41 
a_MAP_UEID_GNB_CU_UP_g2_1
,

43 
a_MAP_UEID_GNB_CU_UP_oms_1
,

47 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_CU_UP
 = {

50 &
a_OP_SEQUENCE
,

51 
a_DEF_UEID_GNB_CU_UP_gs_1
,

52 (
a_DEF_UEID_GNB_CU_UP_gs_1
)

53 /(
a_DEF_UEID_GNB_CU_UP_gs_1
[0]),

54 
a_DEF_UEID_GNB_CU_UP_gs_1
,

55 (
a_DEF_UEID_GNB_CU_UP_gs_1
)

56 /(
a_DEF_UEID_GNB_CU_UP_gs_1
[0]),

57 { 0, 0, 
SEQUENCE_cڡt
 },

58 
a_MBR_UEID_GNB_CU_UP_1
,

60 &
a_SPC_UEID_GNB_CU_UP_ecs_1


	@UEID-GNB-DU.c

8 
	~"UEID-GNB-DU.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_DU_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB_DU
, 
gNB_CU_UE_F1AP_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_GNB_CU_UE_F1AP_ID
,

20 { 
ATF_POINTER
, 1, 
offtof
(
UEID_GNB_DU
, 
n_UEID
),

21 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

23 &
a_DEF_RANUEID
,

30 cڡ 
	ga_MAP_UEID_GNB_DU_oms_1
[] = { 1 };

31 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_DU_gs_1
[] = {

32 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

34 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_GNB_DU_g2_1
[] = {

35 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

36 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 }

38 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_GNB_DU_ecs_1
 = {

39 (
UEID_GNB_DU
),

40 
offtof
(
UEID_GNB_DU
, 
_a_x
),

41 
a_MAP_UEID_GNB_DU_g2_1
,

43 
a_MAP_UEID_GNB_DU_oms_1
,

47 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB_DU
 = {

50 &
a_OP_SEQUENCE
,

51 
a_DEF_UEID_GNB_DU_gs_1
,

52 (
a_DEF_UEID_GNB_DU_gs_1
)

53 /(
a_DEF_UEID_GNB_DU_gs_1
[0]),

54 
a_DEF_UEID_GNB_DU_gs_1
,

55 (
a_DEF_UEID_GNB_DU_gs_1
)

56 /(
a_DEF_UEID_GNB_DU_gs_1
[0]),

57 { 0, 0, 
SEQUENCE_cڡt
 },

58 
a_MBR_UEID_GNB_DU_1
,

60 &
a_SPC_UEID_GNB_DU_ecs_1


	@UEID-GNB.c

8 
	~"UEID-GNB.h
"

10 
	~"UEID-GNB-CU-F1AP-ID-Li.h
"

11 
	~"UEID-GNB-CU-CP-E1AP-ID-Li.h
"

12 
	~"GlobGNB-ID.h
"

13 
	~"GlobNGRANNodeID.h
"

14 
a_TYPE_memb_t
 
	ga_MBR_UEID_GNB_1
[] = {

15 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB
, 
amf_UE_NGAP_ID
),

16 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

18 &
a_DEF_AMF_UE_NGAP_ID
,

24 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_GNB
, 
guami
),

25 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

27 &
a_DEF_GUAMI
,

33 { 
ATF_POINTER
, 6, 
offtof
(
UEID_GNB
, 
gNB_CU_UE_F1AP_ID_Li
),

34 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

36 &
a_DEF_UEID_GNB_CU_F1AP_ID_Li
,

42 { 
ATF_POINTER
, 5, 
offtof
(
UEID_GNB
, 
gNB_CU_CP_UE_E1AP_ID_Li
),

43 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

45 &
a_DEF_UEID_GNB_CU_CP_E1AP_ID_Li
,

51 { 
ATF_POINTER
, 4, 
offtof
(
UEID_GNB
, 
n_UEID
),

52 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

54 &
a_DEF_RANUEID
,

60 { 
ATF_POINTER
, 3, 
offtof
(
UEID_GNB
, 
m_NG_RAN_UE_XnAP_ID
),

61 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

63 &
a_DEF_NG_RANnodeUEXnAPID
,

69 { 
ATF_POINTER
, 2, 
offtof
(
UEID_GNB
, 
globGNB_ID
),

70 (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)),

72 &
a_DEF_GlobGNB_ID
,

78 { 
ATF_POINTER
, 1, 
offtof
(
UEID_GNB
, 
globNG_RANNode_ID
),

79 (
ASN_TAG_CLASS_CONTEXT
 | (7 << 2)),

81 &
a_DEF_GlobNGRANNodeID
,

88 cڡ 
	ga_MAP_UEID_GNB_oms_1
[] = { 2, 3, 4, 5, 6, 7 };

89 cڡ 
b_v_g_t
 
	ga_DEF_UEID_GNB_gs_1
[] = {

90 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

92 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_GNB_g2_1
[] = {

93 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

94 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

95 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

96 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

97 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

98 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 },

99 { (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)), 6, 0, 0 },

100 { (
ASN_TAG_CLASS_CONTEXT
 | (7 << 2)), 7, 0, 0 }

102 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_GNB_ecs_1
 = {

103 (
UEID_GNB
),

104 
offtof
(
UEID_GNB
, 
_a_x
),

105 
a_MAP_UEID_GNB_g2_1
,

107 
a_MAP_UEID_GNB_oms_1
,

111 
a_TYPE_dest_t
 
	ga_DEF_UEID_GNB
 = {

114 &
a_OP_SEQUENCE
,

115 
a_DEF_UEID_GNB_gs_1
,

116 (
a_DEF_UEID_GNB_gs_1
)

117 /(
a_DEF_UEID_GNB_gs_1
[0]),

118 
a_DEF_UEID_GNB_gs_1
,

119 (
a_DEF_UEID_GNB_gs_1
)

120 /(
a_DEF_UEID_GNB_gs_1
[0]),

121 { 0, 0, 
SEQUENCE_cڡt
 },

122 
a_MBR_UEID_GNB_1
,

124 &
a_SPC_UEID_GNB_ecs_1


	@UEID-NG-ENB-DU.c

8 
	~"UEID-NG-ENB-DU.h
"

10 
a_TYPE_memb_t
 
	ga_MBR_UEID_NG_ENB_DU_1
[] = {

11 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_NG_ENB_DU
, 
ng_eNB_CU_UE_W1AP_ID
),

12 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

14 &
a_DEF_NGENB_CU_UE_W1AP_ID
,

21 cڡ 
b_v_g_t
 
	ga_DEF_UEID_NG_ENB_DU_gs_1
[] = {

22 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

24 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_NG_ENB_DU_g2_1
[] = {

25 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 }

27 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_NG_ENB_DU_ecs_1
 = {

28 (
UEID_NG_ENB_DU
),

29 
offtof
(
UEID_NG_ENB_DU
, 
_a_x
),

30 
a_MAP_UEID_NG_ENB_DU_g2_1
,

35 
a_TYPE_dest_t
 
	ga_DEF_UEID_NG_ENB_DU
 = {

38 &
a_OP_SEQUENCE
,

39 
a_DEF_UEID_NG_ENB_DU_gs_1
,

40 (
a_DEF_UEID_NG_ENB_DU_gs_1
)

41 /(
a_DEF_UEID_NG_ENB_DU_gs_1
[0]),

42 
a_DEF_UEID_NG_ENB_DU_gs_1
,

43 (
a_DEF_UEID_NG_ENB_DU_gs_1
)

44 /(
a_DEF_UEID_NG_ENB_DU_gs_1
[0]),

45 { 0, 0, 
SEQUENCE_cڡt
 },

46 
a_MBR_UEID_NG_ENB_DU_1
,

48 &
a_SPC_UEID_NG_ENB_DU_ecs_1


	@UEID-NG-ENB.c

8 
	~"UEID-NG-ENB.h
"

10 
	~"GlobNgENB-ID.h
"

11 
	~"GlobNGRANNodeID.h
"

12 
a_TYPE_memb_t
 
	ga_MBR_UEID_NG_ENB_1
[] = {

13 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_NG_ENB
, 
amf_UE_NGAP_ID
),

14 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

16 &
a_DEF_AMF_UE_NGAP_ID
,

22 { 
ATF_NOFLAGS
, 0, 
offtof
(
UEID_NG_ENB
, 
guami
),

23 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

25 &
a_DEF_GUAMI
,

31 { 
ATF_POINTER
, 4, 
offtof
(
UEID_NG_ENB
, 
ng_eNB_CU_UE_W1AP_ID
),

32 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

34 &
a_DEF_NGENB_CU_UE_W1AP_ID
,

40 { 
ATF_POINTER
, 3, 
offtof
(
UEID_NG_ENB
, 
m_NG_RAN_UE_XnAP_ID
),

41 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

43 &
a_DEF_NG_RANnodeUEXnAPID
,

49 { 
ATF_POINTER
, 2, 
offtof
(
UEID_NG_ENB
, 
globNgENB_ID
),

50 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

52 &
a_DEF_GlobNgENB_ID
,

58 { 
ATF_POINTER
, 1, 
offtof
(
UEID_NG_ENB
, 
globNG_RANNode_ID
),

59 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

61 &
a_DEF_GlobNGRANNodeID
,

68 cڡ 
	ga_MAP_UEID_NG_ENB_oms_1
[] = { 2, 3, 4, 5 };

69 cڡ 
b_v_g_t
 
	ga_DEF_UEID_NG_ENB_gs_1
[] = {

70 (
ASN_TAG_CLASS_UNIVERSAL
 | (16 << 2))

72 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_NG_ENB_g2_1
[] = {

73 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

74 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

75 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

76 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

77 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

78 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 }

80 
a_SEQUENCE_ecifics_t
 
	ga_SPC_UEID_NG_ENB_ecs_1
 = {

81 (
UEID_NG_ENB
),

82 
offtof
(
UEID_NG_ENB
, 
_a_x
),

83 
a_MAP_UEID_NG_ENB_g2_1
,

85 
a_MAP_UEID_NG_ENB_oms_1
,

89 
a_TYPE_dest_t
 
	ga_DEF_UEID_NG_ENB
 = {

92 &
a_OP_SEQUENCE
,

93 
a_DEF_UEID_NG_ENB_gs_1
,

94 (
a_DEF_UEID_NG_ENB_gs_1
)

95 /(
a_DEF_UEID_NG_ENB_gs_1
[0]),

96 
a_DEF_UEID_NG_ENB_gs_1
,

97 (
a_DEF_UEID_NG_ENB_gs_1
)

98 /(
a_DEF_UEID_NG_ENB_gs_1
[0]),

99 { 0, 0, 
SEQUENCE_cڡt
 },

100 
a_MBR_UEID_NG_ENB_1
,

102 &
a_SPC_UEID_NG_ENB_ecs_1


	@UEID.c

8 
	~"UEID.h
"

10 
	~"UEID-GNB.h
"

11 
	~"UEID-GNB-DU.h
"

12 
	~"UEID-GNB-CU-UP.h
"

13 
	~"UEID-NG-ENB.h
"

14 
	~"UEID-NG-ENB-DU.h
"

15 
	~"UEID-EN-GNB.h
"

16 
	~"UEID-ENB.h
"

17 
a_r_cڡts_t
 
a_PER_ty_UEID_cڡr_1
 
	gCC_NOTUSED
 = {

18 { 
APC_CONSTRAINED
 | 
APC_EXTENSIBLE
, 3, 3, 0, 6 } ,

19 { 
APC_UNCONSTRAINED
, -1, -1, 0, 0 },

22 
a_TYPE_memb_t
 
	ga_MBR_UEID_1
[] = {

23 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
gNB_UEID
),

24 (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)),

26 &
a_DEF_UEID_GNB
,

32 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
gNB_DU_UEID
),

33 (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)),

35 &
a_DEF_UEID_GNB_DU
,

41 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
gNB_CU_UP_UEID
),

42 (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)),

44 &
a_DEF_UEID_GNB_CU_UP
,

50 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
ng_eNB_UEID
),

51 (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)),

53 &
a_DEF_UEID_NG_ENB
,

59 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
ng_eNB_DU_UEID
),

60 (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)),

62 &
a_DEF_UEID_NG_ENB_DU
,

68 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
_gNB_UEID
),

69 (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)),

71 &
a_DEF_UEID_EN_GNB
,

77 { 
ATF_POINTER
, 0, 
offtof
(
UEID
, 
choi
.
eNB_UEID
),

78 (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)),

80 &
a_DEF_UEID_ENB
,

87 cڡ 
a_TYPE_g2memb_t
 
	ga_MAP_UEID_g2_1
[] = {

88 { (
ASN_TAG_CLASS_CONTEXT
 | (0 << 2)), 0, 0, 0 },

89 { (
ASN_TAG_CLASS_CONTEXT
 | (1 << 2)), 1, 0, 0 },

90 { (
ASN_TAG_CLASS_CONTEXT
 | (2 << 2)), 2, 0, 0 },

91 { (
ASN_TAG_CLASS_CONTEXT
 | (3 << 2)), 3, 0, 0 },

92 { (
ASN_TAG_CLASS_CONTEXT
 | (4 << 2)), 4, 0, 0 },

93 { (
ASN_TAG_CLASS_CONTEXT
 | (5 << 2)), 5, 0, 0 },

94 { (
ASN_TAG_CLASS_CONTEXT
 | (6 << 2)), 6, 0, 0 }

96 
a_CHOICE_ecifics_t
 
	ga_SPC_UEID_ecs_1
 = {

97 (
UEID
),

98 
offtof
(
UEID
, 
_a_x
),

99 
offtof
(
UEID
, 
e
),

100 (((
UEID
 *)0)->
e
),

101 
a_MAP_UEID_g2_1
,

106 
a_TYPE_dest_t
 
	ga_DEF_UEID
 = {

109 &
a_OP_CHOICE
,

114 { 0, &
a_PER_ty_UEID_cڡr_1
, 
CHOICE_cڡt
 },

115 
a_MBR_UEID_1
,

117 &
a_SPC_UEID_ecs_1


	@asn_SEQUENCE_OF.c

5 
	~<a_.h
>

6 
	~<a_SEQUENCE_OF.h
>

8 
	$A_SEQUENCE_OF
(
	ta_qu
;

11 
	$a_qu_d
(*
a_qu_of_x
, 
numb
, 
_do_
) {

12 
a_qu
 *
as
 = (a_qu *)
a_qu_of_x
;

14 if(
as
) {

15 *
r
;

16 
n
;

18 if(
numb
 < 0 ||umb >
as
->
cou
)

21 if(
_do_
 && 
as
->

) {

22 
r
 = 
as
->
y
[
numb
];

24 
r
 = 0;

30 --
as
->
cou
;

31 
n
 = 
numb
; < 
as
->
cou
;++)

32 
as
->
y
[
n
] =s->array[n+1];

38 if(
r

as
->
	`
(ptr);

40 
	}
}

	@asn_SET_OF.c

5 
	~<a_.h
>

6 
	~<a_SET_OF.h
>

7 
	~<o.h
>

13 
	$a_t_add
(*
a_t_of_x
, *
r
) {

14 
a_ymous_t_
 *
as
 = 
	`_A_SET_FROM_VOID
(
a_t_of_x
);

16 if(
as
 =0 || 
r
 == 0) {

17 
o
 = 
EINVAL
;

24 if(
as
->
cou
 =as->
size
) {

25 
_wsize
 = 
as
->
size
 ? (as->size << 1) : 4;

26 *
_w_r
;

27 
_w_r
 = 
	`REALLOC
(
as
->
y
, 
_wsize
 * (as->array[0]));

28 if(
_w_r
) {

29 
as
->
y
 = (**)
_w_r
;

30 
as
->
size
 = 
_wsize
;

37 
as
->
y
[as->
cou
++] = 
r
;

40 
	}
}

43 
	$a_t_d
(*
a_t_of_x
, 
numb
, 
_do_
) {

44 
a_ymous_t_
 *
as
 = 
	`_A_SET_FROM_VOID
(
a_t_of_x
);

46 if(
as
) {

47 *
r
;

48 if(
numb
 < 0 ||umb >
as
->
cou
)

51 if(
_do_
 && 
as
->

) {

52 
r
 = 
as
->
y
[
numb
];

54 
r
 = 0;

57 
as
->
y
[
numb
] =s->y[--as->
cou
];

63 if(
r

as
->
	`
(ptr);

65 
	}
}

71 
	$a_t_emy
(*
a_t_of_x
) {

72 
a_ymous_t_
 *
as
 = 
	`_A_SET_FROM_VOID
(
a_t_of_x
);

74 if(
as
) {

75 if(
as
->
y
) {

76 if(
as
->

) {

77 
as
->
cou
--)

78 
as
->
	`
s->
y
[as->
cou
]);

80 
	`FREEMEM
(
as
->
y
);

81 
as
->
y
 = 0;

83 
as
->
cou
 = 0;

84 
as
->
size
 = 0;

87 
	}
}

	@asn_application.c

5 
	~<a_.h
>

6 
	~<a_iti.h
>

7 
	~<o.h
>

9 
a_c_rv_t
 
a_code_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

10 
a_sr_syax
 
syax
,

11 cڡ 
a_TYPE_dest_t
 *
td
,

12 cڡ *

,

13 
a_p_csume_bys_f
 *
back
,

14 *
back_key
);

17 
	sback_cou_bys_key
 {

18 
a_p_csume_bys_f
 *
	mback
;

19 *
	mback_key
;

20 
size_t
 
	mcompud_size
;

27 
	$back_cou_bys_cb
(cڡ *
da
, 
size_t
 
size
, *
keyp
) {

28 
back_cou_bys_key
 *
key
 = 
keyp
;

29 
t
;

31 
t
 = 
key
->
	`back
(
da
, 
size
, key->
back_key
);

32 if(
t
 >= 0) {

33 
key
->
compud_size
 +
size
;

36  
t
;

37 
	}
}

39 
	sovrun_cod_key
 {

40 *
	mbufr
;

41 
size_t
 
	mbufr_size
;

42 
size_t
 
	mcompud_size
;

45 
	sdymic_cod_key
 {

46 *
	mbufr
;

47 
size_t
 
	mbufr_size
;

48 
size_t
 
	mcompud_size
;

51 
	sback_u_tch_key
 {

52 
a_p_csume_bys_f
 *
	mback
;

53 *
	mback_key
;

54 
	mback_ed
;

62 
	$ovrun_cod_cb
(cڡ *
da
, 
size_t
 
size
, *
keyp
) {

63 
ovrun_cod_key
 *
key
 = 
keyp
;

65 if(
key
->
compud_size
 + 
size
 > key->
bufr_size
) {

70 
key
->
bufr_size
 = 0;

72 
	`memy
((*)
key
->
bufr
 + key->
compud_size
, 
da
, 
size
);

74 
key
->
compud_size
 +
size
;

77 
	}
}

84 
	$dymic_cod_cb
(cڡ *
da
, 
size_t
 
size
, *
keyp
) {

85 
dymic_cod_key
 *
key
 = 
keyp
;

87 if(
key
->
bufr
) {

88 if(
key
->
compud_size
 + 
size
 >key->
bufr_size
) {

89 *
p
;

90 
size_t
 
w_size
 = 
key
->
bufr_size
;

93 
w_size
 *= 2;

94 } 
w_size
 <
key
->
compud_size
 + 
size
);

96 
p
 = 
	`REALLOC
(
key
->
bufr
, 
w_size
);

97 if(
p
) {

98 
key
->
bufr
 = 
p
;

99 
key
->
bufr_size
 = 
w_size
;

101 
	`FREEMEM
(
key
->
bufr
);

102 
key
->
bufr
 = 0;

103 
key
->
bufr_size
 = 0;

104 
key
->
compud_size
 +
size
;

108 
	`memy
((*)
key
->
bufr
 + key->
compud_size
, 
da
, 
size
);

111 
key
->
compud_size
 +
size
;

114 
	}
}

120 
	$back_u_tch_cb
(cڡ *
da
, 
size_t
 
size
, *
keyp
) {

121 
back_u_tch_key
 *
key
 = 
keyp
;

122 
t
;

124 
t
 = 
key
->
	`back
(
da
, 
size
, key->
back_key
);

125 if(
t
 < 0) {

126 
key
->
back_ed
 = 1;

129  
t
;

130 
	}
}

132 
a_c_rv_t


133 
	$a_code
(cڡ 
a_codec_x_t
 *
t_codec_x
,

134 
a_sr_syax
 
syax
, cڡ 
a_TYPE_dest_t
 *
td
,

135 cڡ *

, 
a_p_csume_bys_f
 *
back
, *
back_key
) {

136 
back_u_tch_key
 
cb_key
;

137 
a_c_rv_t
 

 = {0,0,0};

139 if(!
back
) {

140 
o
 = 
EINVAL
;

141 
ASN__ENCODE_FAILED
;

144 
cb_key
.
back
 = callback;

145 
cb_key
.
back_key
 = callback_key;

146 
cb_key
.
back_ed
 = 0;

148 

 = 
	`a_code_
(
t_codec_x
, 
syax
, 
td
, 

,

149 
back_u_tch_cb
, &
cb_key
);

150 if(
cb_key
.
back_ed
) {

151 
	`as
(

.
coded
 == -1);

152 
	`as
(
o
 =
EBADF
);

153 
o
 = 
EIO
;

156  

;

157 
	}
}

159 
a_c_rv_t


160 
	$a_code_to_bufr
(cڡ 
a_codec_x_t
 *
t_codec_x
,

161 
a_sr_syax
 
syax
,

162 cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

163 *
bufr
, 
size_t
 
bufr_size
) {

164 
ovrun_cod_key
 
buf_key
;

165 
a_c_rv_t
 

 = {0,0,0};

167 if(
bufr_size
 > 0 && !
bufr
) {

168 
o
 = 
EINVAL
;

169 
ASN__ENCODE_FAILED
;

172 
buf_key
.
bufr
 = buffer;

173 
buf_key
.
bufr_size
 = buffer_size;

174 
buf_key
.
compud_size
 = 0;

176 

 = 
	`a_code_
(
t_codec_x
, 
syax
, 
td
, 

,

177 
ovrun_cod_cb
, &
buf_key
);

179 if(

.
coded
 >0 && (
size_t
r.coded !
buf_key
.
compud_size
) {

180 
	`ASN_DEBUG
("a_code(tued %" 
ASN_PRI_SSIZE


181 " yrodud %" 
ASN_PRI_SIZE
 " bytes",

182 

.
coded
, 
buf_key
.
compud_size
);

183 
	`as
(

.
coded
 < 0 || (
size_t
r.coded =
buf_key
.
compud_size
);

186  

;

187 
	}
}

189 
a_code_to_w_bufr_su_t


190 
	$a_code_to_w_bufr
(cڡ 
a_codec_x_t
 *
t_codec_x
,

191 
a_sr_syax
 
syax
,

192 cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

) {

193 
dymic_cod_key
 
buf_key
;

194 
a_code_to_w_bufr_su_t
 
s
;

196 
buf_key
.
bufr_size
 = 16;

197 
buf_key
.
bufr
 = 
	`MALLOC
(buf_key.
bufr_size
);

198 
buf_key
.
compud_size
 = 0;

200 
s
.
su
 = 
	`a_code_
(
t_codec_x
, 
syax
, 
td
, 

,

201 
dymic_cod_cb
, &
buf_key
);

203 if(
s
.
su
.
coded
 >= 0

204 && (
size_t
)
s
.
su
.
coded
 !
buf_key
.
compud_size
) {

205 
	`ASN_DEBUG
("a_code(tued %" 
ASN_PRI_SSIZE


206 " yrodud %" 
ASN_PRI_SIZE
 " bytes",

207 
s
.
su
.
coded
, 
buf_key
.
compud_size
);

208 
	`as
(
s
.
su
.
coded
 < 0

209 || (
size_t
)
s
.
su
.
coded
 =
buf_key
.
compud_size
);

212 
s
.
bufr
 = 
buf_key
.buffer;

215 if(
s
.
bufr
) {

216 
	`as
(
buf_key
.
compud_size
 < buf_key.
bufr_size
);

217 ((*)
s
.
bufr
)[
buf_key
.
compud_size
] = '\0';

220  
s
;

221 
	}
}

223 
a_c_rv_t


224 
	$a_code_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

225 
a_sr_syax
 
syax
,

226 cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

227 
a_p_csume_bys_f
 *
back
, *
back_key
) {

228 
a_c_rv_t
 

 = {0,0,0};

229 
x_cod_ags_e
 
x_ags
 = 
XER_F_CANONICAL
;

231 ()
t_codec_x
;

233 if(!
td
 || !

) {

234 
o
 = 
EINVAL
;

235 
ASN__ENCODE_FAILED
;

238 
syax
) {

239 
ATS_NONSTANDARD_PLAINTEXT
:

240 if(
td
->

->
t_ru
) {

241 
back_cou_bys_key
 
cb_key
;

242 
cb_key
.
back
 = callback;

243 
cb_key
.
back_key
 = callback_key;

244 
cb_key
.
compud_size
 = 0;

245 if(
td
->

->
	`t_ru
d, 

, 1, 
back_cou_bys_cb
,

246 &
cb_key
)

248 || 
	`back_cou_bys_cb
("\n", 1, &
cb_key
) < 0) {

249 
o
 = 
EBADF
;

250 

.
coded
 = -1;

251 

.
ed_ty
 = 
td
;

252 

.
ruu_r
 = 

;

254 

.
coded
 = 
cb_key
.
compud_size
;

255 

.
ed_ty
 = 0;

256 

.
ruu_r
 = 0;

259 
o
 = 
ENOENT
;

260 
ASN__ENCODE_FAILED
;

264 
ATS_RANDOM
:

265 
o
 = 
ENOENT
;

266 
ASN__ENCODE_FAILED
;

268 
ATS_BER
:

271 
ATS_DER
:

272 if(
td
->

->
d_cod
) {

273 

 = 
	`d_code
(
td
, 

, 
back
, 
back_key
);

274 if(

.
coded
 == -1) {

275 if(

.
ed_ty
 &&r.ed_ty->

->
d_cod
) {

276 
o
 = 
EBADF
;

278 
o
 = 
ENOENT
;

282 
o
 = 
ENOENT
;

283 
ASN__ENCODE_FAILED
;

286 
ATS_CER
:

287 
o
 = 
ENOENT
;

288 
ASN__ENCODE_FAILED
;

290 #ifde 
ASN_DISABLE_OER_SUPPORT


291 
ATS_BASIC_OER
:

292 
ATS_CANONICAL_OER
:

293 
o
 = 
ENOENT
;

294 
ASN__ENCODE_FAILED
;

297 
ATS_BASIC_OER
:

300 
ATS_CANONICAL_OER
:

301 if(
td
->

->
r_cod
) {

302 

 = 
	`r_code
(
td
, 

, 
back
, 
back_key
);

303 if(

.
coded
 == -1) {

304 if(

.
ed_ty
 &&r.ed_ty->

->
r_cod
) {

305 
o
 = 
EBADF
;

307 
o
 = 
ENOENT
;

311 
o
 = 
ENOENT
;

312 
ASN__ENCODE_FAILED
;

317 #ifde 
ASN_DISABLE_PER_SUPPORT


318 
ATS_UNALIGNED_BASIC_PER
:

319 
ATS_UNALIGNED_CANONICAL_PER
:

320 
ATS_ALIGNED_BASIC_PER
:

321 
ATS_ALIGNED_CANONICAL_PER
:

322 
o
 = 
ENOENT
;

323 
ASN__ENCODE_FAILED
;

326 
ATS_UNALIGNED_BASIC_PER
:

329 
ATS_UNALIGNED_CANONICAL_PER
:

330 if(
td
->

->
ur_cod
) {

331 

 = 
	`ur_code
(
td
, 0, 

, 
back
, 
back_key
);

332 if(

.
coded
 == -1) {

333 if(

.
ed_ty
 &&r.ed_ty->

->
ur_cod
) {

334 
o
 = 
EBADF
;

336 
o
 = 
ENOENT
;

339 
	`ASN_DEBUG
("Comcoded i%ld bs", ()

.
coded
);

340 if(

.
coded
 == 0) {

342 if(
	`back
("\0", 1, 
back_key
) < 0) {

343 
o
 = 
EBADF
;

344 
ASN__ENCODE_FAILED
;

346 

.
coded
 = 8;

349 

.
coded
 = (er.encoded + 7) >> 3;

352 
o
 = 
ENOENT
;

353 
ASN__ENCODE_FAILED
;

356 
ATS_ALIGNED_BASIC_PER
:

359 
ATS_ALIGNED_CANONICAL_PER
:

360 if(
td
->

->
_cod
) {

361 

 = 
	`_code
(
td
, 0, 

, 
back
, 
back_key
);

362 if(

.
coded
 == -1) {

363 if(

.
ed_ty
 &&r.ed_ty->

->
_cod
) {

364 
o
 = 
EBADF
;

366 
o
 = 
ENOENT
;

369 
	`ASN_DEBUG
("Comcoded i%ld bs", ()

.
coded
);

370 if(

.
coded
 == 0) {

372 if(
	`back
("\0", 1, 
back_key
) < 0) {

373 
o
 = 
EBADF
;

374 
ASN__ENCODE_FAILED
;

376 

.
coded
 = 8;

379 

.
coded
 = (er.encoded + 7) >> 3;

382 
o
 = 
ENOENT
;

383 
ASN__ENCODE_FAILED
;

388 
ATS_BASIC_XER
:

390 
x_ags
 &~
XER_F_CANONICAL
;

391 
x_ags
 |
XER_F_BASIC
;

393 
ATS_CANONICAL_XER
:

394 if(
td
->

->
x_cod
) {

395 

 = 
	`x_code
(
td
, 

, 
x_ags
, 
back
, 
back_key
);

396 if(

.
coded
 == -1) {

397 if(

.
ed_ty
 &&r.ed_ty->

->
x_cod
) {

398 
o
 = 
EBADF
;

400 
o
 = 
ENOENT
;

404 
o
 = 
ENOENT
;

405 
ASN__ENCODE_FAILED
;

410 
o
 = 
ENOENT
;

411 
ASN__ENCODE_FAILED
;

414  

;

415 
	}
}

417 
a_dec_rv_t


418 
	$a_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

419 
a_sr_syax
 
syax
, cڡ 
a_TYPE_dest_t
 *
td
,

420 **

, cڡ *
bufr
, 
size_t
 
size
) {

421 if(!
td
 || !td->

 || !

 || (
size
 && !
bufr
)) {

422 
ASN__DECODE_FAILED
;

425 
syax
) {

426 
ATS_CER
:

427 
ATS_NONSTANDARD_PLAINTEXT
:

429 
o
 = 
ENOENT
;

430 
ASN__DECODE_FAILED
;

432 
ATS_RANDOM
:

433 if(!
td
->

->
ndom_fl
) {

434 
ASN__DECODE_FAILED
;

436 if(
	`a_ndom_fl
(
td
, 

, 16000) == 0) {

437 
a_dec_rv_t
 
t
 = {
RC_OK
, 0};

438  
t
;

440 
ASN__DECODE_FAILED
;

445 
ATS_DER
:

446 
ATS_BER
:

447  
	`b_decode
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
);

449 
ATS_BASIC_OER
:

450 
ATS_CANONICAL_OER
:

451 #ifde 
ASN_DISABLE_OER_SUPPORT


452 
o
 = 
ENOENT
;

453 
ASN__DECODE_FAILED
;

455  
	`r_decode
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
);

458 
ATS_UNALIGNED_BASIC_PER
:

459 
ATS_UNALIGNED_CANONICAL_PER
:

460 #ifde 
ASN_DISABLE_PER_SUPPORT


461 
o
 = 
ENOENT
;

462 
ASN__DECODE_FAILED
;

464  
	`ur_decode_come
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
);

467 
ATS_ALIGNED_BASIC_PER
:

468 
ATS_ALIGNED_CANONICAL_PER
:

469 #ifde 
ASN_DISABLE_PER_SUPPORT


470 
o
 = 
ENOENT
;

471 
ASN__DECODE_FAILED
;

473  
	`_decode_come
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
);

476 
ATS_BASIC_XER
:

477 
ATS_CANONICAL_XER
:

478  
	`x_decode
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
);

480 
	}
}

	@asn_bit_data.c

6 
	~<a_syem.h
>

7 
	~<a_.h
>

8 
	~<a_b_da.h
>

14 
a_b_da_t
 *

15 
	$a_b_da_w_ctiguous
(cڡ *
da
, 
size_t
 
size_bs
) {

16 
size_t
 
size_bys
 = (
size_bs
 + 7) / 8;

17 
a_b_da_t
 *
pd
;

18 
ut8_t
 *
bys
;

21 
pd
 = 
	`CALLOC
(1, (*pd+ 
size_bys
 + 1);

22 if(!
pd
) {

23  
NULL
;

25 
bys
 = (*)(((*)
pd
) + (*pd));

26 
	`memy
(
bys
, 
da
, 
size_bys
);

27 
bys
[
size_bys
] = 0;

28 
pd
->
bufr
 = 
bys
;

29 
pd
->
nboff
 = 0;

30 
pd
->
nbs
 = 
size_bs
;

32  
pd
;

33 
	}
}

37 
	$a_b_da_rg
(
a_b_da_t
 *
pd
) {

38 
buf
[2][32];

39 
n
;

40 
n
 = (n+1) % 2;

41 
	`tf
(
buf
[
n
], (buf[n]),

42 "{m=%" 
ASN_PRI_SIZE
 " span %" ASN_PRI_SIZE "[%" ASN_PRI_SIZE

43 "..%" 
ASN_PRI_SIZE
 "] (%" ASN_PRI_SIZE ")}",

44 
pd
->
moved
, ((
u_t
)d->
bufr
& 0xf),d->
nboff
,d->
nbs
,

45 
pd
->
nbs
 -d->
nboff
);

46  
buf
[
n
];

47 
	}
}

50 
	$a_g_undo
(
a_b_da_t
 *
pd
, 
nbs
) {

51 if((
ssize_t
)
pd
->
nboff
 < 
nbs
) {

52 
	`as
((
ssize_t
)
pd
->
nboff
 < 
nbs
);

54 
pd
->
nboff
 -
nbs
;

55 
pd
->
moved
 -
nbs
;

57 
	}
}

62 
t32_t


63 
	$a_g_w_bs
(
a_b_da_t
 *
pd
, 
nbs
) {

64 
size_t
 
off
;

65 
ssize_t
 
e
;

66 
ut32_t
 
accum
;

67 cڡ 
ut8_t
 *
buf
;

69 if(
nbs
 < 0)

72 
e
 = 
pd
->
nbs
 -d->
nboff
;

73 if(
nbs
 > 
e
) {

74 
t32_t
 
v
, 
vhd
;

75 if(!
pd
->
fl
 || 
nbs
 > 31)  -1;

77 
	`ASN_DEBUG
("Obtainheest %d bits (want %d)",

78 ()
e
, ()
nbs
);

79 
v
 = 
	`a_g_w_bs
(
pd
, 
e
);

80 if(
v
 < 0)  -1;

82 if(
pd
->
	`fl
(pd))

84 
nbs
 -
e
;

85 
vhd
 = 
	`a_g_w_bs
(
pd
, 
nbs
);

87 
v
 = (v << 
nbs
| 
vhd
;

88  
v
;

94 if(
pd
->
nboff
 >= 8) {

95 
pd
->
bufr
 +d->
nboff
 >> 3);

96 
pd
->
nbs
 -d->
nboff
 & ~0x07);

97 
pd
->
nboff
 &= 0x07;

99 
pd
->
moved
 +
nbs
;

100 
pd
->
nboff
 +
nbs
;

101 
off
 = 
pd
->
nboff
;

102 
buf
 = 
pd
->
bufr
;

107 if(
off
 <= 8)

108 
accum
 = 
nbs
 ? (
buf
[0]>> (8 - 
off
) : 0;

109 if(
off
 <= 16)

110 
accum
 = ((
buf
[0] << 8+ buf[1]>> (16 - 
off
);

111 if(
off
 <= 24)

112 
accum
 = ((
buf
[0] << 16+ (buf[1] << 8+ buf[2]>> (24 - 
off
);

113 if(
off
 <= 31)

114 
accum
 = (((
ut32_t
)
buf
[0] << 24) + (buf[1] << 16)

115 + (
buf
[2] << 8+ (buf[3])>> (32 - 
off
);

116 if(
nbs
 <= 31) {

117 
a_b_da_t
 
d
 = *
pd
;

119 
	`a_g_undo
(&
d
, 
nbs
);

123 
accum
 = 
	`a_g_w_bs
(&
d
, 
nbs
 - 24) << 24;

124 
accum
 |
	`a_g_w_bs
(&
d
, 24);

126 
	`a_g_undo
(
pd
, 
nbs
);

130 
accum
 &(((
ut32_t
)1 << 
nbs
) - 1);

132 
	`ASN_DEBUG
(" [PER got %2d<=%2d bits => span %d %+ld[%d..%d]:%02x (%d) => 0x%x]",

133 ()
nbs
, ()
e
,

134 ()
pd
->
moved
,

135 ((()
pd
->
bufr
) & 0xf),

136 ()
pd
->
nboff
, (d->
nbs
,

137 ((
pd
->
bufr
 !
NULL
)?pd->buffer[0]:0),

138 ()(
pd
->
nbs
 -d->
nboff
),

139 ()
accum
);

141  
accum
;

142 
	}
}

148 
	$a_g_my_bs
(
a_b_da_t
 *
pd
, 
ut8_t
 *
d
, 
right
, 
nbs
) {

149 
t32_t
 
vue
;

151 if(
right
 && (
nbs
 & 7)) {

153 
vue
 = 
	`a_g_w_bs
(
pd
, 
nbs
 & 0x07);

154 if(
vue
 < 0)  -1;

155 *
d
++ = 
vue
;

156 
nbs
 &= ~7;

159 
nbs
) {

160 if(
nbs
 >= 24) {

161 
vue
 = 
	`a_g_w_bs
(
pd
, 24);

162 if(
vue
 < 0)  -1;

163 *(
d
++
vue
 >> 16;

164 *(
d
++
vue
 >> 8;

165 *(
d
++
vue
;

166 
nbs
 -= 24;

168 
vue
 = 
	`a_g_w_bs
(
pd
, 
nbs
);

169 if(
vue
 < 0)  -1;

170 if(
nbs
 & 7) {

171 
vue
 <<8 - (
nbs
 & 7),

172 
nbs
 += 8 - (nbits & 7);

173 if(
nbs
 > 24)

174 *
d
++ = 
vue
 >> 24;

176 if(
nbs
 > 16)

177 *
d
++ = 
vue
 >> 16;

178 if(
nbs
 > 8)

179 *
d
++ = 
vue
 >> 8;

180 *
d
++ = 
vue
;

186 
	}
}

192 
	$a_put_w_bs
(
a_b_ou_t
 *
po
, 
ut32_t
 
bs
, 
obs
) {

193 
size_t
 
off
;

194 
size_t
 
omsk
;

195 
ut8_t
 *
buf
;

197 if(
obs
 <= 0 || obits >= 32)  obits ? -1 : 0;

199 
	`ASN_DEBUG
("[PERut %d bits %xo %p+%d bits]",

200 
obs
, ()
bs
, (*)
po
->
bufr
, (o->
nboff
);

205 if(
po
->
nboff
 >= 8) {

206 
po
->
bufr
 +o->
nboff
 >> 3);

207 
po
->
nbs
 -o->
nboff
 & ~0x07);

208 
po
->
nboff
 &= 0x07;

214 if(
po
->
nboff
 + 
obs
 >o->
nbs
) {

215 
size_t
 
come_bys
;

216 if(!
po
->
bufr
po->bufpo->
tmpa
;

217 
come_bys
 = (
po
->
bufr
 -o->
tmpa
);

218 
	`ASN_DEBUG
("[PER output %ld complete + %ld]",

219 ()
come_bys
, ()
po
->
ushed_bys
);

220 if(
po
->
	`ouut
o->
tmpa
, 
come_bys
,o->
_key
) < 0)

222 if(
po
->
nboff
)

223 
po
->
tmpa
[0] =o->
bufr
[0];

224 
po
->
bufr
 =o->
tmpa
;

225 
po
->
nbs
 = 8 * o->
tmpa
);

226 
po
->
ushed_bys
 +
come_bys
;

232 
buf
 = 
po
->
bufr
;

233 
omsk
 = ~((1 << (8 - 
po
->
nboff
)) - 1);

234 
off
 = (
po
->
nboff
 + 
obs
);

237 
bs
 &(((
ut32_t
)1 << 
obs
) - 1);

239 
	`ASN_DEBUG
("[PER ou%d %u/%x (t=%d,o=%d%x&%x=%x]", 
obs
,

240 ()
bs
, ()bits,

241 ()
po
->
nboff
, ()
off
,

242 
buf
[0], ()(
omsk
&0xff),

243 ()(
buf
[0] & 
omsk
));

245 if(
off
 <= 8)

246 
po
->
nboff
 = 
off
,

247 
bs
 <<(8 - 
off
),

248 
buf
[0] = (buf[0] & 
omsk
| 
bs
;

249 if(
off
 <= 16)

250 
po
->
nboff
 = 
off
,

251 
bs
 <<(16 - 
off
),

252 
buf
[0] = (buf[0] & 
omsk
| (
bs
 >> 8),

253 
buf
[1] = 
bs
;

254 if(
off
 <= 24)

255 
po
->
nboff
 = 
off
,

256 
bs
 <<(24 - 
off
),

257 
buf
[0] = (buf[0] & 
omsk
| (
bs
 >> 16),

258 
buf
[1] = 
bs
 >> 8,

259 
buf
[2] = 
bs
;

260 if(
off
 <= 31)

261 
po
->
nboff
 = 
off
,

262 
bs
 <<(32 - 
off
),

263 
buf
[0] = (buf[0] & 
omsk
| (
bs
 >> 24),

264 
buf
[1] = 
bs
 >> 16,

265 
buf
[2] = 
bs
 >> 8,

266 
buf
[3] = 
bs
;

268 if(
	`a_put_w_bs
(
po
, 
bs
 >> (
obs
 - 24), 24))  -1;

269 if(
	`a_put_w_bs
(
po
, 
bs
, 
obs
 - 24))  -1;

272 
	`ASN_DEBUG
("[PER out %u/%x => %02x buf+%ld]",

273 ()
bs
, ()bs, 
buf
[0],

274 ()(
po
->
bufr
 -o->
tmpa
));

277 
	}
}

284 
	$a_put_my_bs
(
a_b_ou_t
 *
po
, cڡ 
ut8_t
 *
c
, 
nbs
) {

286 
nbs
) {

287 
ut32_t
 
vue
;

289 if(
nbs
 >= 24) {

290 
vue
 = (
c
[0] << 16) | (src[1] << 8) | src[2];

291 
c
 += 3;

292 
nbs
 -= 24;

293 if(
	`a_put_w_bs
(
po
, 
vue
, 24))

296 
vue
 = 
c
[0];

297 if(
nbs
 > 8)

298 
vue
 = (vu<< 8| 
c
[1];

299 if(
nbs
 > 16)

300 
vue
 = (vu<< 8| 
c
[2];

301 if(
nbs
 & 0x07)

302 
vue
 >>(8 - (
nbs
 & 0x07));

303 if(
	`a_put_w_bs
(
po
, 
vue
, 
nbs
))

310 
	}
}

314 
	$a_put_igd_ush
(
a_b_ou_t
 *
po
) {

315 
ut32_t
 
unud_bs
 = (0x7 & (8 - (
po
->
nboff
 & 0x07)));

316 
size_t
 
come_bys
 =

317 (
po
->
bufr
 ?o->buf-o->
tmpa
 : 0+ (o->
nboff
 + 7) >> 3);

319 if(
unud_bs
) {

320 
po
->
bufr
[po->
nboff
 >> 3] &~0u << 
unud_bs
;

323 if(
po
->
	`ouut
o->
tmpa
, 
come_bys
,o->
_key
) < 0) {

326 
po
->
bufr
 =o->
tmpa
;

327 
po
->
nboff
 = 0;

328 
po
->
nbs
 = 8 * o->
tmpa
);

329 
po
->
ushed_bys
 +
come_bys
;

332 
	}
}

	@asn_codecs_prim.c

5 
	~<a_.h
>

6 
	~<a_codecs_im.h
>

7 
	~<o.h
>

12 
a_dec_rv_t


13 
	$b_decode_imive
(cڡ 
a_codec_x_t
 *
t_codec_x
,

14 cڡ 
a_TYPE_dest_t
 *
td
, **

,

15 cڡ *
buf_r
, 
size_t
 
size
, 
g_mode
) {

16 
ASN__PRIMITIVE_TYPE_t
 *

 = (ASN__PRIMITIVE_TYPE_*)*

;

17 
a_dec_rv_t
 
rv
;

18 
b_v_n_t
 
ngth
 = 0;

23 if(

 =
NULL
) {

24 

 = (
ASN__PRIMITIVE_TYPE_t
 *)
	`CALLOC
(1, (*st));

25 if(

 =
NULL

ASN__DECODE_FAILED
;

26 *

 = (*)

;

29 
	`ASN_DEBUG
("Decoding %sslainrimitive (tm=%d)",

30 
td
->
me
, 
g_mode
);

35 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 0, 
buf_r
, 
size
,

36 
g_mode
, 0, &
ngth
, 0);

37 if(
rv
.
code
 !
RC_OK
)

38  
rv
;

40 
	`ASN_DEBUG
("%ngth i%d bys", 
td
->
me
, ()
ngth
);

45 
buf_r
 = ((cڡ *)buf_r+ 
rv
.
csumed
;

46 
size
 -
rv
.
csumed
;

47 if(
ngth
 > (
b_v_n_t
)
size
) {

48 
rv
.
code
 = 
RC_WMORE
;

49 
rv
.
csumed
 = 0;

50  
rv
;

53 

->
size
 = ()
ngth
;

55 if((

->
size
!(
ngth
)

56 && (
b_v_n_t
)

->
size
 !
ngth
) {

57 

->
size
 = 0;

58 
ASN__DECODE_FAILED
;

61 

->
buf
 = (
ut8_t
 *)
	`MALLOC
(
ngth
 + 1);

62 if(!

->
buf
) {

63 

->
size
 = 0;

64 
ASN__DECODE_FAILED
;

67 
	`memy
(

->
buf
, 
buf_r
, 
ngth
);

68 

->
buf
[
ngth
] = '\0';

70 
rv
.
code
 = 
RC_OK
;

71 
rv
.
csumed
 +
ngth
;

73 
	`ASN_DEBUG
("Took %ld/%ld bytesoncode %s",

74 ()
rv
.
csumed
,

75 ()
ngth
, 
td
->
me
);

77  
rv
;

78 
	}
}

83 
a_c_rv_t


84 
	$d_code_imive
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

85 
g_mode
, 
b_v_g_t
 
g
,

86 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

87 
a_c_rv_t
 
v
 = {0,0,0};

88 cڡ 
ASN__PRIMITIVE_TYPE_t
 *

 = (cڡ ASN__PRIMITIVE_TYPE_*)

;

90 
	`ASN_DEBUG
("%s %ssrimitiveype (tm=%d)",

91 
cb
?"Encodg":"Eimg", 
td
->
me
, 
g_mode
);

93 
v
.
coded
 = 
	`d_wre_gs
(
td
, 

->
size
, 
g_mode
, 0, 
g
,

94 
cb
, 
p_key
);

95 
	`ASN_DEBUG
("%wrِg%d", 
td
->
me
, ()
v
.
coded
);

96 if(
v
.
coded
 == -1) {

97 
v
.
ed_ty
 = 
td
;

98 
v
.
ruu_r
 = 

;

99  
v
;

102 if(
cb
 && 

->
buf
) {

103 if(
	`cb
(

->
buf
, st->
size
, 
p_key
) < 0) {

104 
v
.
coded
 = -1;

105 
v
.
ed_ty
 = 
td
;

106 
v
.
ruu_r
 = 

;

107  
v
;

110 
	`as
(

->
buf
 || st->
size
 == 0);

113 
v
.
coded
 +

->
size
;

114 
	`ASN__ENCODED_OK
(
v
);

115 
	}
}

118 
	$ASN__PRIMITIVE_TYPE_
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

119 
a_ru__mhod
 
mhod
) {

120 
ASN__PRIMITIVE_TYPE_t
 *

 = (ASN__PRIMITIVE_TYPE_*)

;

122 if(!
td
 || !

)

125 
	`ASN_DEBUG
("Feg %aimivty", 
td
->
me
);

127 if(

->
buf
)

128 
	`FREEMEM
(

->
buf
);

130 
mhod
) {

131 
ASFM_FREE_EVERYTHING
:

132 
	`FREEMEM
(

);

134 
ASFM_FREE_UNDERLYING
:

136 
ASFM_FREE_UNDERLYING_AND_RESET
:

137 
	`memt
(

, 0, (
ASN__PRIMITIVE_TYPE_t
));

140 
	}
}

146 
	sxdp_g_s
 {

147 cڡ 
a_TYPE_dest_t
 *
	mty_dest
;

148 *
	mru_key
;

149 
x_imive_body_decod_f
 *
	mim_body_decod
;

150 
	mdecoded_somhg
;

151 
	mwt_me
;

160 
	$x_decode__uxed_g
(*
key
, cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

161 
xdp_g_s
 *
g
 = (xdp_g_*)
key
;

162 
x_pbd_rv
 
bt
;

167 
	`as
(
chunk_size
 && ((cڡ *)
chunk_buf
)[0] == 0x3c);

172 if(
g
->
decoded_somhg
)

175 
bt
 = 
g
->
	`im_body_decod
rg->
ty_dest
,

176 
g
->
ru_key
, 
chunk_buf
, 
chunk_size
);

177 
bt
) {

178 
XPBD_SYSTEM_FAILURE
:

179 
XPBD_DECODER_LIMIT
:

180 
XPBD_BROKEN_ENCODING
:

182 
XPBD_BODY_CONSUMED
:

184 
g
->
decoded_somhg
 = 1;

186 
XPBD_NOT_BODY_IGNORE
:

191 
	}
}

193 
ssize_t


194 
	$x_decode__imive_body
(*
key
, cڡ *
chunk_buf
, 
size_t
 
chunk_size
, 
have_me
) {

195 
xdp_g_s
 *
g
 = (xdp_g_*)
key
;

196 
x_pbd_rv
 
bt
;

197 
size_t
 
ad_w_size
;

199 if(
g
->
decoded_somhg
) {

200 if(
	`x_whea_
(
chunk_buf
, 
chunk_size
) == chunk_size) {

206  
chunk_size
;

214 if(!
have_me
) {

223 
g
->
wt_me
 = 1;

227 
ad_w_size
 = 
	`x_whea_
(
chunk_buf
, 
chunk_size
);

228 
chunk_buf
 = (cڡ *)chunk_bu+ 
ad_w_size
;

229 
chunk_size
 -
ad_w_size
;

231 
bt
 = 
g
->
	`im_body_decod
rg->
ty_dest
,

232 
g
->
ru_key
, 
chunk_buf
, 
chunk_size
);

233 
bt
) {

234 
XPBD_SYSTEM_FAILURE
:

235 
XPBD_DECODER_LIMIT
:

236 
XPBD_BROKEN_ENCODING
:

238 
XPBD_BODY_CONSUMED
:

240 
g
->
decoded_somhg
 = 1;

242 
XPBD_NOT_BODY_IGNORE
:

243  
ad_w_size
 + 
chunk_size
;

247 
	}
}

250 
a_dec_rv_t


251 
	$x_decode_imive
(cڡ 
a_codec_x_t
 *
t_codec_x
,

252 cڡ 
a_TYPE_dest_t
 *
td
, **

,

253 
size_t
 
ru_size
, cڡ *
t_mme
,

254 cڡ *
buf_r
, 
size_t
 
size
,

255 
x_imive_body_decod_f
 *
im_body_decod
) {

256 cڡ *
xml_g
 = 
t_mme
 ? o_mm: 
td
->xml_tag;

257 
a_ru_x_t
 
s_x
;

258 
xdp_g_s
 
s_g
;

259 
a_dec_rv_t
 
rc
;

264 if(!*

) {

265 *

 = 
	`CALLOC
(1, 
ru_size
);

266 if(!*


ASN__DECODE_FAILED
;

269 
	`memt
(&
s_x
, 0, (s_ctx));

270 
s_g
.
ty_dest
 = 
td
;

271 
s_g
.
ru_key
 = *

;

272 
s_g
.
im_body_decod
 =rim_body_decoder;

273 
s_g
.
decoded_somhg
 = 0;

274 
s_g
.
wt_me
 = 0;

276 
rc
 = 
	`x_decode_g
(
t_codec_x
, &
s_x
, &
s_g
,

277 
xml_g
, 
buf_r
, 
size
,

278 
x_decode__uxed_g
, 
x_decode__imive_body
);

279 
rc
.
code
) {

280 
RC_OK
:

281 if(!
s_g
.
decoded_somhg
) {

282 
ch
;

283 
	`ASN_DEBUG
("Primitive body isotecognized, "

290 if(
	`im_body_decod
(
s_g
.
ty_dest
,

291 
s_g
.
ru_key
, &
ch
, 0)

292 !
XPBD_BODY_CONSUMED
) {

296 
ASN__DECODE_FAILED
;

300 
RC_WMORE
:

305 
rc
.
csumed
 = 0;

307 
RC_FAIL
:

308 
rc
.
csumed
 = 0;

309 if(
s_g
.
wt_me
)

310 
rc
.
code
 = 
RC_WMORE
;

312 
ASN__DECODE_FAILED
;

315  
rc
;

316 
	}
}

	@asn_internal.c

1 
	~<a_.h
>

3 
ssize_t


4 
	$a__fm_to_back
((*
cb
)(cڡ *, 
size_t
, *
key
), *key,

5 cڡ *
fmt
, ...) {

6 
sch
[64];

7 *
buf
 = 
sch
;

8 
size_t
 
buf_size
 = (
sch
);

9 
wre
;

10 
cb_t
;

13 
va_li
 
gs
;

14 
	`va_t
(
gs
, 
fmt
);

16 
wre
 = 
	`vtf
(
buf
, 
buf_size
, 
fmt
, 
gs
);

17 if(
wre
 < (
ssize_t
)
buf_size
) {

18 if(
wre
 < 0) {

19 if(
buf
 !
sch

	`FREEMEM
(buf);

20 
	`va_d
(
gs
);

26 
buf_size
 <<= 1;

27 if(
buf
 =
sch
) {

28 
buf
 = 
	`MALLOC
(
buf_size
);

29 if(!
buf
{ 
	`va_d
(
gs
);  -1; }

31 *
p
 = 
	`REALLOC
(
buf
, 
buf_size
);

32 if(!
p
) {

33 
	`FREEMEM
(
buf
);

34 
	`va_d
(
gs
);

37 
buf
 = 
p
;

41 
cb_t
 = 
	`cb
(
buf
, 
wre
, 
key
);

42 if(
buf
 !
sch

	`FREEMEM
(buf);

43 if(
cb_t
 < 0) {

47  
wre
;

48 
	}
}

	@asn_random_fill.c

6 
	~<a_.h
>

7 
	~<a_ndom_fl.h
>

8 
	~<cڡr_TYPE.h
>

11 
	$a_ndom_fl
(cڡ 
a_TYPE_dest_s
 *
td
, **
ru_r
,

12 
size_t
 
ngth
) {

14 if(
td
 &&d->

->
ndom_fl
) {

15 
a_ndom_fl_su_t
 
s
 =

16 
td
->

->
	`ndom_fl
d, 
ru_r
, 0, 
ngth
);

17  (
s
.
code
 =
ARFILL_OK
) ? 0 : -1;

21 
	}
}

23 
utmax_t


24 
	$a__tmax_nge
(
tmax_t
 
lb
, imax_
ub
) {

25 
	`as
(
lb
 <
ub
);

26 if((
ub
 < 0=(
lb
 < 0)) {

27  
ub
 - 
lb
;

28 } if(
lb
 < 0) {

29  1 + ((
utmax_t
)
ub
 + (utmax_t)-(
lb
 + 1));

31 
	`as
(!"Unreachable");

34 
	}
}

36 
tmax_t


37 
	$a_ndom_bwn
(
tmax_t
 
lb
, imax_
rb
) {

38 if(
lb
 =
rb
) {

39  
lb
;

41 cڡ 
utmax_t
 
tmax_max
 = ((~(uintmax_t)0) >> 1);

42 
utmax_t
 
nge
 = 
	`a__tmax_nge
(
lb
, 
rb
);

43 
utmax_t
 
vue
 = 0;

44 
utmax_t
 
g_y
 = 0;

46 
	`as
(
RAND_MAX
 > 0xffffff);

47 
	`as
(
nge
 < 
tmax_max
);

49 ; 
g_y
 < 
nge
;) {

50 
g_y
 = (got_entropy << 24) | 0xffffff;

51 
vue
 = (vu<< 24| (
	`ndom
() % 0xffffff);

54  
lb
 + (
tmax_t
)(
vue
 % (
nge
 + 1));

56 
	}
}

	@ber_decoder.c

5 
	~<a_.h
>

7 #unde
ADVANCE


8 
	#ADVANCE
(
num_bys
) do { \

9 
size_t
 
num
 = 
num_bys
; \

10 
r
 = ((cڡ *+ 
num
; \

11 
size
 -
num
; \

12 
csumed_mylf
 +
num
; \

13 } 0)

	)

14 #unde
RETURN


15 
	#RETURN
(
_code
) do { \

16 
a_dec_rv_t
 
rv
; \

17 
rv
.
code
 = 
_code
; \

18 if(
t_x
t_x->

 = step; \

19 if(
_code
 =
RC_OK
 || 
t_x
) \

20 
rv
.
csumed
 = 
csumed_mylf
; \

22 
rv
.
csumed
 = 0; \

23  
rv
; \

24 } 0)

	)

29 
a_dec_rv_t


30 
	$b_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

31 cڡ 
a_TYPE_dest_t
 *
ty_dest
, **
ru_r
,

32 cڡ *
r
, 
size_t
 
size
) {

33 
a_codec_x_t
 
s_codec_x
;

39 if(
t_codec_x
) {

40 if(
t_codec_x
->
max_ack_size
) {

41 
s_codec_x
 = *
t_codec_x
;

42 
t_codec_x
 = &
s_codec_x
;

46 
	`memt
(&
s_codec_x
, 0, (s_codec_ctx));

47 
s_codec_x
.
max_ack_size
 = 
ASN__DEFAULT_STACK_MAX
;

48 
t_codec_x
 = &
s_codec_x
;

54  
ty_dest
->

->
	`b_decod
(
t_codec_x
,ype_descriptor,

55 
ru_r
,

56 
r
, 
size
,

59 
	}
}

64 
a_dec_rv_t


65 
	$b_check_gs
(cڡ 
a_codec_x_t
 *
t_codec_x
,

66 cڡ 
a_TYPE_dest_t
 *
td
, 
a_ru_x_t
 *
t_x
,

67 cڡ *
r
, 
size_t
 
size
, 
g_mode
, 
ϡ_g_fm
,

68 
b_v_n_t
 *
ϡ_ngth
, *
t_v_fm
) {

69 
ssize_t
 
csumed_mylf
 = 0;

70 
ssize_t
 
g_n
;

71 
ssize_t
 
n_n
;

72 
b_v_g_t
 
v_g
;

73 
b_v_n_t
 
v_n
;

74 
b_v_n_t
 
lim_n
 = -1;

75 
ex_00_rms
 = 0;

76 
v_cڡr
 = -1;

77 

 = 
t_x
 ? opt_ctx->step : 0;

78 
gno
;

83 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

84 
	`RETURN
(
RC_FAIL
);

108 
gno
 = 



109 + (
g_mode
==1?-1:0)

111 
	`ASN_DEBUG
("ber_check_tags(%s, size=%ld,m=%d, step=%d,agno=%d)",

112 
td
->
me
, ()
size
, 
g_mode
, 

, 
gno
);

115 if(
g_mode
 =0 && 
gno
 =()
td
->
gs_cou
) {

121 
g_n
 = 
	`b_tch_g
(
r
, 
size
, &
v_g
);

122 
g_n
) {

123 -1: 
	`RETURN
(
RC_FAIL
);

124 0: 
	`RETURN
(
RC_WMORE
);

126 
v_cڡr
 = 
	`BER_TLV_CONSTRUCTED
(
r
);

127 
n_n
 = 
	`b_tch_ngth
(
v_cڡr
,

128 (cڡ *)
r
 + 
g_n
, 
size
 -ag_n, &
v_n
);

129 
n_n
) {

130 -1: 
	`RETURN
(
RC_FAIL
);

131 0: 
	`RETURN
(
RC_WMORE
);

133 
	`ASN_DEBUG
("Advancing %ld in ANY case",

134 ()(
g_n
 + 
n_n
));

135 
	`ADVANCE
(
g_n
 + 
n_n
);

137 
	`as
(
gno
 < ()
td
->
gs_cou
);

139 ()
gno
;agn< ()
td
->
gs_cou
;agno++, 

++) {

144 
g_n
 = 
	`b_tch_g
(
r
, 
size
, &
v_g
);

145 
	`ASN_DEBUG
("Fetchingag from {%p,%ld}: "

147 
r
, ()
size
,

148 ()
g_n
, 

, 
gno
,

149 
	`b_v_g_rg
(
v_g
));

150 
g_n
) {

151 -1: 
	`RETURN
(
RC_FAIL
);

152 0: 
	`RETURN
(
RC_WMORE
);

155 
v_cڡr
 = 
	`BER_TLV_CONSTRUCTED
(
r
);

161 if(
g_mode
 !0 && 

 == 0) {

168 
	`as
(
gno
 >= 0);

169 if(
v_g
 !
td
->
gs
[
gno
]) {

173 
	`ASN_DEBUG
("Expected: %s, "

175 
	`b_v_g_rg
(
td
->
gs
[
gno
]),

176 
gno
, 
g_mode


178 
	`RETURN
(
RC_FAIL
);

189 if(
gno
 < (()
td
->
gs_cou
 - 1)) {

190 if(
v_cڡr
 == 0) {

191 
	`ASN_DEBUG
("tlv_constr = %d,xpfail",

192 
v_cڡr
);

193 
	`RETURN
(
RC_FAIL
);

196 if(
ϡ_g_fm
 !
v_cڡr


197 && 
ϡ_g_fm
 != -1) {

198 
	`ASN_DEBUG
("last_tag_form %d != %d",

199 
ϡ_g_fm
, 
v_cڡr
);

200 
	`RETURN
(
RC_FAIL
);

207 
n_n
 = 
	`b_tch_ngth
(
v_cڡr
,

208 (cڡ *)
r
 + 
g_n
, 
size
 -ag_n, &
v_n
);

209 
	`ASN_DEBUG
("Fchg = %ld", ()
n_n
);

210 
n_n
) {

211 -1: 
	`RETURN
(
RC_FAIL
);

212 0: 
	`RETURN
(
RC_WMORE
);

222 if(
v_n
 == -1) {

226 if(
lim_n
 == -1) {

227 
ex_00_rms
++;

229 
	`ASN_DEBUG
("Unexpected indefiniteength "

231 
	`RETURN
(
RC_FAIL
);

233 
	`ADVANCE
(
g_n
 + 
n_n
);

236 if(
ex_00_rms
) {

237 
	`ASN_DEBUG
("Unexpected definiteength "

239 
	`RETURN
(
RC_FAIL
);

247 if(
lim_n
 == -1) {

248 
lim_n
 = 
v_n
 + 
g_n
 + 
n_n
;

249 if(
lim_n
 < 0) {

251 
	`RETURN
(
RC_FAIL
);

253 } if(
lim_n
 !
v_n
 + 
g_n
 + 
n_n
) {

258 
	`ASN_DEBUG
("Outer TLV is %ldnd inner is %ld",

259 ()
lim_n
, ()
v_n
);

260 
	`RETURN
(
RC_FAIL
);

263 
	`ADVANCE
(
g_n
 + 
n_n
);

265 
lim_n
 -(
g_n
 + 
n_n
);

266 if((
ssize_t
)
size
 > 
lim_n
) {

271 
size
 = 
lim_n
;

275 if(
t_v_fm
)

276 *
t_v_fm
 = 
v_cڡr
;

277 if(
ex_00_rms
)

278 *
ϡ_ngth
 = -
ex_00_rms
;

280 *
ϡ_ngth
 = 
v_n
;

282 
	`RETURN
(
RC_OK
);

283 
	}
}

	@ber_tlv_length.c

5 
	~<a_.h
>

6 
	~<b_v_ngth.h
>

7 
	~<b_v_g.h
>

9 
ssize_t


10 
	$b_tch_ngth
(
_is_cڡrued
, cڡ *
bu
, 
size_t
 
size
,

11 
b_v_n_t
 *
n_r
) {

12 cڡ 
ut8_t
 *
buf
 = (cڡ ut8_*)
bu
;

13 
o
;

15 if(
size
 == 0)

18 
o
 = *(cڡ 
ut8_t
 *)
buf
;

19 if((
o
 & 0x80) == 0) {

23 *
n_r
 = 
o
;

26 
b_v_n_t
 
n
;

27 
size_t
 
skd
;

29 if(
_is_cڡrued
 && 
o
 == 0x80) {

30 *
n_r
 = -1;

34 if(
o
 == 0xff) {

39 
o
 &= 0x7F;

40 
n
 = 0, 
buf
++, 
skd
 = 1;

41 
o
 && (++
skd
 <
size
); 
buf
++, oct--) {

44 if(!(
n
 >> ((8 * (len)) - (8+1)))) {

45 
n
 = (<< 8| *
buf
;

52 if(
o
 == 0) {

53 if(
n
 < 0 || > 
RSSIZE_MAX
) {

58 *
n_r
 = 
n
;

59  
skd
;

65 
	}
}

67 
ssize_t


68 
	$b_sk_ngth
(cڡ 
a_codec_x_t
 *
t_codec_x
,

69 
_is_cڡrued
, cڡ *
r
, 
size_t
 
size
) {

70 
b_v_n_t
 
vn
;

71 
ssize_t
 

;

72 
ssize_t
 

;

73 
size_t
 
sk
;

78 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

84 

 = 
	`b_tch_ngth
(
_is_cڡrued
, 
r
, 
size
, &
vn
);

85 if(

 <= 0) l;

90 if(
vn
 >= 0) {

91 
sk
 = 

 + 
vn
;

92 if(
sk
 > 
size
)

94  
sk
;

100 
	`ASN_DEBUG
("Skipping indefiniteength");

101 
sk
 = 

, 
r
 = ((cڡ *+l, 
size
 -=l;;) {

102 
b_v_g_t
 
g
;

105 

 = 
	`b_tch_g
(
r
, 
size
, &
g
);

106 if(

 <= 0) l;

108 

 = 
	`b_sk_ngth
(
t_codec_x
,

109 
	`BER_TLV_CONSTRUCTED
(
r
),

110 ((cڡ *)
r
+ 

, 
size
 -l);

111 if(

 <= 0) l;

113 
sk
 +

 + 

;

120 if(((cڡ 
ut8_t
 *)
r
)[0] == 0

121 && ((cڡ 
ut8_t
 *)
r
)[1] == 0)

122  
sk
;

124 
r
 = ((cڡ *+ 

 + 

;

125 
size
 -

 + 

;

129 
	}
}

131 
size_t


132 
	$d_v_ngth_rlize
(
b_v_n_t
 
n
, *
bu
, 
size_t
 
size
) {

133 
size_t
 
qued_size
;

134 
ut8_t
 *
buf
 = (ut8_*)
bu
;

135 
ut8_t
 *
d
;

136 
i
;

138 if(
n
 <= 127) {

140 if(
size
*
buf
 = (
ut8_t
)
n
;

147 
qued_size
 = 1, 
i
 = 8; i < 8 * ()(
n
); i += 8) {

148 if(
n
 >> 
i
)

149 
qued_size
++;

154 if(
size
 <
qued_size
)

155  
qued_size
 + 1;

157 *
buf
++ = (
ut8_t
)(0x80 | 
qued_size
);

162 
d
 = 
buf
 + 
qued_size
;

163 
i
 -8; 
buf
 < 
d
; i -= 8, buf++)

164 *
buf
 = (
ut8_t
)(
n
 >> 
i
);

166  
qued_size
 + 1;

167 
	}
}

	@ber_tlv_tag.c

5 
	~<a_.h
>

6 
	~<b_v_g.h
>

7 
	~<o.h
>

9 
ssize_t


10 
	$b_tch_g
(cڡ *
r
, 
size_t
 
size
, 
b_v_g_t
 *
g_r
) {

11 
b_v_g_t
 
v
;

12 
b_v_g_t
 
tass
;

13 
size_t
 
skd
;

15 if(
size
 == 0)

18 
v
 = *(cڡ 
ut8_t
 *)
r
;

19 
tass
 = (
v
 >> 6);

20 if((
v
 &= 0x1F) != 0x1F) {

25 *
g_r
 = (
v
 << 2| 
tass
;

33 
v
 = 0, 
r
 = ((cڡ *+ 1, 
skd
 = 2;

34 
skd
 <
size
;

35 
r
 = ((cڡ *+ 1, 
skd
++) {

36 
o
 = *(cڡ 
ut8_t
 *)
r
;

37 if(
o
 & 0x80) {

38 
v
 = (v << 7| (
o
 & 0x7F);

43 if(
v
 >> ((8 * (val)) - 9)) {

51 
v
 = (v << 7| 
o
;

52 *
g_r
 = (
v
 << 2| 
tass
;

53  
skd
;

58 
	}
}

61 
ssize_t


62 
	$b_v_g_fwre
(
b_v_g_t
 
g
, 
FILE
 *
f
) {

63 
buf
[("[APPLICATION ]") + 32];

64 
ssize_t
 
t
;

66 
t
 = 
	`b_v_g_t
(
g
, 
buf
, (buf));

67 if(
t
 >(
ssize_t
)(
buf
) ||et < 2) {

68 
o
 = 
EPERM
;

72  
	`fwre
(
buf
, 1, 
t
, 
f
);

73 
	}
}

75 
ssize_t


76 
	$b_v_g_t
(
b_v_g_t
 
g
, *
buf
, 
size_t
 
size
) {

77 cڡ *
ty
 = 0;

78 
t
;

80 
g
 & 0x3) {

81 
ASN_TAG_CLASS_UNIVERSAL
: 
ty
 = "UNIVERSAL "; ;

82 
ASN_TAG_CLASS_APPLICATION
: 
ty
 = "APPLICATION "; ;

83 
ASN_TAG_CLASS_CONTEXT
: 
ty
 = ""; ;

84 
ASN_TAG_CLASS_PRIVATE
: 
ty
 = "PRIVATE "; ;

87 
t
 = 
	`tf
(
buf
, 
size
, "[%s%u]", 
ty
, (()
g
) >> 2);

88 if(
t
 <0 && 
size

buf
[0] = '\0';

90  
t
;

91 
	}
}

94 
	$b_v_g_rg
(
b_v_g_t
 
g
) {

95 
buf
[("[APPLICATION ]") + 32];

97 ()
	`b_v_g_t
(
g
, 
buf
, (buf));

99  
buf
;

100 
	}
}

103 
size_t


104 
	$b_v_g_rlize
(
b_v_g_t
 
g
, *
bu
, 
size_t
 
size
) {

105 
tass
 = 
	`BER_TAG_CLASS
(
g
);

106 
b_v_g_t
 
tv
 = 
	`BER_TAG_VALUE
(
g
);

107 
ut8_t
 *
buf
 = (ut8_*)
bu
;

108 
ut8_t
 *
d
;

109 
size_t
 
qued_size
;

110 
size_t
 
i
;

112 if(
tv
 <= 30) {

114 if(
size

buf
[0] = (
tass
 << 6| 
tv
;

116 } if(
size
) {

117 *
buf
++ = (
tass
 << 6) | 0x1F;

118 
size
--;

124 
qued_size
 = 1, 
i
 = 7; i < 8 * (
tv
); i += 7) {

125 if(
tv
 >> 
i
)

126 
qued_size
++;

131 if(
size
 < 
qued_size
)

132  
qued_size
 + 1;

137 
d
 = 
buf
 + 
qued_size
 - 1;

138 
i
 -7; 
buf
 < 
d
; i -= 7, buf++)

139 *
buf
 = 0x80 | ((
tv
 >> 
i
) & 0x7F);

140 *
buf
 = (
tv
 & 0x7F);

142  
qued_size
 + 1;

143 
	}
}

	@constr_CHOICE.c

5 
	~<a_.h
>

6 
	~<cڡr_CHOICE.h
>

7 
	~<r_ݒty.h
>

14 
	#LEFT
 ((
size
<(
size_t
)
x
->

)?size:(size_t)x->)

	)

27 
	#SIZE_VIOLATION
 (
x
->

 >0 && (
size_t
)x-> <
size
)

	)

33 #unde
ADVANCE


34 
	#ADVANCE
(
num_bys
) do { \

35 
size_t
 
num
 = 
num_bys
; \

36 
r
 = ((cڡ *+ 
num
;\

37 
size
 -
num
; \

38 if(
x
->

 >= 0) \

39 
x
->

 -
num
; \

40 
csumed_mylf
 +
num
; \

41 } 0)

	)

46 #unde
NEXT_PHASE


47 
	#NEXT_PHASE
(
x
) do { \

48 
x
->
pha
++; \

49 
x
->

 = 0; \

50 } 0)

	)

55 #unde
RETURN


56 
	#RETURN
(
_code
) do { \

57 
rv
.
code
 = 
_code
; \

58 
rv
.
csumed
 = 
csumed_mylf
;\

59  
rv
; \

60 } 0)

	)

65 
_tch_e_idx
(cڡ *
ru_r
, 
off
,

66 
size
);

67 
_t_e_idx
(*

, 
offt
, 
size
,

68 
es
);

69 cڡ *
_g_memb_r
(cڡ 
a_TYPE_dest_t
 *,

70 cڡ *

, 
a_TYPE_memb_t
 **
m
,

71 *
e
);

77 
	$_ch4g
(cڡ *

, cڡ *
bp
) {

78 cڡ 
a_TYPE_g2memb_t
 *
a
 = (cڡ_TYPE_g2memb_*)

;

79 cڡ 
a_TYPE_g2memb_t
 *
b
 = (cڡ_TYPE_g2memb_*)
bp
;

81 
a_ass
 = 
	`BER_TAG_CLASS
(
a
->
_g
);

82 
b_ass
 = 
	`BER_TAG_CLASS
(
b
->
_g
);

84 if(
a_ass
 =
b_ass
) {

85 
b_v_g_t
 
a_vue
 = 
	`BER_TAG_VALUE
(
a
->
_g
);

86 
b_v_g_t
 
b_vue
 = 
	`BER_TAG_VALUE
(
b
->
_g
);

88 if(
a_vue
 =
b_vue
)

90 if(
a_vue
 < 
b_vue
)

94 } if(
a_ass
 < 
b_ass
) {

99 
	}
}

104 
a_dec_rv_t


105 
	$CHOICE_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

106 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

107 cڡ *
r
, 
size_t
 
size
, 
g_mode
) {

111 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

112 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

113 
a_TYPE_memb_t
 *
emts
 = 
td
->elements;

118 *

 = *
ru_r
;

119 
a_ru_x_t
 *
x
;

121 
b_v_g_t
 
v_g
;

122 
ssize_t
 
g_n
;

123 
a_dec_rv_t
 
rv
;

125 
ssize_t
 
csumed_mylf
 = 0;

127 
	`ASN_DEBUG
("Decodg %aCHOICE", 
td
->
me
);

132 if(

 == 0) {

133 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

134 if(

 == 0) {

135 
	`RETURN
(
RC_FAIL
);

142 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

147 
x
->
pha
) {

155 if(
g_mode
 || 
td
->
gs_cou
) {

156 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 
x
, 
r
, 
size
,

157 
g_mode
, -1, &
x
->

, 0);

158 if(
rv
.
code
 !
RC_OK
) {

159 
	`ASN_DEBUG
("%sagging check failed: %d",

160 
td
->
me
, 
rv
.
code
);

161  
rv
;

164 if(
x
->

 >= 0) {

166 
x
->

 +
rv
.
csumed
;

168 
	`ADVANCE
(
rv
.
csumed
);

170 
x
->

 = -1;

173 
	`NEXT_PHASE
(
x
);

175 
	`ASN_DEBUG
("Structure consumes %ld bytes, buffer %ld",

176 ()
x
->

, ()
size
);

183 
g_n
 = 
	`b_tch_g
(
r
, 
LEFT
, &
v_g
);

184 
	`ASN_DEBUG
("I%CHOICEaggth %d", 
td
->
me
, ()
g_n
);

185 
g_n
) {

186 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

188 -1: 
	`RETURN
(
RC_FAIL
);

192 cڡ 
a_TYPE_g2memb_t
 *
t2m
;

193 
a_TYPE_g2memb_t
 
key
;

195 
key
.
_g
 = 
v_g
;

196 
t2m
 = (cڡ 
a_TYPE_g2memb_t
 *)
	`bch
(&
key
,

197 
ecs
->
g2
, scs->
g2_cou
,

198 (
ecs
->
g2
[0]), 
_ch4g
);

199 if(
t2m
) {

203 
	`NEXT_PHASE
(
x
);

204 
x
->

 = 
t2m
->
_no
;

206 } if(
ecs
->
ext_t
 == -1) {

207 
	`ASN_DEBUG
("Unexpectedag %s "

209 
	`b_v_g_rg
(
v_g
), 
td
->
me
);

210 
	`RETURN
(
RC_FAIL
);

213 
ssize_t
 
sk
;

215 
	`ASN_DEBUG
("Skipping unknownag %s",

216 
	`b_v_g_rg
(
v_g
));

218 
sk
 = 
	`b_sk_ngth
(
t_codec_x
,

219 
	`BER_TLV_CONSTRUCTED
(
r
),

220 (cڡ *)
r
 + 
g_n
,

221 
LEFT
 - 
g_n
);

223 
sk
) {

224 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

226 -1: 
	`RETURN
(
RC_FAIL
);

229 
	`ADVANCE
(
sk
 + 
g_n
);

230 
	`RETURN
(
RC_OK
);

240 
a_TYPE_memb_t
 *
m
;

241 *
memb_r
;

242 **
memb_r2
;

244 
m
 = &
emts
[
x
->

];

251 if(
m
->
ags
 & 
ATF_POINTER
) {

253 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

259 
memb_r
 = (*)

 + 
m
->
memb_offt
;

260 
memb_r2
 = &
memb_r
;

263 
	`_t_e_idx
(

, 
ecs
->
es_offt
,

264 
ecs
->
es_size
, 
x
->

 + 1);

268 
rv
 = 
m
->
ty
->

->
	`b_decod
(
t_codec_x
,lm->type,

269 
memb_r2
, 
r
, 
LEFT
, 
m
->
g_mode
);

270 
rv
.
code
) {

271 
RC_OK
:

273 
RC_WMORE
:

274 if(!
SIZE_VIOLATION
) {

275 
	`ADVANCE
(
rv
.
csumed
);

276 
	`RETURN
(
RC_WMORE
);

278 
	`RETURN
(
RC_FAIL
);

279 
RC_FAIL
:

280 
	`RETURN
(
rv
.
code
);

283 
	`ADVANCE
(
rv
.
csumed
);

286 
	`NEXT_PHASE
(
x
);

290 
	`ASN_DEBUG
("CHOICE %s Leftover: %ld, size = %ld,m=%d,c=%d",

291 
td
->
me
, ()
x
->

, ()
size
,

292 
g_mode
, 
td
->
gs_cou
);

294 if(
x
->

 > 0) {

299 
	`RETURN
(
RC_FAIL
);

302 if(
x
->

 == -1

303 && !(
g_mode
 || 
td
->
gs_cou
)) {

310 
	`NEXT_PHASE
(
x
);

317 
x
->

 < 0) {

318 
ssize_t
 

;

320 

 = 
	`b_tch_g
(
r
, 
LEFT
, &
v_g
);

321 

) {

322 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

324 -1: 
	`RETURN
(
RC_FAIL
);

330 if(((cڡ 
ut8_t
 *)
r
)[0] == 0) {

331 if(
LEFT
 < 2) {

332 if(
SIZE_VIOLATION
)

333 
	`RETURN
(
RC_FAIL
);

335 
	`RETURN
(
RC_WMORE
);

336 } if(((cڡ 
ut8_t
 *)
r
)[1] == 0) {

340 
	`ADVANCE
(2);

341 
x
->

++;

345 
	`ASN_DEBUG
("Unexpected continuation in %s",

346 
td
->
me
);

347 
	`RETURN
(
RC_FAIL
);

353 
	`NEXT_PHASE
(
x
);

359 
	`RETURN
(
RC_OK
);

360 
	}
}

362 
a_c_rv_t


363 
	$CHOICE_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

364 
g_mode
, 
b_v_g_t
 
g
, 
a_p_csume_bys_f
 *
cb
,

365 *
p_key
) {

366 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

367 
a_TYPE_memb_t
 *
m
;

368 
a_c_rv_t
 
v
 = {0,0,0};

369 cڡ *
memb_r
;

370 
size_t
 
compud_size
 = 0;

371 
e
;

373 if(!


ASN__ENCODE_FAILED
;

375 
	`ASN_DEBUG
("%s %ss CHOICE",

376 
cb
?"Encodg":"Eimg", 
td
->
me
);

378 
e
 = 
	`_tch_e_idx
(

,

379 
ecs
->
es_offt
, scs->
es_size
);

385 if(
e
 =0 || > 
td
->
emts_cou
) {

386 if(
e
 =0 && 
td
->
emts_cou
 == 0) {

388 
v
.
coded
 = 0;

389 
	`ASN__ENCODED_OK
(
v
);

391 
ASN__ENCODE_FAILED
;

397 
m
 = &
td
->
emts
[
e
-1];

398 if(
m
->
ags
 & 
ATF_POINTER
) {

399 
memb_r
 =

400 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

401 if(
memb_r
 == 0) {

402 if(
m
->
tiڮ
) {

403 
v
.
coded
 = 0;

404 
	`ASN__ENCODED_OK
(
v
);

407 
ASN__ENCODE_FAILED
;

410 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

418 if(
g_mode
 =1 || 
td
->
gs_cou
) {

422 
ssize_t
 
t
;

425 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
,

426 
m
->
g_mode
,lm->
g
, 0, 0);

427 if(
v
.
coded
 == -1)

428  
v
;

431 
t
 = 
	`d_wre_gs
(
td
, 
v
.
coded
, 
g_mode
, 1, 
g
,

432 
cb
, 
p_key
);

433 if(
t
 == -1)

434 
ASN__ENCODE_FAILED
;

435 
compud_size
 +
t
;

441 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
,

442 
m
->
g_mode
,lm->
g
, 
cb
, 
p_key
);

443 if(
v
.
coded
 == -1)

444  
v
;

446 
	`ASN_DEBUG
("Encoded CHOICE member in %ld bytes (+%ld)",

447 ()
v
.
coded
, ()
compud_size
);

449 
v
.
coded
 +
compud_size
;

451  
v
;

452 
	}
}

454 
b_v_g_t


455 
	$CHOICE_outmo_g
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
r
, 
g_mode
, 
b_v_g_t
 
g
) {

456 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

457 
e
;

459 
	`as
(
g_mode
 == 0); ()tag_mode;

460 
	`as
(
g
 == 0); ()tag;

465 
e
 = 
	`_tch_e_idx
(
r
, 
ecs
->
es_offt
, scs->
es_size
);

467 if(
e
 > 0 && <
td
->
emts_cou
) {

468 cڡ 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
e
-1];

469 cڡ *
memb_r
;

471 if(
m
->
ags
 & 
ATF_POINTER
) {

472 
memb_r
 = *(const * const *)

473 ((cڡ *)
r
 + 
m
->
memb_offt
);

475 
memb_r
 = (const *)

476 ((cڡ *)
r
 + 
m
->
memb_offt
);

479  
	`a_TYPE_outmo_g
(
m
->
ty
, 
memb_r
,

480 
m
->
g_mode
,lm->
g
);

482  (
b_v_g_t
)-1;

484 
	}
}

487 
	$CHOICE_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

488 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

489 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

490 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

491 
e
;

493 if(!

) {

494 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

496 
td
->
me
, 
__FILE__
, 
__LINE__
);

503 
e
 = 
	`_tch_e_idx
(

, 
ecs
->
es_offt
,ecs->
es_size
);

504 if(
e
 > 0 && <
td
->
emts_cou
) {

505 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
e
-1];

506 cڡ *
memb_r
;

508 if(
m
->
ags
 & 
ATF_POINTER
) {

509 
memb_r
 = *(cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

510 if(!
memb_r
) {

511 if(
m
->
tiڮ
)

513 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

515 
td
->
me
, 
m
->me, 
__FILE__
, 
__LINE__
);

519 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

522 if(
m
->
codg_cڡts
.
g_cڡts
) {

523  
m
->
codg_cڡts
.
	`g_cڡts
lm->
ty
, 
memb_r
,

524 
cb
, 
p_key
);

526  
m
->
ty
->
codg_cڡts
.
	`g_cڡts
(elm->type,

527 
memb_r
, 
cb
, 
p_key
);

530 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

532 
td
->
me
, 
__FILE__
, 
__LINE__
);

535 
	}
}

537 #unde
XER_ADVANCE


538 
	#XER_ADVANCE
(
num_bys
) do { \

539 
size_t
 
num
 = 
num_bys
; \

540 
buf_r
 = (cڡ *)(((cڡ *)buf_r+ 
num
); \

541 
size
 -
num
; \

542 
csumed_mylf
 +
num
; \

543 } 0)

	)

548 
a_dec_rv_t


549 
	$CHOICE_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

550 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

551 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

555 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

556 cڡ *
xml_g
 = 
t_mme
 ? o_mm: 
td
->xml_tag;

561 *

 = *
ru_r
;

562 
a_ru_x_t
 *
x
;

564 
a_dec_rv_t
 
rv
;

565 
ssize_t
 
csumed_mylf
 = 0;

566 
size_t
 
edx
;

571 if(

 == 0) {

572 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

573 if(

 =0
	`RETURN
(
RC_FAIL
);

579 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

580 if(
x
->
pha
 =0 && !*
xml_g
)

581 
x
->
pha
 = 1;

592 
edx
 = 
x
->

; ctx->
pha
 <= 4;) {

593 
px_chunk_ty_e
 
ch_ty
;

594 
ssize_t
 
ch_size
;

595 
x_check_g_e
 
tcv
;

596 
a_TYPE_memb_t
 *
m
;

601 if(
x
->
pha
 == 2) {

602 
a_dec_rv_t
 
tmv
;

603 *
memb_r
;

604 **
memb_r2
;

605 
d_e
;

607 
m
 = &
td
->
emts
[
edx
];

609 if(
m
->
ags
 & 
ATF_POINTER
) {

611 
memb_r2
 = (**)((*)



612 + 
m
->
memb_offt
);

614 
memb_r
 = (*)

 + 
m
->
memb_offt
;

615 
memb_r2
 = &
memb_r
;

619 
tmv
 = 
m
->
ty
->

->
	`x_decod
(
t_codec_x
,

620 
m
->
ty
, 
memb_r2
,lm->
me
,

621 
buf_r
, 
size
);

622 
	`XER_ADVANCE
(
tmv
.
csumed
);

623 
	`ASN_DEBUG
("XER/CHOICE: itdf: [%s] code=%d",

624 
m
->
ty
->
me
, 
tmv
.
code
);

625 
d_e
 = 
	`_tch_e_idx
(

,

626 
ecs
->
es_offt
, scs->
es_size
);

627 
	`as
(
d_e
 =0 || old_e =
edx
 + 1);

629 
	`_t_e_idx
(

,

630 
ecs
->
es_offt
, scs->
es_size
, 
edx
 + 1);

631 if(
tmv
.
code
 !
RC_OK
)

632 
	`RETURN
(
tmv
.
code
);

633 
x
->
pha
 = 3;

638 if(
x
->
pha
 =3 && !*
xml_g
) {

639 
x
->
pha
 = 5;

640 
	`RETURN
(
RC_OK
);

646 
ch_size
 = 
	`x_xt_tok
(&
x
->
cڋxt
, 
buf_r
, 
size
, &
ch_ty
);

647 if(
ch_size
 == -1) {

648 
	`RETURN
(
RC_FAIL
);

650 
ch_ty
) {

651 
PXER_WMORE
:

652 
	`RETURN
(
RC_WMORE
);

653 
PXER_COMMENT
:

654 
PXER_TEXT
:

655 
	`XER_ADVANCE
(
ch_size
);

657 
PXER_TAG
:

662 
tcv
 = 
	`x_check_g
(
buf_r
, 
ch_size
, 
xml_g
);

663 
	`ASN_DEBUG
("XER/CHOICE checked [%c%c%c%c] vs [%s],cv=%d",

664 
ch_size
>0?((cڡ 
ut8_t
 *)
buf_r
)[0]:'?',

665 
ch_size
>1?((cڡ 
ut8_t
 *)
buf_r
)[1]:'?',

666 
ch_size
>2?((cڡ 
ut8_t
 *)
buf_r
)[2]:'?',

667 
ch_size
>3?((cڡ 
ut8_t
 *)
buf_r
)[3]:'?',

668 
xml_g
, 
tcv
);

671 if(
x
->
pha
 == 4) {

672 
	`ASN_DEBUG
("skip_unknown(%d, %ld)",

673 
tcv
, ()
x
->

);

674 
	`x_sk_unknown
(
tcv
, &
x
->

)) {

676 
x
->
pha
 = 5;

677 
	`RETURN
(
RC_FAIL
);

679 
x
->
pha
 = 3;

682 
	`XER_ADVANCE
(
ch_size
);

685 
x
->
pha
 = 3;

690 
tcv
) {

691 
XCT_BOTH
:

693 
XCT_CLOSING
:

694 if(
x
->
pha
 != 3)

696 
	`XER_ADVANCE
(
ch_size
);

697 
x
->
pha
 = 5;

698 
	`RETURN
(
RC_OK
);

699 
XCT_OPENING
:

700 if(
x
->
pha
 == 0) {

701 
	`XER_ADVANCE
(
ch_size
);

702 
x
->
pha
 = 1;

706 
XCT_UNKNOWN_OP
:

707 
XCT_UNKNOWN_BO
:

709 if(
x
->
pha
 != 1)

715 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

716 
m
 = &
td
->
emts
[
edx
];

717 
tcv
 = 
	`x_check_g
(
buf_r
,
ch_size
,
m
->
me
);

718 
tcv
) {

719 
XCT_BOTH
:

720 
XCT_OPENING
:

724 
x
->

 = 
edx
;

725 
x
->
pha
 = 2;

727 
XCT_UNKNOWN_OP
:

728 
XCT_UNKNOWN_BO
:

731 
edx
 = 
td
->
emts_cou
;

736 if(
edx
 !
td
->
emts_cou
)

740 if(
ecs
->
ext_t
 != -1) {

741 
	`ASN_DEBUG
("Gotnticipatedxtension");

747 if(
tcv
 & 
XCT_CLOSING
) {

749 
x
->
pha
 = 3;

751 
x
->

 = 1;

752 
x
->
pha
 = 4;

754 
	`XER_ADVANCE
(
ch_size
);

763 
	`ASN_DEBUG
("Unexpected XMLag [%c%c%c%c] in CHOICE [%s]"

765 
ch_size
>0?((cڡ 
ut8_t
 *)
buf_r
)[0]:'?',

766 
ch_size
>1?((cڡ 
ut8_t
 *)
buf_r
)[1]:'?',

767 
ch_size
>2?((cڡ 
ut8_t
 *)
buf_r
)[2]:'?',

768 
ch_size
>3?((cڡ 
ut8_t
 *)
buf_r
)[3]:'?',

769 
td
->
me
, 
x
->
pha
, 
xml_g
);

773 
x
->
pha
 = 5;

774 
	`RETURN
(
RC_FAIL
);

775 
	}
}

778 
a_c_rv_t


779 
	$CHOICE_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

780 
x_cod_ags_e
 
ags
, 
a_p_csume_bys_f
 *
cb
,

781 *
p_key
) {

782 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

783 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

784 
a_c_rv_t
 

 = {0,0,0};

785 
e
 = 0;

787 if(!

)

788 
ASN__ENCODE_FAILED
;

793 
e
 = 
	`_tch_e_idx
(

, 
ecs
->
es_offt
,ecs->
es_size
);

795 if(
e
 =0 || > 
td
->
emts_cou
) {

796 
ASN__ENCODE_FAILED
;

798 
a_c_rv_t
 
tmr
 = {0,0,0};

799 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
e
-1];

800 cڡ *
memb_r
 = 
NULL
;

801 cڡ *
mme
 = 
m
->
me
;

802 
mn
 = 
	`
(
mme
);

804 if(
m
->
ags
 & 
ATF_POINTER
) {

805 
memb_r
 =

806 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

807 if(!
memb_r

ASN__ENCODE_FAILED
;

809 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

812 

.
coded
 = 0;

814 if(!(
ags
 & 
XER_F_CANONICAL
)
	`ASN__TEXT_INDENT
(1, 
ev
);

815 
	`ASN__CALLBACK3
("<", 1, 
mme
, 
mn
, ">", 1);

817 
tmr
 = 
m
->
ty
->

->
	`x_cod
lm->ty, 
memb_r
,

818 
ev
 + 1, 
ags
, 
cb
, 
p_key
);

819 if(
tmr
.
coded
 == -1) mper;

820 

.
coded
 +
tmr
.encoded;

822 
	`ASN__CALLBACK3
("</", 2, 
mme
, 
mn
, ">", 1);

825 if(!(
ags
 & 
XER_F_CANONICAL
)
	`ASN__TEXT_INDENT
(1, 
ev
 - 1);

827 
	`ASN__ENCODED_OK
(

);

828 
cb_ed
:

829 
ASN__ENCODE_FAILED
;

830 
	}
}

832 
a_dec_rv_t


833 
	$CHOICE_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

834 cڡ 
a_TYPE_dest_t
 *
td
,

835 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

836 
a_r_da_t
 *
pd
) {

837 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

838 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

839 
a_dec_rv_t
 
rv
;

840 cڡ 
a_r_cڡt_t
 *

;

841 
a_TYPE_memb_t
 *
m
;

842 *
memb_r
;

843 **
memb_r2
;

844 *

 = *

;

845 
vue
;

847 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

848 
ASN__DECODE_FAILED
;

853 if(!

) {

854 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

855 if(!


ASN__DECODE_FAILED
;

858 if(
cڡts


 = &cڡts->
vue
;

859 if(
td
->
codg_cڡts
.
r_cڡts


 = &td->codg_cڡts.r_cڡts->
vue
;

860 

 = 0;

862 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

863 
vue
 = 
	`r_g_w_bs
(
pd
, 1);

864 if(
vue
 < 0
ASN__DECODE_STARVED
;

865 if(
vue


 = 0;

868 if(

 && ct->
nge_bs
 >= 0) {

869 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

870 if(
vue
 < 0
ASN__DECODE_STARVED
;

871 
	`ASN_DEBUG
("CHOICE %s got index %d inange %d",

872 
td
->
me
, 
vue
, 

->
nge_bs
);

873 if(
vue
 > 

->
u_bound
)

874 
ASN__DECODE_FAILED
;

876 if(
ecs
->
ext_t
 == -1)

877 
ASN__DECODE_FAILED
;

878 
vue
 = 
	`ur_g_nnwn
(
pd
);

879 if(
vue
 < 0
ASN__DECODE_STARVED
;

880 
vue
 +
ecs
->
ext_t
;

881 if(()
vue
 >
td
->
emts_cou
)

882 
ASN__DECODE_FAILED
;

886 if(
ecs
->
om_nil_d
) {

887 
	`ASN_DEBUG
("CHOICEn from w%d", 
vue
);

888 
vue
 = 
ecs
->
om_nil_d
[value];

889 
	`ASN_DEBUG
("CHOICEn indexfiv%d", 
vue
);

893 
	`_t_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
, 
vue
 + 1);

895 
m
 = &
td
->
emts
[
vue
];

896 if(
m
->
ags
 & 
ATF_POINTER
) {

898 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

900 
memb_r
 = (*)

 + 
m
->
memb_offt
;

901 
memb_r2
 = &
memb_r
;

903 
	`ASN_DEBUG
("Discoved CHOICE %code%s", 
td
->
me
, 
m
->name);

905 if(

 && ct->
nge_bs
 >= 0) {

906 
rv
 = 
m
->
ty
->

->
	`ur_decod
(
t_codec_x
,lm->type,

907 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

909 
rv
 = 
	`ur_ݒ_ty_g
(
t_codec_x
, 
m
->
ty
,

910 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

913 if(
rv
.
code
 !
RC_OK
)

914 
	`ASN_DEBUG
("Failedo decode %s in %s (CHOICE) %d",

915 
m
->
me
, 
td
->me, 
rv
.
code
);

916  
rv
;

917 
	}
}

919 
a_c_rv_t


920 
	$CHOICE_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

921 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

922 
a_r_ou_t
 *
po
) {

923 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

924 
a_TYPE_memb_t
 *
m
;

925 cڡ 
a_r_cڡt_t
 *

;

926 cڡ *
memb_r
;

927 
e
;

928 
e_c
;

930 if(!


ASN__ENCODE_FAILED
;

932 
	`ASN_DEBUG
("Encodg %aCHOICE", 
td
->
me
);

934 if(
cڡts


 = &cڡts->
vue
;

935 if(
td
->
codg_cڡts
.
r_cڡts
)

936 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

937 

 = 0;

939 
e
 = 
	`_tch_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
);

945 if(
e
 =0 || > 
td
->
emts_cou
)

946 
ASN__ENCODE_FAILED
;

948 
e
--;

950 
	`ASN_DEBUG
("Encodg %CHOICEm%d", 
td
->
me
, 
e
);

953 if(
ecs
->
to_nil_d
)

954 
e_c
 = 
ecs
->
to_nil_d
[
e
];

956 
e_c
 = 
e
;

958 if(

 && ct->
nge_bs
 >= 0) {

959 if(
e_c
 < 

->
low_bound


960 || 
e_c
 > 

->
u_bound
) {

961 if(

->
ags
 & 
APC_EXTENSIBLE
) {

962 
	`ASN_DEBUG
(

964 
e
, 
e_c
, 

->
low_bound
, ct->
u_bound
);

965 if(
	`r_put_w_bs
(
po
, 1, 1))

966 
ASN__ENCODE_FAILED
;

968 
ASN__ENCODE_FAILED
;

970 

 = 0;

973 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

974 
	`ASN_DEBUG
("CHOICE member %d (enc %d) isotnxtension (%ld..%ld)",

975 
e
, 
e_c
, 

->
low_bound
, ct->
u_bound
);

976 if(
	`r_put_w_bs
(
po
, 0, 1))

977 
ASN__ENCODE_FAILED
;

981 
m
 = &
td
->
emts
[
e
];

982 
	`ASN_DEBUG
("CHOICE memb \"%s\" %d (a%d)", 
m
->
me
, 
e
,

983 
e_c
);

984 if(
m
->
ags
 & 
ATF_POINTER
) {

986 
memb_r
 =

987 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

988 if(!
memb_r

ASN__ENCODE_FAILED
;

990 
memb_r
 = (cڡ *)

 + 
m
->
memb_offt
;

993 if(

 && ct->
nge_bs
 >= 0) {

994 if(
	`r_put_w_bs
(
po
, 
e_c
, 

->
nge_bs
))

995 
ASN__ENCODE_FAILED
;

997  
m
->
ty
->

->
	`ur_cod
(

998 
m
->
ty
,lm->
codg_cڡts
.
r_cڡts
, 
memb_r
, 
po
);

1000 
a_c_rv_t
 
rv
 = {0,0,0};

1001 if(
ecs
->
ext_t
 =-1
ASN__ENCODE_FAILED
;

1002 if(
	`ur_put_nnwn
(
po
, 
e_c
 - 
ecs
->
ext_t
))

1003 
ASN__ENCODE_FAILED
;

1004 if(
	`ur_ݒ_ty_put
(
m
->
ty
,

1005 
m
->
codg_cڡts
.
r_cڡts
,

1006 
memb_r
, 
po
))

1007 
ASN__ENCODE_FAILED
;

1008 
rv
.
coded
 = 0;

1009 
	`ASN__ENCODED_OK
(
rv
);

1011 
	}
}

1013 
a_dec_rv_t


1014 
	$CHOICE_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1015 cڡ 
a_TYPE_dest_t
 *
td
,

1016 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

1017 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

1018 
a_dec_rv_t
 
rv
;

1019 cڡ 
a_r_cڡt_t
 *

;

1020 cڡ 
a_r_cڡt_t
 *
ext_
 = 
NULL
;

1021 
a_TYPE_memb_t
 *
m
;

1022 *
memb_r
;

1023 **
memb_r2
;

1024 *

 = *

;

1025 
vue
;

1027 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

1028 
ASN__DECODE_FAILED
;

1033 if(!

) {

1034 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

1035 if(!


ASN__DECODE_FAILED
;

1038 if(
cڡts


 = &cڡts->
vue
;

1039 if(
td
->
codg_cڡts
.
r_cڡts
)

1040 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

1041 

 = 0;

1043 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

1044 
vue
 = 
	`r_g_w_bs
(
pd
, 1);

1045 if(
vue
 < 0
ASN__DECODE_STARVED
;

1046 if(
vue
) {

1047 
ext_
 = 

;

1048 

 = 0;

1053 if(

 && ct->
nge_bs
 >= 0) {

1054 
vue
 = 
	`r_g_w_bs
(
pd
, 

->
nge_bs
);

1055 if(
vue
 < 0
ASN__DECODE_STARVED
;

1056 
	`ASN_DEBUG
("CHOICE %s got index %d inange %d",

1057 
td
->
me
, 
vue
, 

->
nge_bs
);

1058 if(
vue
 > 

->
u_bound
)

1059 
ASN__DECODE_FAILED
;

1061 if(
ecs
->
ext_t
 == -1)

1062 
ASN__DECODE_FAILED
;

1063 
vue
 = 
	`_g_nnwn
(
pd
, 
ext_
->
nge_bs
);

1064 if(
vue
 < 0
ASN__DECODE_STARVED
;

1065 
vue
 +
ecs
->
ext_t
;

1066 if(()
vue
 >
td
->
emts_cou
)

1067 
ASN__DECODE_FAILED
;

1071 if(
ecs
->
om_nil_d
)

1072 
vue
 = 
ecs
->
om_nil_d
[value];

1075 
	`_t_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
, 
vue
 + 1);

1077 
m
 = &
td
->
emts
[
vue
];

1078 if(
m
->
ags
 & 
ATF_POINTER
) {

1080 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1082 
memb_r
 = (*)

 + 
m
->
memb_offt
;

1083 
memb_r2
 = &
memb_r
;

1085 
	`ASN_DEBUG
("Discoved CHOICE %code%s", 
td
->
me
, 
m
->name);

1087 if(

 && ct->
nge_bs
 >= 0) {

1088 
rv
 = 
m
->
ty
->

->
	`_decod
(
t_codec_x
,lm->type,

1089 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

1091 
rv
 = 
	`_ݒ_ty_g
(
t_codec_x
, 
m
->
ty
,

1092 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

1095 if(
rv
.
code
 !
RC_OK
)

1096 
	`ASN_DEBUG
("Failedo decode %s in %s (CHOICE) %d",

1097 
m
->
me
, 
td
->me, 
rv
.
code
);

1098  
rv
;

1099 
	}
}

1101 
a_c_rv_t


1102 
	$CHOICE_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

1103 cڡ 
a_r_cڡts_t
 *
cڡts
,

1104 cڡ *

, 
a_r_ou_t
 *
po
) {

1105 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

1106 cڡ 
a_TYPE_memb_t
 *
m
;

1107 cڡ 
a_r_cڡt_t
 *

 = 
NULL
;

1108 cڡ 
a_r_cڡt_t
 *
ext_
 = 
NULL
;

1109 cڡ *
memb_r
;

1110 
e
;

1111 
e_c
;

1113 if(!


ASN__ENCODE_FAILED
;

1115 
	`ASN_DEBUG
("Encodg %aCHOICE usg ALIGNED PER", 
td
->
me
);

1117 if(
cڡts


 = &cڡts->
vue
;

1118 if(
td
->
codg_cڡts
.
r_cڡts
)

1119 

 = &
td
->
codg_cڡts
.
r_cڡts
->
vue
;

1120 

 = 
NULL
;

1122 
e
 = 
	`_tch_e_idx
(

,

1123 
ecs
->
es_offt
, scs->
es_size
);

1129 if(
e
 <0 || ( > 
td
->
emts_cou
)

1130 
ASN__ENCODE_FAILED
;

1132 
e
--;

1135 if(
ecs
->
to_nil_d
)

1136 
e_c
 = 
ecs
->
to_nil_d
[
e
];

1138 
e_c
 = 
e
;

1140 
	`ASN_DEBUG
("Encodg %CHOICEm%d", 
td
->
me
, 
e
);

1142 if(

 && (->
nge_bs
 >= 0)) {

1144 if(
e
 < 

->
low_bound
 || > ct->
u_bound
) {

1145 if(

->
ags
 & 
APC_EXTENSIBLE
) {

1146 
	`ASN_DEBUG
("CHOICE member %d (enc %d) isnxtension (%ld..%ld)",

1147 
e
, 
e_c
, 

->
low_bound
, ct->
u_bound
);

1149 if(
	`r_put_w_bs
(
po
, 1, 1)) {

1150 
ASN__ENCODE_FAILED
;

1153 
ASN__ENCODE_FAILED
;

1156 
ext_
 = 

;

1157 

 = 
NULL
;

1161 if(

 && (->
ags
 & 
APC_EXTENSIBLE
)) {

1162 
	`ASN_DEBUG
("CHOICE member %d (enc %d) isotnxtension (%ld..%ld)",

1163 
e
,, 

->
low_bound
, ct->
u_bound
);

1165 if(
	`r_put_w_bs
(
po
, 0, 1)) {

1166 
ASN__ENCODE_FAILED
;

1170 
m
 = &
td
->
emts
[
e
];

1171 if(
m
->
ags
 & 
ATF_POINTER
) {

1173 
memb_r
 = *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1174 if(!
memb_r

ASN__ENCODE_FAILED
;

1176 
memb_r
 = (cڡ *)

 + 
m
->
memb_offt
;

1179 if(

 && (->
nge_bs
 >= 0)) {

1182 if(
	`r_put_w_bs
(
po
, 
e_c
, 

->
nge_bs
))

1183 
ASN__ENCODE_FAILED
;

1185  
m
->
ty
->

->
	`_cod
lm->ty,lm->
codg_cڡts
.
r_cڡts
,

1186 
memb_r
, 
po
);

1188 
a_c_rv_t
 
rv
 = {0,0,0};

1189 if(
ecs
->
ext_t
 == -1)

1190 
ASN__ENCODE_FAILED
;

1193 if(
ext_
 && 
	`_put_nnwn
(
po
,xt_->
nge_bs
, 
e_c
 - 
ecs
->
ext_t
))

1194 
ASN__ENCODE_FAILED
;

1195 if(
	`_ݒ_ty_put
(
m
->
ty
,lm->
codg_cڡts
.
r_cڡts
,

1196 
memb_r
, 
po
))

1197 
ASN__ENCODE_FAILED
;

1198 
rv
.
coded
 = 0;

1199 
	`ASN__ENCODED_OK
(
rv
);

1201 
	}
}

1204 
	$CHOICE_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

1205 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

1206 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 = (cڡ_CHOICE_ecifics_*)
td
->
ecifics
;

1207 
e
;

1209 if(!

 (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

1214 
e
 = 
	`_tch_e_idx
(

, 
ecs
->
es_offt
,ecs->
es_size
);

1219 if(
e
 > 0 && <
td
->
emts_cou
) {

1220 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
e
-1];

1221 cڡ *
memb_r
;

1223 if(
m
->
ags
 & 
ATF_POINTER
) {

1224 
memb_r
 = *(cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1225 if(!
memb_r
 (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

1227 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1232 if(
	`cb
(
m
->
me
, 
	`
lm->me), 
p_key
) < 0

1233 || 
	`cb
(": ", 2, 
p_key
) < 0)

1237  
m
->
ty
->

->
	`t_ru
lm->ty, 
memb_r
, 
ev
,

1238 
cb
, 
p_key
);

1240  (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

1242 
	}
}

1245 
	$CHOICE_
(cڡ 
a_TYPE_dest_t
 *
td
, *
r
,

1246 
a_ru__mhod
 
mhod
) {

1247 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

1248 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

1249 
e
;

1251 if(!
td
 || !
r
)

1254 
	`ASN_DEBUG
("Feg %aCHOICE", 
td
->
me
);

1259 
e
 = 
	`_tch_e_idx
(
r
, 
ecs
->
es_offt
, scs->
es_size
);

1264 if(
e
 > 0 && <
td
->
emts_cou
) {

1265 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
e
-1];

1266 *
memb_r
;

1268 if(
m
->
ags
 & 
ATF_POINTER
) {

1269 
memb_r
 = *(**)((*)
r
 + 
m
->
memb_offt
);

1270 if(
memb_r
)

1271 
	`ASN_STRUCT_FREE
(*
m
->
ty
, 
memb_r
);

1273 
memb_r
 = (*)((*)
r
 + 
m
->
memb_offt
);

1274 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(*
m
->
ty
, 
memb_r
);

1278 
mhod
) {

1279 
ASFM_FREE_EVERYTHING
:

1280 
	`FREEMEM
(
r
);

1282 
ASFM_FREE_UNDERLYING
:

1284 
ASFM_FREE_UNDERLYING_AND_RESET
:

1285 
	`memt
(
r
, 0, 
ecs
->
ru_size
);

1288 
	}
}

1301 
	$_tch_e_idx
(cڡ *
ru_r
, 
es_offt
,

1302 
es_size
) {

1303 cڡ *
e_r
;

1304 
e
;

1306 
e_r
 = ((cڡ *)
ru_r
+ 
es_offt
;

1308 
es_size
) {

1309 (): 
e
 = *(cڡ *)
e_r
; ;

1310 (): 
e
 = *(cڡ *)
e_r
; ;

1311 (): 
e
 = *(cڡ *)
e_r
; ;

1314 
	`as
(
es_size
 != ());

1318  
e
;

1319 
	}
}

1322 
	$_t_e_idx
(*
ru_r
, 
es_offt
, 
es_size
,

1323 
e
) {

1324 *
e_r
;

1325 
e_r
 = ((*)
ru_r
+ 
es_offt
;

1327 
es_size
) {

1328 (): *(*)
e_r
 = 
e
; ;

1329 (): *(*)
e_r
 = 
e
; ;

1330 (): *(*)
e_r
 = 
e
; ;

1333 
	`as
(
es_size
 != ());

1335 
	}
}

1338 
	$_g_memb_r
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1339 
a_TYPE_memb_t
 **
m_r
, *
e_out
) {

1340 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

1341 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

1342 
e
;

1344 if(!

) {

1345 *
m_r
 = 
NULL
;

1346 *
e_out
 = 0;

1347  
NULL
;

1353 
e
 = 
	`_tch_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
);

1354 *
e_out
 = 
e
;

1360 if(
e
 > 0 && <
td
->
emts_cou
) {

1361 
a_TYPE_memb_t
 *cڡ 
m
 = &
td
->
emts
[
e
 - 1];

1362 cڡ *
memb_r
;

1364 if(
m
->
ags
 & 
ATF_POINTER
) {

1365 
memb_r
 =

1366 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1368 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1370 *
m_r
 = 
m
;

1371  
memb_r
;

1373 *
m_r
 = 
NULL
;

1374  
NULL
;

1377 
	}
}

1380 
	$CHOICE_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, cڡ *
br
) {

1381 
a_TYPE_memb_t
 *
lm
;

1382 
a_TYPE_memb_t
 *
bm
;

1383 

 = 0;

1384 
be
 = 0;

1385 cڡ *
amemb
 = 
	`_g_memb_r
(
td
, 

, &
lm
, &

);

1386 cڡ *
bmemb
 = 
	`_g_memb_r
(
td
, 
br
, &
bm
, &
be
);

1388 if(
amemb
 && 
bmemb
) {

1389 if(

 =
be
) {

1390 
	`as
(
lm
 =
bm
);

1391  
lm
->
ty
->

->
	`com_ru
זm->ty, 
amemb
, 
bmemb
);

1392 } if(

 < 
be
) {

1397 } if(!
amemb
) {

1402 
	}
}

1409 
	$CHOICE_v_g_en
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

) {

1410 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

1411 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

1412  
	`_tch_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
);

1413 
	}
}

1422 
	$CHOICE_v_t_en
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

1423 
e
) {

1424 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

1425 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

1426 
d_e
;

1428 if(!

) {

1432 if(
e
 > 
td
->
emts_cou
)

1435 
d_e
 =

1436 
	`_tch_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
);

1437 if(
e
 =
d_e
)

1440 if(
d_e
 != 0) {

1441 
	`as
(
d_e
 <
td
->
emts_cou
);

1442 
	`ASN_STRUCT_RESET
(*
td
, 

);

1445 
	`_t_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
, 
e
);

1448 
	}
}

1451 
a_ndom_fl_su_t


1452 
	$CHOICE_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

1453 cڡ 
a_codg_cڡts_t
 *
cڡr
,

1454 
size_t
 
max_ngth
) {

1455 cڡ 
a_CHOICE_ecifics_t
 *
ecs
 =

1456 (cڡ 
a_CHOICE_ecifics_t
 *)
td
->
ecifics
;

1457 
a_ndom_fl_su_t
 
s
;

1458 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

1459 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

1460 cڡ 
a_TYPE_memb_t
 *
m
;

1461 
e
;

1462 *
memb_r
;

1463 **
memb_r2
;

1464 *

 = *

;

1466 if(
max_ngth
 =0 
su_skd
;

1468 ()
cڡr
;

1470 if(

 =
NULL
) {

1471 

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

1472 if(

 =
NULL
) {

1473  
su_ed
;

1477 
e
 = 
	`a_ndom_bwn
(1, 
td
->
emts_cou
);

1478 
m
 = &
td
->
emts
[
e
 - 1];

1480 if(
m
->
ags
 & 
ATF_POINTER
) {

1482 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1484 
memb_r
 = (*)

 + 
m
->
memb_offt
;

1485 
memb_r2
 = &
memb_r
;

1488 
s
 = 
m
->
ty
->

->
	`ndom_fl
lm->ty, 
memb_r2
,

1489 &
m
->
codg_cڡts
, 
max_ngth
);

1490 
	`_t_e_idx
(

, 
ecs
->
es_offt
, scs->
es_size
, 
e
);

1491 if(
s
.
code
 =
ARFILL_OK
) {

1492 *

 = 

;

1494 if(

 =*

) {

1495 
	`ASN_STRUCT_RESET
(*
td
, 

);

1497 
	`ASN_STRUCT_FREE
(*
td
, 

);

1501  
s
;

1502 
	}
}

1505 
a_TYPE_ݔi_t
 
	ga_OP_CHOICE
 = {

1506 
CHOICE_
,

1507 
CHOICE_t
,

1508 
CHOICE_com
,

1509 
CHOICE_decode_b
,

1510 
CHOICE_code_d
,

1511 
CHOICE_decode_x
,

1512 
CHOICE_code_x
,

1513 #ifdef 
ASN_DISABLE_OER_SUPPORT


1517 
CHOICE_decode_r
,

1518 
CHOICE_code_r
,

1520 #ifde
ASN_DISABLE_PER_SUPPORT


1526 
CHOICE_decode_ur
,

1527 
CHOICE_code_ur
,

1528 
CHOICE_decode_
,

1529 
CHOICE_code_
,

1531 
CHOICE_ndom_fl
,

1532 
CHOICE_outmo_g


	@constr_SEQUENCE.c

6 
	~<a_.h
>

7 
	~<cڡr_SEQUENCE.h
>

8 
	~<OPEN_TYPE.h
>

9 
	~<r_ݒty.h
>

16 
	#LEFT
 ((
size
<(
size_t
)
x
->

)?size:(size_t)x->)

	)

29 
	#SIZE_VIOLATION
 (
x
->

 >0 && (
size_t
)x-> <
size
)

	)

35 #unde
ADVANCE


36 
	#ADVANCE
(
num_bys
) do { \

37 
size_t
 
num
 = 
num_bys
; \

38 
r
 = ((cڡ *+ 
num
; \

39 
size
 -
num
; \

40 if(
x
->

 >= 0) \

41 
x
->

 -
num
; \

42 
csumed_mylf
 +
num
; \

43 } 0)

	)

48 #unde
NEXT_PHASE


49 #unde
PHASE_OUT


50 
	#NEXT_PHASE
(
x
) do { \

51 
x
->
pha
++; \

52 
x
->

 = 0; \

53 } 0)

	)

54 
	#PHASE_OUT
(
x
d{ ctx->
pha
 = 10; } 0)

	)

59 #unde
RETURN


60 
	#RETURN
(
_code
) do { \

61 
rv
.
code
 = 
_code
; \

62 
rv
.
csumed
 = 
csumed_mylf
;\

63  
rv
; \

64 } 0)

	)

69 
	#IN_EXTENSION_GROUP
(
ecs
, 
memb_idx
) \

70 ((
ecs
)->
f_exnsi
 >= 0 \

71 && ()(
ecs
)->
f_exnsi
 <(
memb_idx
))

	)

77 
	$_t2e_cmp
(cڡ *

, cڡ *
bp
) {

78 cڡ 
a_TYPE_g2memb_t
 *
a
 = (cڡ_TYPE_g2memb_*)

;

79 cڡ 
a_TYPE_g2memb_t
 *
b
 = (cڡ_TYPE_g2memb_*)
bp
;

81 
a_ass
 = 
	`BER_TAG_CLASS
(
a
->
_g
);

82 
b_ass
 = 
	`BER_TAG_CLASS
(
b
->
_g
);

84 if(
a_ass
 =
b_ass
) {

85 
b_v_g_t
 
a_vue
 = 
	`BER_TAG_VALUE
(
a
->
_g
);

86 
b_v_g_t
 
b_vue
 = 
	`BER_TAG_VALUE
(
b
->
_g
);

88 if(
a_vue
 =
b_vue
) {

89 if(
a
->
_no
 > 
b
->el_no)

96 } if(
a_vue
 < 
b_vue
)

100 } if(
a_ass
 < 
b_ass
) {

105 
	}
}

111 
a_dec_rv_t


112 
	$SEQUENCE_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

113 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

114 cڡ *
r
, 
size_t
 
size
, 
g_mode
) {

118 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 = (cڡ_SEQUENCE_ecifics_*)
td
->
ecifics
;

119 cڡ 
a_TYPE_memb_t
 *
emts
 = 
td
->elements;

124 *

 = *
ru_r
;

125 
a_ru_x_t
 *
x
;

127 
b_v_g_t
 
v_g
;

128 
a_dec_rv_t
 
rv
;

130 
ssize_t
 
csumed_mylf
 = 0;

131 
size_t
 
edx
;

133 
	`ASN_DEBUG
("Decodg %aSEQUENCE", 
td
->
me
);

138 if(

 == 0) {

139 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

140 if(

 == 0) {

141 
	`RETURN
(
RC_FAIL
);

148 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

153 
x
->
pha
) {

161 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 
x
, 
r
, 
size
,

162 
g_mode
, 1, &
x
->

, 0);

163 if(
rv
.
code
 !
RC_OK
) {

164 
	`ASN_DEBUG
("%sagging check failed: %d",

165 
td
->
me
, 
rv
.
code
);

166  
rv
;

169 if(
x
->

 >= 0)

170 
x
->

 +
rv
.
csumed
;

171 
	`ADVANCE
(
rv
.
csumed
);

173 
	`NEXT_PHASE
(
x
);

175 
	`ASN_DEBUG
("Structure consumes %ld bytes, buffer %ld",

176 ()
x
->

, ()
size
);

190 
edx
 = ((
size_t
)
x
->

 >> 1);dx < 
td
->
emts_cou
;

191 
edx
++, 
x
->

 = (ctx->step & ~1) + 2) {

192 *
memb_r
;

193 **
memb_r2
;

194 
ssize_t
 
g_n
;

195 
size_t
 
t_edx_d
;

196 
size_t
 
n
;

197 
u_bch
;

199 if(
x
->

 & 1)

200 
miha2
;

205 
	`ASN_DEBUG
("I%SEQUENCEe %d,dx=%" 
ASN_PRI_SIZE
 " flags=%d"

207 
td
->
me
, ()
x
->

, 
edx
,

208 
emts
[
edx
].
ags
,mts[edx].
tiڮ
,

209 
td
->
emts_cou
);

211 if(
x
->

 == 0

214 (
edx
 + 
emts
[edx].
tiڮ
 =
td
->
emts_cou
) ||

216 
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
))) {

217 
	`ASN_DEBUG
("End oSEQUENCE %s", 
td
->
me
);

221 
	`PHASE_OUT
(
x
);

222 
	`RETURN
(
RC_OK
);

228 
g_n
 = 
	`b_tch_g
(
r
, 
LEFT
, &
v_g
);

229 
	`ASN_DEBUG
("Cug i%SEQUENCE f܃m%" 
ASN_PRI_SIZE
 " "

231 
td
->
me
, 
edx
, 
emts
[edx].name,

232 
	`b_v_g_rg
(
v_g
), ()
g_n
, ()
LEFT
);

233 
g_n
) {

234 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

236 -1: 
	`RETURN
(
RC_FAIL
);

239 if(
x
->

 < 0 && ((cڡ 
ut8_t
 *)
r
)[0] == 0) {

240 if(
LEFT
 < 2) {

241 if(
SIZE_VIOLATION
) {

242 
	`RETURN
(
RC_FAIL
);

244 
	`RETURN
(
RC_WMORE
);

246 } if(((cڡ 
ut8_t
 *)
r
)[1] == 0) {

247 
	`ASN_DEBUG
("edx = %" 
ASN_PRI_SIZE
 ", o = %d,c=%d", 
edx
,

248 
emts
[
edx
].
tiڮ
, 
td
->
emts_cou
);

249 if((
edx
 + 
emts
[edx].
tiڮ
 =
td
->
emts_cou
)

250 || 
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
)) {

260 
pha3
;

268 
u_bch
 = 0;

269 
t_edx_d
 = 
edx
 + 
emts
[edx].
tiڮ
 + 1;

270 if(
t_edx_d
 > 
td
->
emts_cou
)

271 
t_edx_d
 = 
td
->
emts_cou
;

272 if(
t_edx_d
 - 
edx
 > 8) {

274 
t_edx_d
 = 
edx
 + 8;

275 
u_bch
 = 1;

278 
n
 = 
edx
; < 
t_edx_d
;++) {

279 if(
	`BER_TAGS_EQUAL
(
v_g
, 
emts
[
n
].
g
)) {

285 
edx
 = 
n
;

286 
x
->

 = 1 + 2 * 
edx
;

287 
miha2
;

288 } if(
emts
[
n
].
ags
 & 
ATF_ANY_TYPE
) {

293 
edx
 = 
n
;

294 
x
->

 = 1 + 2 * 
edx
;

295 
miha2
;

296 } if(
emts
[
n
].
g
 =(
b_v_g_t
)-1) {

297 
u_bch
 = 1;

301 if(
u_bch
) {

306 cڡ 
a_TYPE_g2memb_t
 *
t2m
;

307 
a_TYPE_g2memb_t
 
key
 = {0, 0, 0, 0};

308 
key
.
_g
 = 
v_g
;

309 
key
.
_no
 = 
edx
;

310 
t2m
 = (cڡ 
a_TYPE_g2memb_t
 *)
	`bch
(&
key
,

311 
ecs
->
g2
, scs->
g2_cou
,

312 (
ecs
->
g2
[0]), 
_t2e_cmp
);

313 if(
t2m
) {

314 cڡ 
a_TYPE_g2memb_t
 *
be
 = 0;

315 cڡ 
a_TYPE_g2memb_t
 *
t2m_f
, *
t2m_l
;

316 
size_t
 
edx_max
 = 
edx
 + 
emts
[edx].
tiڮ
;

321 
t2m_f
 = 
t2m
 +2m->
toff_f
;

322 
t2m_l
 = 
t2m
 +2m->
toff_ϡ
;

323 
t2m
 = 
t2m_f
;2m <
t2m_l
;2m++) {

324 if(
t2m
->
_no
 > 
edx_max
) ;

325 if(
t2m
->
_no
 < 
edx
) ;

326 
be
 = 
t2m
;

328 if(
be
) {

329 
edx
 = 
be
->
_no
;

330 
x
->

 = 1 + 2 * 
edx
;

331 
miha2
;

334 
n
 = 
t_edx_d
;

336 if(
n
 =
t_edx_d
) {

343 if(!
	`IN_EXTENSION_GROUP
(
ecs
,

344 
edx
 + 
emts
[edx].
tiڮ
)) {

345 
	`ASN_DEBUG
("Uxedag %׈%" 
ASN_PRI_SIZE
 ")",

346 
	`b_v_g_rg
(
v_g
), 
edx
);

347 
	`ASN_DEBUG
("Expectedag %s (%s)%s",

348 
	`b_v_g_rg
(
emts
[
edx
].
g
),

349 
emts
[
edx
].
me
,

350 
emts
[
edx
].
tiڮ


352 
	`RETURN
(
RC_FAIL
);

355 
ssize_t
 
sk
;

356 
edx
 +
emts
[edx].
tiڮ
;

358 
	`ASN_DEBUG
("Skpg uxed %׈%" 
ASN_PRI_SIZE
 ")",

359 
	`b_v_g_rg
(
v_g
), 
edx
);

360 
sk
 = 
	`b_sk_ngth
(
t_codec_x
,

361 
	`BER_TLV_CONSTRUCTED
(
r
),

362 (cڡ *)
r
 + 
g_n
,

363 
LEFT
 - 
g_n
);

364 
	`ASN_DEBUG
("Skipength %d in %s",

365 ()
sk
, 
td
->
me
);

366 
sk
) {

367 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

369 -1: 
	`RETURN
(
RC_FAIL
);

372 
	`ADVANCE
(
sk
 + 
g_n
);

373 
x
->

 -= 2;

374 
edx
--;

382 
x
->

 |= 1;

383 
miha2
:

384 
	`ASN_DEBUG
("InsidSEQUENCE %MF2", 
td
->
me
);

391 if(
emts
[
edx
].
ags
 & 
ATF_POINTER
) {

393 
memb_r2
 = (**)((*)

 + 
emts
[
edx
].
memb_offt
);

399 
memb_r
 = (*)

 + 
emts
[
edx
].
memb_offt
;

400 
memb_r2
 = &
memb_r
;

405 if(
emts
[
edx
].
ags
 & 
ATF_OPEN_TYPE
) {

406 
rv
 = 
	`OPEN_TYPE_b_g
(
t_codec_x
, 
td
, 

, &
emts
[
edx
], 
r
, 
LEFT
);

408 
rv
 = 
emts
[
edx
].
ty
->

->
	`b_decod
(
t_codec_x
,

409 
emts
[
edx
].
ty
,

410 
memb_r2
, 
r
, 
LEFT
,

411 
emts
[
edx
].
g_mode
);

413 
	`ASN_DEBUG
("I%SEQUENCE decoded %" 
ASN_PRI_SIZE
 " %s of %d "

415 
td
->
me
, 
edx
, 
emts
[edx].
ty
->name,

416 ()
LEFT
, ()
rv
.
csumed
,v.
code
, ()
size
);

417 
rv
.
code
) {

418 
RC_OK
:

420 
RC_WMORE
:

421 if(!
SIZE_VIOLATION
) {

422 
	`ADVANCE
(
rv
.
csumed
);

423 
	`RETURN
(
RC_WMORE
);

425 
	`ASN_DEBUG
("Size violation (c->l=%ld <= s=%ld)",

426 ()
x
->

, ()
size
);

428 
RC_FAIL
:

429 
	`RETURN
(
RC_FAIL
);

432 
	`ADVANCE
(
rv
.
csumed
);

435 
pha3
:

436 
x
->
pha
 = 3;

441 
	`ASN_DEBUG
("SEQUENCE %s Leftover: %ld, size = %ld",

442 
td
->
me
, ()
x
->

, ()
size
);

447 
x
->

) {

448 
ssize_t
 

, 

;

450 

 = 
	`b_tch_g
(
r
, 
LEFT
, &
v_g
);

451 

) {

452 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

454 -1: 
	`RETURN
(
RC_FAIL
);

460 if(
x
->

 < 0

461 && ((cڡ 
ut8_t
 *)
r
)[0] == 0) {

462 if(
LEFT
 < 2) {

463 if(
SIZE_VIOLATION
)

464 
	`RETURN
(
RC_FAIL
);

466 
	`RETURN
(
RC_WMORE
);

467 } if(((cڡ 
ut8_t
 *)
r
)[1] == 0) {

471 
	`ADVANCE
(2);

472 
x
->

++;

473 
x
->
pha
 = 4;

478 if(!
	`IN_EXTENSION_GROUP
(
ecs
, 
td
->
emts_cou
)

479 || 
x
->
pha
 == 4) {

480 
	`ASN_DEBUG
("Unexpected continuation "

483 
td
->
me
,

484 
	`b_v_g_rg
(
v_g
));

485 
	`RETURN
(
RC_FAIL
);

488 

 = 
	`b_sk_ngth
(
t_codec_x
,

489 
	`BER_TLV_CONSTRUCTED
(
r
),

490 (cڡ *)
r
 + 

, 
LEFT
 -l);

491 

) {

492 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

494 -1: 
	`RETURN
(
RC_FAIL
);

497 
	`ADVANCE
(

 + 

);

500 
	`PHASE_OUT
(
x
);

503 
	`RETURN
(
RC_OK
);

504 
	}
}

510 
a_c_rv_t


511 
	$SEQUENCE_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

512 
g_mode
, 
b_v_g_t
 
g
,

513 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

514 
size_t
 
compud_size
 = 0;

515 
a_c_rv_t
 
v
 = {0,0,0};

516 
ssize_t
 
t
;

517 
size_t
 
edx
;

519 
	`ASN_DEBUG
("%s %ss SEQUENCE",

520 
cb
?"Encodg":"Eimg", 
td
->
me
);

525 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

526 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

528 cڡ *
memb_r
;

529 cڡ *cڡ *
memb_r2
;

531 if(
m
->
ags
 & 
ATF_POINTER
) {

532 
memb_r2
 =

533 (cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

534 if(!*
memb_r2
) {

535 
	`ASN_DEBUG
("Em%%" 
ASN_PRI_SIZE
 "otresent",

536 
m
->
me
, 
edx
);

537 if(
m
->
tiڮ
)

540 
ASN__ENCODE_FAILED
;

543 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

544 
memb_r2
 = &
memb_r
;

548 if(
m
->
deu_vue_cmp
 &&lm->
	`deu_vue_cmp
(*
memb_r2
) == 0)

551 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, *
memb_r2
,

552 
m
->
g_mode
,lm->
g
,

554 if(
v
.
coded
 == -1)

555  
v
;

556 
compud_size
 +
v
.
coded
;

557 
	`ASN_DEBUG
("Memb %" 
ASN_PRI_SIZE
 " %sstimated %ld bytes",

558 
edx
, 
m
->
me
, ()
v
.
coded
);

564 
t
 = 
	`d_wre_gs
(
td
, 
compud_size
, 
g_mode
, 1, 
g
, 
cb
, 
p_key
);

565 
	`ASN_DEBUG
("Wrِgs: %ld (+%ld)", ()
t
, ()
compud_size
);

566 if(
t
 == -1)

567 
ASN__ENCODE_FAILED
;

568 
v
.
coded
 = 
compud_size
 + 
t
;

570 if(!
cb

	`ASN__ENCODED_OK
(
v
);

575 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

576 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

577 
a_c_rv_t
 
tmrv
 = {0,0,0};

578 cڡ *
memb_r
;

579 cڡ *cڡ *
memb_r2
;

581 if(
m
->
ags
 & 
ATF_POINTER
) {

582 
memb_r2
 =

583 (cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

584 if(!*
memb_r2
) ;

586 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

587 
memb_r2
 = &
memb_r
;

591 if(
m
->
deu_vue_cmp
 &&lm->
	`deu_vue_cmp
(*
memb_r2
) == 0)

594 
tmrv
 = 
m
->
ty
->

->
	`d_cod
lm->ty, *
memb_r2
,

595 
m
->
g_mode
,lm->
g
, 
cb
, 
p_key
);

596 if(
tmrv
.
coded
 == -1)

597  
tmrv
;

598 
compud_size
 -
tmrv
.
coded
;

599 
	`ASN_DEBUG
("Memb %" 
ASN_PRI_SIZE
 " %s of SEQUENCE %sncoded in %ld bytes",

600 
edx
, 
m
->
me
, 
td
->me, ()
tmrv
.
coded
);

603 if(
compud_size
 != 0)

607 
ASN__ENCODE_FAILED
;

609 
	`ASN__ENCODED_OK
(
v
);

610 
	}
}

613 #unde
XER_ADVANCE


614 
	#XER_ADVANCE
(
num_bys
) \

616 
size_t
 
num
 = (
num_bys
); \

617 
r
 = ((cڡ *+ 
num
; \

618 
size
 -
num
; \

619 
csumed_mylf
 +
num
; \

620 } 0)

	)

625 
a_dec_rv_t


626 
	$SEQUENCE_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

627 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

628 cڡ *
t_mme
, cڡ *
r
, 
size_t
 
size
) {

632 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs


633 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

634 
a_TYPE_memb_t
 *
emts
 = 
td
->elements;

635 cڡ *
xml_g
 = 
t_mme
 ? o_mm: 
td
->xml_tag;

640 *

 = *
ru_r
;

641 
a_ru_x_t
 *
x
;

643 
a_dec_rv_t
 
rv
;

644 
ssize_t
 
csumed_mylf
 = 0;

645 
size_t
 
edx
;

650 if(

 == 0) {

651 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

652 if(

 =0
	`RETURN
(
RC_FAIL
);

658 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

669 
edx
 = 
x
->

; ctx->
pha
 <= 3;) {

670 
px_chunk_ty_e
 
ch_ty
;

671 
ssize_t
 
ch_size
;

672 
x_check_g_e
 
tcv
;

673 
a_TYPE_memb_t
 *
m
;

678 if(
x
->
pha
 == 2) {

679 
a_dec_rv_t
 
tmv
;

680 *
memb_r_dtu
;

681 **
memb_r2
;

683 
m
 = &
td
->
emts
[
edx
];

685 if(
m
->
ags
 & 
ATF_POINTER
) {

687 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

689 
memb_r_dtu
 = (*)

 + 
m
->
memb_offt
;

690 
memb_r2
 = &
memb_r_dtu
;

693 if(
m
->
ags
 & 
ATF_OPEN_TYPE
) {

694 
tmv
 = 
	`OPEN_TYPE_x_g
(
t_codec_x
, 
td
, 

, 
m
, 
r
, 
size
);

697 
tmv
 = 
m
->
ty
->

->
	`x_decod
(
t_codec_x
,

698 
m
->
ty
, 
memb_r2
,lm->
me
,

699 
r
, 
size
);

701 
	`XER_ADVANCE
(
tmv
.
csumed
);

702 if(
tmv
.
code
 !
RC_OK
)

703 
	`RETURN
(
tmv
.
code
);

704 
x
->
pha
 = 1;

705 
x
->

 = ++
edx
;

706 
	`ASN_DEBUG
("XER/SEQUENCEhase => %d, step => %d",

707 
x
->
pha
, ctx->

);

714 
ch_size
 = 
	`x_xt_tok
(&
x
->
cڋxt
, 
r
, 
size
,

715 &
ch_ty
);

716 if(
ch_size
 == -1) {

717 
	`RETURN
(
RC_FAIL
);

719 
ch_ty
) {

720 
PXER_WMORE
:

721 
	`RETURN
(
RC_WMORE
);

722 
PXER_COMMENT
:

723 
PXER_TEXT
:

724 
	`XER_ADVANCE
(
ch_size
);

726 
PXER_TAG
:

731 
tcv
 = 
	`x_check_g
(
r
, 
ch_size
, 
xml_g
);

732 
	`ASN_DEBUG
("XER/SEQUENCE:cv = %d,h=%d [%s]",

733 
tcv
, 
x
->
pha
, 
xml_g
);

736 if(
x
->
pha
 == 3) {

737 
	`x_sk_unknown
(
tcv
, &
x
->

)) {

739 
x
->
pha
 = 4;

740 
	`RETURN
(
RC_FAIL
);

742 
	`XER_ADVANCE
(
ch_size
);

745 
	`XER_ADVANCE
(
ch_size
);

746 
x
->
pha
 = 1;

749 
x
->
pha
 = 1;

754 
tcv
) {

755 
XCT_CLOSING
:

756 if(
x
->
pha
 == 0) ;

757 
x
->
pha
 = 0;

759 
XCT_BOTH
:

760 if(
x
->
pha
 == 0) {

761 if(
edx
 >
td
->
emts_cou
 ||

763 (
edx
 + 
emts
[edx].
tiڮ
 =
td
->
emts_cou
) ||

765 
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
)) {

766 
	`XER_ADVANCE
(
ch_size
);

767 
x
->
pha
 = 4;

768 
	`RETURN
(
RC_OK
);

770 
	`ASN_DEBUG
("Prematurend of XER SEQUENCE");

771 
	`RETURN
(
RC_FAIL
);

775 
XCT_OPENING
:

776 if(
x
->
pha
 == 0) {

777 
	`XER_ADVANCE
(
ch_size
);

778 
x
->
pha
 = 1;

782 
XCT_UNKNOWN_OP
:

783 
XCT_UNKNOWN_BO
:

785 
	`ASN_DEBUG
("XER/SEQUENCE:cv=%d,h=%d,dx=%" 
ASN_PRI_SIZE
 "",

786 
tcv
, 
x
->
pha
, 
edx
);

787 if(
x
->
pha
 != 1) {

791 if(
edx
 < 
td
->
emts_cou
) {

795 
size_t
 
n
;

796 
size_t
 
edx_d
 = 
edx
 + 
emts
[edx].
tiڮ
 + 1;

797 if(
edx_d
 > 
td
->
emts_cou
)

798 
edx_d
 = 
td
->
emts_cou
;

799 
n
 = 
edx
; < 
edx_d
;++) {

800 
m
 = &
td
->
emts
[
n
];

801 
tcv
 = 
	`x_check_g
(
r
, 
ch_size
, 
m
->
me
);

802 
tcv
) {

803 
XCT_BOTH
:

804 
XCT_OPENING
:

808 
x
->

 = 
edx
 = 
n
;

809 
x
->
pha
 = 2;

811 
XCT_UNKNOWN_OP
:

812 
XCT_UNKNOWN_BO
:

815 
n
 = 
edx_d
;

820 if(
n
 !
edx_d
)

823 
	`ASN_DEBUG
("Ouodefed membs: %" 
ASN_PRI_SIZE
 "/%u",

824 
edx
, 
td
->
emts_cou
);

828 if(
	`IN_EXTENSION_GROUP
(
ecs
,

829 
edx
 + (edx < 
td
->
emts_cou


830 ? 
emts
[
edx
].
tiڮ
 : 0))) {

831 
	`ASN_DEBUG
("Gهicedxnsiڇ%" 
ASN_PRI_SIZE
 "",

832 
edx
);

838 if(
tcv
 & 
XCT_CLOSING
) {

841 
x
->

 = 1;

842 
x
->
pha
 = 3;

844 
	`XER_ADVANCE
(
ch_size
);

853 
	`ASN_DEBUG
("Unexpected XMLag in SEQUENCE [%c%c%c%c%c%c]",

854 
size
>0?((cڡ *)
r
)[0]:'.',

855 
size
>1?((cڡ *)
r
)[1]:'.',

856 
size
>2?((cڡ *)
r
)[2]:'.',

857 
size
>3?((cڡ *)
r
)[3]:'.',

858 
size
>4?((cڡ *)
r
)[4]:'.',

859 
size
>5?((cڡ *)
r
)[5]:'.');

863 
x
->
pha
 = 4;

864 
	`RETURN
(
RC_FAIL
);

865 
	}
}

867 
a_c_rv_t


868 
	$SEQUENCE_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

869 
ev
, 
x_cod_ags_e
 
ags
,

870 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

871 
a_c_rv_t
 

 = {0,0,0};

872 
xn
 = (
ags
 & 
XER_F_CANONICAL
);

873 
a_TYPE_dest_t
 *
tmp_def_v_td
 = 0;

874 *
tmp_def_v
 = 0;

875 
size_t
 
edx
;

877 if(!


ASN__ENCODE_FAILED
;

879 

.
coded
 = 0;

881 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

882 
a_c_rv_t
 
tmr
 = {0,0,0};

883 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

884 cڡ *
memb_r
;

885 cڡ *
mme
 = 
m
->
me
;

886 
mn
 = 
	`
(
mme
);

888 if(
m
->
ags
 & 
ATF_POINTER
) {

889 
memb_r
 =

890 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

891 if(!
memb_r
) {

892 
	`as
(
tmp_def_v
 == 0);

893 if(
m
->
deu_vue_t
) {

894 if(
m
->
	`deu_vue_t
(&
tmp_def_v
)) {

895 
ASN__ENCODE_FAILED
;

897 
memb_r
 = 
tmp_def_v
;

898 
tmp_def_v_td
 = 
m
->
ty
;

900 } if(
m
->
tiڮ
) {

904 
ASN__ENCODE_FAILED
;

908 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

911 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
);

912 
	`ASN__CALLBACK3
("<", 1, 
mme
, 
mn
, ">", 1);

915 
tmr
 = 
m
->
ty
->

->
	`x_cod
lm->ty, 
memb_r
, 
ev
 + 1,

916 
ags
, 
cb
, 
p_key
);

917 if(
tmp_def_v
) {

918 
	`ASN_STRUCT_FREE
(*
tmp_def_v_td
, 
tmp_def_v
);

919 
tmp_def_v
 = 0;

921 if(
tmr
.
coded
 == -1) mper;

922 

.
coded
 +
tmr
.encoded;

924 
	`ASN__CALLBACK3
("</", 2, 
mme
, 
mn
, ">", 1);

927 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
 - 1);

929 
	`ASN__ENCODED_OK
(

);

930 
cb_ed
:

931 if(
tmp_def_v

	`ASN_STRUCT_FREE
(*
tmp_def_v_td
,mp_def_val);

932 
ASN__ENCODE_FAILED
;

933 
	}
}

936 
	$SEQUENCE_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

937 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

938 
size_t
 
edx
;

939 
t
;

941 if(!

 (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

944 if(
	`cb
(
td
->
me
, 
	`
d->me), 
p_key
) < 0

945 || 
	`cb
(" ::{", 6, 
p_key
) < 0)

948 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

949 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

950 cڡ *
memb_r
;

952 if(
m
->
ags
 & 
ATF_POINTER
) {

953 
memb_r
 = *(cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

954 if(!
memb_r
) {

955 if(
m
->
tiڮ
) ;

960 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

964 
	`_i_INDENT
(1);

967 if(
	`cb
(
m
->
me
, 
	`
lm->me), 
p_key
) < 0

968 || 
	`cb
(": ", 2, 
p_key
) < 0)

972 
t
 = 
m
->
ty
->

->
	`t_ru
lm->ty, 
memb_r
, 
ev
 + 1,

973 
cb
, 
p_key
);

974 if(
t
) et;

977 
ev
--;

978 
	`_i_INDENT
(1);

980  (
	`cb
("}", 1, 
p_key
) < 0) ? -1 : 0;

981 
	}
}

984 
	$SEQUENCE_
(cڡ 
a_TYPE_dest_t
 *
td
, *

,

985 
a_ru__mhod
 
mhod
) {

986 
size_t
 
edx
;

987 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 =

988 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

989 
a_ru_x_t
 *
x
;

991 if(!
td
 || !

)

994 
	`ASN_DEBUG
("Feg %aSEQUENCE", 
td
->
me
);

996 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

997 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

998 *
memb_r
;

999 if(
m
->
ags
 & 
ATF_POINTER
) {

1000 
memb_r
 = *(**)((*)

 + 
m
->
memb_offt
);

1001 if(
memb_r
)

1002 
	`ASN_STRUCT_FREE
(*
m
->
ty
, 
memb_r
);

1004 
memb_r
 = (*)((*)

 + 
m
->
memb_offt
);

1005 
	`ASN_STRUCT_FREE_CONTENTS_ONLY
(*
m
->
ty
, 
memb_r
);

1010 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

1011 
	`FREEMEM
(
x
->
r
);

1013 
mhod
) {

1014 
ASFM_FREE_EVERYTHING
:

1015 
	`FREEMEM
(

);

1017 
ASFM_FREE_UNDERLYING
:

1019 
ASFM_FREE_UNDERLYING_AND_RESET
:

1020 
	`memt
(

1021 

, 0,

1022 ((cڡ 
a_SEQUENCE_ecifics_t
 *)(
td
->
ecifics
))->
ru_size
);

1025 
	}
}

1028 
	$SEQUENCE_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1029 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

1030 
size_t
 
edx
;

1032 if(!

) {

1033 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

1035 
td
->
me
, 
__FILE__
, 
__LINE__
);

1042 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

1043 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1044 cڡ *
memb_r
;

1046 if(
m
->
ags
 & 
ATF_POINTER
) {

1047 
memb_r
 = *(cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1048 if(!
memb_r
) {

1049 if(
m
->
tiڮ
)

1051 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

1053 
td
->
me
, 
m
->me, 
__FILE__
, 
__LINE__
);

1057 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1060 if(
m
->
codg_cڡts
.
g_cڡts
) {

1061 
t
 = 
m
->
codg_cڡts
.
	`g_cڡts
lm->
ty
, 
memb_r
,

1062 
cb
, 
p_key
);

1063 if(
t
) et;

1065  
m
->
ty
->
codg_cڡts
.
	`g_cڡts
(elm->type,

1066 
memb_r
, 
cb
, 
p_key
);

1071 
	}
}

1073 #ide
ASN_DISABLE_PER_SUPPORT


1075 
a_dec_rv_t


1076 
	$SEQUENCE_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1077 cڡ 
a_TYPE_dest_t
 *
td
,

1078 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

1079 
a_r_da_t
 *
pd
) {

1080 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 = (cڡ_SEQUENCE_ecifics_*)
td
->
ecifics
;

1081 *

 = *

;

1082 
ex
;

1083 
ut8_t
 *
ݻs
;

1084 
a_r_da_t
 
md
;

1085 
a_dec_rv_t
 
rv
;

1086 
size_t
 
edx
;

1088 ()
cڡts
;

1090 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

1091 
ASN__DECODE_FAILED
;

1093 if(!

) {

1094 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

1095 if(!


ASN__DECODE_FAILED
;

1098 
	`ASN_DEBUG
("Decodg %aSEQUENCE (UPER)", 
td
->
me
);

1101 if(
ecs
->
f_exnsi
 < 0) {

1102 
ex
 = 0;

1104 
ex
 = 
	`r_g_w_bs
(
pd
, 1);

1105 if(
ex
 < 0
ASN__DECODE_STARVED
;

1109 
	`memt
(&
md
, 0, (opmd));

1110 if(
ecs
->
roms_cou
) {

1111 
ݻs
 = (
ut8_t
 *)
	`MALLOC
(((
ecs
->
roms_cou
 + 7) >> 3) + 1);

1112 if(!
ݻs

ASN__DECODE_FAILED
;

1114 if(
	`r_g_my_bs
(
pd
, 
ݻs
, 0, 
ecs
->
roms_cou
)) {

1115 
	`FREEMEM
(
ݻs
);

1116 
ASN__DECODE_STARVED
;

1118 
md
.
bufr
 = 
ݻs
;

1119 
md
.
nbs
 = 
ecs
->
roms_cou
;

1120 
	`ASN_DEBUG
("Read inresence bitmap for %s of %d bits (%x..)",

1121 
td
->
me
, 
ecs
->
roms_cou
, *
ݻs
);

1123 
ݻs
 = 0;

1129 
edx
 = 0;

1130 
edx
 < (
ecs
->
f_exnsi
 < 0 ? 
td
->
emts_cou


1131 : (
size_t
)
ecs
->
f_exnsi
);

1132 
edx
++) {

1133 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1134 *
memb_r
;

1135 **
memb_r2
;

1137 
	`as
(!
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
));

1140 if(
m
->
ags
 & 
ATF_POINTER
) {

1141 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1143 
memb_r
 = (*)

 + 
m
->
memb_offt
;

1144 
memb_r2
 = &
memb_r
;

1148 if(
m
->
tiڮ
) {

1149 
e
 = 
	`r_g_w_bs
(&
md
, 1);

1150 
	`ASN_DEBUG
("Member %s->%s is optional,=%d (%d->%d)",

1151 
td
->
me
, 
m
->me, 
e
,

1152 ()
md
.
nboff
, ()md.
nbs
);

1153 if(
e
 == 0) {

1155 if(
m
->
deu_vue_t
) {

1157 if(
m
->
	`deu_vue_t
(
memb_r2
)) {

1158 
	`FREEMEM
(
ݻs
);

1159 
ASN__DECODE_FAILED
;

1161 
	`ASN_DEBUG
("Filled-in default");

1170 
	`ASN_DEBUG
("Decodg memb \"%s\" i%s", 
m
->
me
, 
td
->name);

1172 if(
m
->
ags
 & 
ATF_OPEN_TYPE
) {

1173 
rv
 = 
	`OPEN_TYPE_ur_g
(
t_codec_x
, 
td
, 

, 
m
, 
pd
);

1175 
rv
 = 
m
->
ty
->

->
	`ur_decod
(
t_codec_x
,lm->type,

1176 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

1178 if(
rv
.
code
 !
RC_OK
) {

1179 
	`ASN_DEBUG
("Failed decode %s in %s",

1180 
m
->
me
, 
td
->name);

1181 
	`FREEMEM
(
ݻs
);

1182  
rv
;

1187 
	`FREEMEM
(
ݻs
);

1192 if(
ex
) {

1193 
ssize_t
 
bmngth
;

1194 
ut8_t
 *
s
;

1195 
a_r_da_t
 
md
;

1197 
bmngth
 = 
	`ur_g_ngth
(
pd
);

1198 if(
bmngth
 < 0
ASN__DECODE_STARVED
;

1200 
	`ASN_DEBUG
("Exnsiڠ%" 
ASN_PRI_SSIZE
 " i%s", 
bmngth
, 
td
->
me
);

1202 
s
 = (
ut8_t
 *)
	`MALLOC
((
bmngth
 + 15) >> 3);

1203 if(!
s

ASN__DECODE_STARVED
;

1206 if(
	`r_g_my_bs
(
pd
, 
s
, 0, 
bmngth
)) {

1207 
	`FREEMEM
(
s
);

1208 
ASN__DECODE_STARVED
;

1211 
	`memt
(&
md
, 0, (epmd));

1212 
md
.
bufr
 = 
s
;

1213 
md
.
nbs
 = 
bmngth
;

1214 
	`ASN_DEBUG
("Read inxtensions bitmap for %s of %ld bits (%x..)",

1215 
td
->
me
, ()
bmngth
, *
s
);

1218 
edx
 = 
ecs
->
f_exnsi
;dx < 
td
->
emts_cou
;dx++) {

1219 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1220 *
memb_r
;

1221 **
memb_r2
;

1222 
e
;

1225 if(
m
->
ags
 & 
ATF_POINTER
) {

1226 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1228 
memb_r
 = (*)((*)

 + 
m
->
memb_offt
);

1229 
memb_r2
 = &
memb_r
;

1232 
e
 = 
	`r_g_w_bs
(&
md
, 1);

1233 if(
e
 <= 0) {

1234 if(
e
 < 0) ;

1238 
	`ASN_DEBUG
("Decodg memb % %%p", 
m
->
me
, 
td
->name,

1239 *
memb_r2
);

1240 
rv
 = 
	`ur_ݒ_ty_g
(
t_codec_x
, 
m
->
ty
,

1241 
m
->
codg_cڡts
.
r_cڡts
,

1242 
memb_r2
, 
pd
);

1243 if(
rv
.
code
 !
RC_OK
) {

1244 
	`FREEMEM
(
s
);

1245  
rv
;

1252 
	`ASN_DEBUG
("Getting overflowxtensions");

1253 
	`r_g_w_bs
(&
md
, 1)) {

1257 if(
	`ur_ݒ_ty_sk
(
t_codec_x
, 
pd
)) {

1258 
	`FREEMEM
(
s
);

1259 
ASN__DECODE_STARVED
;

1261 
	`ASN_DEBUG
("Skipped overflowxtension");

1267 
	`FREEMEM
(
s
);

1270 if(
ecs
->
f_exnsi
 >= 0) {

1271 
i
;

1273 
i
 = 
ecs
->
roms_cou
; i < scs->roms_cou + scs->
aoms_cou
;

1274 
i
++) {

1275 
a_TYPE_memb_t
 *
m
;

1276 **
memb_r2
;

1278 
edx
 = 
ecs
->
oms
[
i
];

1279 
m
 = &
td
->
emts
[
edx
];

1281 if(!
m
->
deu_vue_t
) ;

1284 if(
m
->
ags
 & 
ATF_POINTER
) {

1285 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1286 if(*
memb_r2
) ;

1292 if(
m
->
	`deu_vue_t
(
memb_r2
)) {

1293 
ASN__DECODE_FAILED
;

1298 
rv
.
csumed
 = 0;

1299 
rv
.
code
 = 
RC_OK
;

1300  
rv
;

1301 
	}
}

1304 
	$SEQUENCE__hd_exnsis
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1305 
a_r_ou_t
 *
po1
,_r_ou_*
po2
) {

1306 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 =

1307 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

1308 
exts_e
 = 0;

1309 
exts_cou
 = 0;

1310 
size_t
 
edx
;

1312 if(
ecs
->
f_exnsi
 < 0) {

1317 
edx
 = 
ecs
->
f_exnsi
;dx < 
td
->
emts_cou
;dx++) {

1318 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1319 cڡ *
memb_r
;

1320 cڡ *cڡ *
memb_r2
;

1321 
e
;

1324 if(
m
->
ags
 & 
ATF_POINTER
) {

1325 
memb_r2
 =

1326 (cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1327 
e
 = (*
memb_r2
 != 0);

1329 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1330 
memb_r2
 = &
memb_r
;

1331 
e
 = 1;

1334 
	`ASN_DEBUG
("checkg %s:%(@%" 
ASN_PRI_SIZE
 "e => %d", 
m
->
me
,

1335 
m
->
ty
->
me
, 
edx
, 
e
);

1336 
exts_cou
++;

1337 
exts_e
 +
e
;

1340 if(
po1
 && 
	`r_put_w_bs
o1, 
e
, 1)) {

1344 if(
po2
 && 
e


1345 && 
	`ur_ݒ_ty_put
(
m
->
ty
,

1346 
m
->
codg_cڡts
.
r_cڡts
,

1347 *
memb_r2
, 
po2
))

1351  
exts_e
 ? 
exts_cou
 : 0;

1352 
	}
}

1354 
a_c_rv_t


1355 
	$SEQUENCE_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

1356 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

1357 
a_r_ou_t
 *
po
) {

1358 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs


1359 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

1360 
a_c_rv_t
 

 = {0,0,0};

1361 
n_exnsis
;

1362 
size_t
 
edx
;

1363 
size_t
 
i
;

1365 ()
cڡts
;

1367 if(!

)

1368 
ASN__ENCODE_FAILED
;

1370 

.
coded
 = 0;

1372 
	`ASN_DEBUG
("Encodg %aSEQUENCE (UPER)", 
td
->
me
);

1378 if(
ecs
->
f_exnsi
 < 0) {

1379 
n_exnsis
 = 0;

1381 
n_exnsis
 = 
	`SEQUENCE__hd_exnsis
(
td
, 

, 0, 0);

1382 if(
n_exnsis
 < 0
ASN__ENCODE_FAILED
;

1383 if(
	`r_put_w_bs
(
po
, 
n_exnsis
 ? 1 : 0, 1)) {

1384 
ASN__ENCODE_FAILED
;

1389 
i
 = 0; i < 
ecs
->
roms_cou
; i++) {

1390 
a_TYPE_memb_t
 *
m
;

1391 cڡ *
memb_r
;

1392 cڡ *cڡ *
memb_r2
;

1393 
e
;

1395 
edx
 = 
ecs
->
oms
[
i
];

1396 
m
 = &
td
->
emts
[
edx
];

1399 if(
m
->
ags
 & 
ATF_POINTER
) {

1400 
memb_r2
 =

1401 (cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1402 
e
 = (*
memb_r2
 != 0);

1404 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1405 
memb_r2
 = &
memb_r
;

1406 
e
 = 1;

1410 if(
e
 && 
m
->
deu_vue_cmp


1411 && 
m
->
	`deu_vue_cmp
(*
memb_r2
) == 0)

1412 
e
 = 0;

1414 
	`ASN_DEBUG
("Element %s %s %s->%s is %s",

1415 
m
->
ags
 & 
ATF_POINTER
 ? "ptr" : "inline",

1416 
m
->
deu_vue_cmp
 ? "def" : "wtv",

1417 
td
->
me
, 
m
->me, 
e
 ? "present" : "absent");

1418 if(
	`r_put_w_bs
(
po
, 
e
, 1))

1419 
ASN__ENCODE_FAILED
;

1425 
	`ASN_DEBUG
("f_exnsi = %d,mt%d", 
ecs
->
f_exnsi
,

1426 
td
->
emts_cou
);

1427 
edx
 = 0;

1428 
edx
 < ((
ecs
->
f_exnsi
 < 0? 
td
->
emts_cou


1429 : (
size_t
)
ecs
->
f_exnsi
);

1430 
edx
++) {

1431 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1432 cڡ *
memb_r
;

1433 cڡ *cڡ *
memb_r2
;

1435 
	`ASN_DEBUG
("Aboutؒcod%s", 
m
->
ty
->
me
);

1438 if(
m
->
ags
 & 
ATF_POINTER
) {

1439 
memb_r2
 =

1440 (cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1441 if(!*
memb_r2
) {

1442 
	`ASN_DEBUG
("Em%%" 
ASN_PRI_SIZE
 "otresent",

1443 
m
->
me
, 
edx
);

1444 if(
m
->
tiڮ
)

1447 
ASN__ENCODE_FAILED
;

1450 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1451 
memb_r2
 = &
memb_r
;

1455 if(
m
->
deu_vue_cmp
 &&lm->
	`deu_vue_cmp
(*
memb_r2
) == 0)

1458 
	`ASN_DEBUG
("Encodg %s->%s:%s", 
td
->
me
, 
m
->me,lm->
ty
->name);

1459 

 = 
m
->
ty
->

->
	`ur_cod
(

1460 
m
->
ty
,lm->
codg_cڡts
.
r_cڡts
, *
memb_r2
,

1461 
po
);

1462 if(

.
coded
 == -1) r;

1466 if(!
n_exnsis

	`ASN__ENCODED_OK
(

);

1468 
	`ASN_DEBUG
("Lgth oexnsiڠ%d b-m", 
n_exnsis
);

1470 if(
	`ur_put_ngth
(
po
, 
n_exnsis
))

1471 
ASN__ENCODE_FAILED
;

1473 
	`ASN_DEBUG
("B-m o%dmts", 
n_exnsis
);

1476 if(
	`SEQUENCE__hd_exnsis
(
td
, 

, 
po
, 0!
n_exnsis
)

1477 
ASN__ENCODE_FAILED
;

1479 
	`ASN_DEBUG
("Wrg %dxnsis", 
n_exnsis
);

1481 if(
	`SEQUENCE__hd_exnsis
(
td
, 

, 0, 
po
!
n_exnsis
)

1482 
ASN__ENCODE_FAILED
;

1484 
	`ASN__ENCODED_OK
(

);

1485 
	}
}

1487 
a_dec_rv_t


1488 
	$SEQUENCE_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1489 cڡ 
a_TYPE_dest_t
 *
td
,

1490 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

1491 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 = (cڡ_SEQUENCE_ecifics_*)
td
->
ecifics
;

1492 *

 = *

;

1493 
ex
;

1494 
ut8_t
 *
ݻs
;

1495 
a_r_da_t
 
md
;

1496 
a_dec_rv_t
 
rv
;

1497 
size_t
 
edx
;

1499 ()
cڡts
;

1501 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

1502 
ASN__DECODE_FAILED
;

1504 if(!

) {

1505 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

1506 if(!


ASN__DECODE_FAILED
;

1509 
	`ASN_DEBUG
("Decodg %aSEQUENCE (APER)", 
td
->
me
);

1512 if(
ecs
->
f_exnsi
 < 0) {

1513 
ex
 = 0;

1515 
ex
 = 
	`r_g_w_bs
(
pd
, 1);

1516 if(
ex
 < 0
ASN__DECODE_STARVED
;

1520 
	`memt
(&
md
, 0, (opmd));

1521 if(
ecs
->
roms_cou
) {

1522 
ݻs
 = (
ut8_t
 *)
	`MALLOC
(((
ecs
->
roms_cou
 + 7) >> 3) + 1);

1523 if(!
ݻs

ASN__DECODE_FAILED
;

1525 if(
	`r_g_my_bs
(
pd
, 
ݻs
, 0, 
ecs
->
roms_cou
)) {

1526 
	`FREEMEM
(
ݻs
);

1527 
ASN__DECODE_STARVED
;

1529 
md
.
bufr
 = 
ݻs
;

1530 
md
.
nbs
 = 
ecs
->
roms_cou
;

1531 
	`ASN_DEBUG
("Read inresence bitmap for %s of %d bits (%x..)",

1532 
td
->
me
, 
ecs
->
roms_cou
, *
ݻs
);

1534 
ݻs
 = 0;

1540 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

1541 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1542 *
memb_r
;

1543 **
memb_r2
;

1545 
ddg
;

1548 if(
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
))

1552 if(
m
->
ags
 & 
ATF_POINTER
) {

1553 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1555 
memb_r
 = (*)

 + 
m
->
memb_offt
;

1556 
memb_r2
 = &
memb_r
;

1560 
ddg
 = (8 - (
pd
->
moved
 % 8)) % 8;

1561 if(
ddg
 > 0)

1562 
	`ASN_DEBUG
("F܃m%s,offt%ld Paddg b%d", 
td
->
me
, 
pd
->
moved
, 
ddg
);

1564 
	`r_g_w_bs
(
pd
, 
ddg
);

1566 if(
edx
 !(
td
->
emts_cou
-1))

1567 
	`r_g_w_bs
(
pd
, 
ddg
);

1569 if(
ecs
->
roms_cou
 && (
ddg
 > 0))

1570 
	`ASN_DEBUG
(">>>>> skpgaddg o%d bf܃mt:%ld ouo%d", 
ddg
, 
edx
, 
td
->
emts_cou
);

1572 
	`r_g_w_bs
(
pd
, 
ddg
);

1577 if(
m
->
tiڮ
) {

1578 
e
 = 
	`r_g_w_bs
(&
md
, 1);

1579 
	`ASN_DEBUG
("Member %s->%s is optional,=%d (%d->%d)",

1580 
td
->
me
, 
m
->me, 
e
,

1581 ()
md
.
nboff
, ()md.
nbs
);

1582 if(
e
 == 0) {

1584 if(
m
->
deu_vue_t
) {

1586 if(
m
->
	`deu_vue_t
(
memb_r2
)) {

1587 
	`FREEMEM
(
ݻs
);

1588 
ASN__DECODE_FAILED
;

1590 
	`ASN_DEBUG
("Filled-in default");

1599 
	`ASN_DEBUG
("Decodg memb \"%s\" i%s", 
m
->
me
, 
td
->name);

1601 if(
m
->
ags
 & 
ATF_OPEN_TYPE
) {

1602 
rv
 = 
	`OPEN_TYPE__g
(
t_codec_x
, 
td
, 

, 
m
, 
pd
);

1604 
rv
 = 
m
->
ty
->

->
	`_decod
(
t_codec_x
,lm->type,

1605 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

1607 if(
rv
.
code
 !
RC_OK
) {

1608 
	`ASN_DEBUG
("Failed decode %s in %s",

1609 
m
->
me
, 
td
->name);

1610 
	`FREEMEM
(
ݻs
);

1611  
rv
;

1616 
	`FREEMEM
(
ݻs
);

1621 if(
ex
) {

1622 
ssize_t
 
bmngth
;

1623 
ut8_t
 *
s
;

1624 
a_r_da_t
 
md
;

1626 
bmngth
 = 
	`_g_ngth
(
pd
);

1627 if(
bmngth
 < 0
ASN__DECODE_STARVED
;

1629 
	`ASN_DEBUG
("Exnsiڠ%" 
ASN_PRI_SSIZE
 " i%s", 
bmngth
, 
td
->
me
);

1631 
s
 = (
ut8_t
 *)
	`MALLOC
((
bmngth
 + 15) >> 3);

1632 if(!
s

ASN__DECODE_STARVED
;

1635 if(
	`r_g_my_bs
(
pd
, 
s
, 0, 
bmngth
))

1636 
ASN__DECODE_STARVED
;

1638 
	`memt
(&
md
, 0, (epmd));

1639 
md
.
bufr
 = 
s
;

1640 
md
.
nbs
 = 
bmngth
;

1641 
	`ASN_DEBUG
("Read inxtensions bitmap for %s of %ld bits (%x..)",

1642 
td
->
me
, 
bmngth
, *
s
);

1645 
edx
 = 
ecs
->
f_exnsi
;dx < 
td
->
emts_cou
;dx++) {

1646 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1647 *
memb_r
;

1648 **
memb_r2
;

1649 
e
;

1651 if(!
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
)) {

1652 
	`ASN_DEBUG
("%ld inكxnsi", 
edx
);

1657 if(
m
->
ags
 & 
ATF_POINTER
) {

1658 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

1660 
memb_r
 = (*)((*)

 + 
m
->
memb_offt
);

1661 
memb_r2
 = &
memb_r
;

1664 
e
 = 
	`r_g_w_bs
(&
md
, 1);

1665 if(
e
 <= 0) {

1666 if(
e
 < 0) ;

1670 
	`ASN_DEBUG
("Decodg memb % %%p", 
m
->
me
, 
td
->me, *
memb_r2
);

1671 
rv
 = 
	`_ݒ_ty_g
(
t_codec_x
, 
m
->
ty
,

1672 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r2
, 
pd
);

1673 if(
rv
.
code
 !
RC_OK
) {

1674 
	`FREEMEM
(
s
);

1675  
rv
;

1682 
	`ASN_DEBUG
("Getting overflowxtensions");

1683 
	`r_g_w_bs
(&
md
, 1)) {

1689 if(
	`_ݒ_ty_sk
(
t_codec_x
, 
pd
)) {

1690 
	`FREEMEM
(
s
);

1691 
ASN__DECODE_STARVED
;

1697 
	`FREEMEM
(
s
);

1701 
edx
 = 
ecs
->
roms_cou
;dx < specs->roms_count

1702 + 
ecs
->
aoms_cou
; 
edx
++) {

1703 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1704 **
memb_r2
;

1706 if(!
m
->
deu_vue_t
) ;

1709 if(
m
->
ags
 & 
ATF_POINTER
) {

1710 
memb_r2
 = (**)((*)



1711 + 
m
->
memb_offt
);

1712 if(*
memb_r2
) ;

1718 if(
m
->
	`deu_vue_t
(
memb_r2
)) {

1719 
ASN__DECODE_FAILED
;

1723 
rv
.
csumed
 = 0;

1724 
rv
.
code
 = 
RC_OK
;

1725  
rv
;

1726 
	}
}

1729 
	$SEQUENCE_hd_exnsis_
(cڡ 
a_TYPE_dest_t
 *
td
,

1730 cڡ *

,

1731 
a_r_ou_t
 *
po1
,_r_ou_*
po2
) {

1732 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs


1733 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

1734 
exts_e
 = 0;

1735 
exts_cou
 = 0;

1736 
size_t
 
edx
;

1738 if(
ecs
->
f_exnsi
 < 0) {

1743 
edx
 = 
ecs
->
f_exnsi
;dx < 
td
->
emts_cou
;dx++) {

1744 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1745 cڡ *
memb_r
;

1746 cڡ * cڡ *
memb_r2
;

1747 
e
;

1749 if(!
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
)) {

1750 
	`ASN_DEBUG
("%(@%ldinكxnsi", 
m
->
ty
->
me
, 
edx
);

1755 if(
m
->
ags
 & 
ATF_POINTER
) {

1756 
memb_r2
 = (cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1757 
e
 = (*
memb_r2
 != 0);

1759 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1760 
memb_r2
 = &
memb_r
;

1761 
e
 = 1;

1764 
	`ASN_DEBUG
("checking %s (@%ld)resent => %d",

1765 
m
->
ty
->
me
, 
edx
, 
e
);

1766 
exts_cou
++;

1767 
exts_e
 +
e
;

1770 if(
po1
 && 
	`r_put_w_bs
o1, 
e
, 1))

1773 if(
po2
 && 
e
 && 
	`_ݒ_ty_put
(
m
->
ty
,

1774 
m
->
codg_cڡts
.
r_cڡts
, *
memb_r2
, 
po2
))

1779  
exts_e
 ? 
exts_cou
 : 0;

1780 
	}
}

1782 
a_c_rv_t


1783 
	$SEQUENCE_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

1784 cڡ 
a_r_cڡts_t
 *
cڡts
,

1785 cڡ *

, 
a_r_ou_t
 *
po
) {

1786 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs


1787 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

1788 
a_c_rv_t
 

 = {0,0,0};

1789 
n_exnsis
;

1790 
size_t
 
edx
;

1791 
size_t
 
i
;

1793 ()
cڡts
;

1795 if(!

)

1796 
ASN__ENCODE_FAILED
;

1798 

.
coded
 = 0;

1800 
	`ASN_DEBUG
("Encodg %aSEQUENCE (APER)", 
td
->
me
);

1806 if(
ecs
->
f_exnsi
 < 0) {

1807 
n_exnsis
 = 0;

1809 
n_exnsis
 = 
	`SEQUENCE_hd_exnsis_
(
td
, 

, 0, 0);

1810 if(
n_exnsis
 < 0
ASN__ENCODE_FAILED
;

1811 if(
	`r_put_w_bs
(
po
, 
n_exnsis
 ? 1 : 0, 1)) {

1812 
ASN__ENCODE_FAILED
;

1817 
i
 = 0; i < 
ecs
->
roms_cou
; i++) {

1818 
a_TYPE_memb_t
 *
m
;

1819 cڡ *
memb_r
;

1820 cڡ * cڡ *
memb_r2
;

1821 
e
;

1823 
edx
 = 
ecs
->
oms
[
i
];

1824 
m
 = &
td
->
emts
[
edx
];

1827 if(
m
->
ags
 & 
ATF_POINTER
) {

1828 
memb_r2
 = (cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1829 
e
 = (*
memb_r2
 != 0);

1831 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1832 
memb_r2
 = &
memb_r
;

1833 
e
 = 1;

1837 if(
e
 && 
m
->
deu_vue_cmp


1838 && 
m
->
	`deu_vue_cmp
(
memb_r2
) == 1)

1839 
e
 = 0;

1841 
	`ASN_DEBUG
("Element %s %s %s->%s is %s",

1842 
m
->
ags
 & 
ATF_POINTER
 ? "ptr" : "inline",

1843 
m
->
deu_vue_cmp
 ? "def" : "wtv",

1844 
td
->
me
, 
m
->me, 
e
 ? "present" : "absent");

1845 if(
	`r_put_w_bs
(
po
, 
e
, 1))

1846 
ASN__ENCODE_FAILED
;

1852 
	`ASN_DEBUG
("f_exnsi = %d,mt%d", 
ecs
->
f_exnsi
,

1853 
td
->
emts_cou
);

1854 
edx
 = 0;

1855 
edx
 < ((
ecs
->
f_exnsi
 < 0? 
td
->
emts_cou


1856 : (
size_t
)
ecs
->
f_exnsi
);

1857 
edx
++) {

1858 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1859 cڡ *
memb_r
;

1860 cڡ * cڡ *
memb_r2
;

1862 if(
	`IN_EXTENSION_GROUP
(
ecs
, 
edx
))

1865 
	`ASN_DEBUG
("Aboutؒcod%s", 
m
->
ty
->
me
);

1868 if(
m
->
ags
 & 
ATF_POINTER
) {

1869 
memb_r2
 = (cڡ * cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1870 if(!*
memb_r2
) {

1871 
	`ASN_DEBUG
("Element %s %ldotresent",

1872 
m
->
me
, 
edx
);

1873 if(
m
->
tiڮ
)

1876 
ASN__ENCODE_FAILED
;

1879 
memb_r
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1880 
memb_r2
 = &
memb_r
;

1884 if(
m
->
deu_vue_cmp
 &&lm->
	`deu_vue_cmp
(
memb_r2
) == 1)

1887 
	`ASN_DEBUG
("Encodg %s->%s", 
td
->
me
, 
m
->name);

1888 

 = 
m
->
ty
->

->
	`_cod
lm->ty,lm->
codg_cڡts
.
r_cڡts
,

1889 *
memb_r2
, 
po
);

1890 if(

.
coded
 == -1)

1891  

;

1895 if(!
n_exnsis

	`ASN__ENCODED_OK
(

);

1897 
	`ASN_DEBUG
("Lgth o%d b-m", 
n_exnsis
);

1899 if(
	`_put_ngth
(
po
, 
n_exnsis
))

1900 
ASN__ENCODE_FAILED
;

1902 
	`ASN_DEBUG
("B-m o%dmts", 
n_exnsis
);

1905 if(
	`SEQUENCE_hd_exnsis_
(
td
, 

, 
po
, 0!
n_exnsis
)

1906 
ASN__ENCODE_FAILED
;

1908 
	`ASN_DEBUG
("Wrg %dxnsis", 
n_exnsis
);

1910 if(
	`SEQUENCE_hd_exnsis_
(
td
, 

, 0, 
po
!
n_exnsis
)

1911 
ASN__ENCODE_FAILED
;

1913 
	`ASN__ENCODED_OK
(

);

1914 
	}
}

1919 
	$SEQUENCE_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1920 cڡ *
br
) {

1921 
size_t
 
edx
;

1923 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

1924 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

1925 cڡ *
amemb
;

1926 cڡ *
bmemb
;

1927 
t
;

1929 if(
m
->
ags
 & 
ATF_POINTER
) {

1930 
amemb
 =

1931 *(cڡ *cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1932 
bmemb
 =

1933 *(cڡ *cڡ *)((cڡ *)
br
 + 
m
->
memb_offt
);

1934 if(!
amemb
) {

1935 if(!
bmemb
) ;

1936 if(
m
->
deu_vue_cmp


1937 && 
m
->
	`deu_vue_cmp
(
bmemb
) == 0) {

1942 } if(!
bmemb
) {

1943 if(
m
->
deu_vue_cmp


1944 && 
m
->
	`deu_vue_cmp
(
amemb
) == 0) {

1951 
amemb
 = (cڡ *)((cڡ *)

 + 
m
->
memb_offt
);

1952 
bmemb
 = (cڡ *)((cڡ *)
br
 + 
m
->
memb_offt
);

1955 
t
 = 
m
->
ty
->

->
	`com_ru
lm->ty, 
amemb
, 
bmemb
);

1956 if(
t
 != 0) et;

1960 
	}
}

1962 
a_TYPE_ݔi_t
 
	ga_OP_SEQUENCE
 = {

1963 
SEQUENCE_
,

1964 
SEQUENCE_t
,

1965 
SEQUENCE_com
,

1966 
SEQUENCE_decode_b
,

1967 
SEQUENCE_code_d
,

1968 
SEQUENCE_decode_x
,

1969 
SEQUENCE_code_x
,

1970 #ifdef 
ASN_DISABLE_OER_SUPPORT


1974 
SEQUENCE_decode_r
,

1975 
SEQUENCE_code_r
,

1977 #ifde
ASN_DISABLE_PER_SUPPORT


1983 
SEQUENCE_decode_ur
,

1984 
SEQUENCE_code_ur
,

1985 
SEQUENCE_decode_
,

1986 
SEQUENCE_code_
,

1988 
SEQUENCE_ndom_fl
,

1993 
a_ndom_fl_su_t


1994 
	$SEQUENCE_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

1995 cڡ 
a_codg_cڡts_t
 *
cڡr
,

1996 
size_t
 
max_ngth
) {

1997 cڡ 
a_SEQUENCE_ecifics_t
 *
ecs
 =

1998 (cڡ 
a_SEQUENCE_ecifics_t
 *)
td
->
ecifics
;

1999 
a_ndom_fl_su_t
 
su_ok
 = {
ARFILL_OK
, 0};

2000 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

2001 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

2002 *

 = *

;

2003 
size_t
 
edx
;

2005 if(
max_ngth
 =0 
su_skd
;

2007 ()
cڡr
;

2009 if(

 =
NULL
) {

2010 

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

2011 if(

 =
NULL
) {

2012  
su_ed
;

2016 
edx
 = 0;dx < 
td
->
emts_cou
;dx++) {

2017 cڡ 
a_TYPE_memb_t
 *
m
 = &
td
->
emts
[
edx
];

2018 *
memb_r
;

2019 **
memb_r2
;

2020 
a_ndom_fl_su_t
 
tmes
;

2022 if(
m
->
tiڮ
 && 
	`a_ndom_bwn
(0, 4) == 2) {

2027 if(
m
->
ags
 & 
ATF_POINTER
) {

2029 
memb_r2
 = (**)((*)

 + 
m
->
memb_offt
);

2031 
memb_r
 = (*)

 + 
m
->
memb_offt
;

2032 
memb_r2
 = &
memb_r
;

2035 
tmes
 = 
m
->
ty
->

->
	`ndom_fl
(

2036 
m
->
ty
, 
memb_r2
, &m->
codg_cڡts
,

2037 
max_ngth
 > 
su_ok
.
ngth
 ? max_length -esult_ok.length : 0);

2038 
tmes
.
code
) {

2039 
ARFILL_OK
:

2040 
su_ok
.
ngth
 +
tmes
.length;

2042 
ARFILL_SKIPPED
:

2043 
	`as
(!(
m
->
ags
 & 
ATF_POINTER
|| *
memb_r2
 =
NULL
);

2045 
ARFILL_FAILED
:

2046 if(

 =*

) {

2047 
	`ASN_STRUCT_RESET
(*
td
, 

);

2049 
	`ASN_STRUCT_FREE
(*
td
, 

);

2051  
tmes
;

2055 *

 = 

;

2057  
su_ok
;

2058 
	}
}

	@constr_SEQUENCE_OF.c

6 
	~<a_.h
>

7 
	~<cڡr_SEQUENCE_OF.h
>

8 
	~<a_SEQUENCE_OF.h
>

13 
a_c_rv_t


14 
	$SEQUENCE_OF_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *
r
,

15 
g_mode
, 
b_v_g_t
 
g
,

16 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

17 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

18 cڡ 
a_ymous_qu_
 *
li
 = 
	`_A_CSEQUENCE_FROM_VOID
(
r
);

19 
size_t
 
compud_size
 = 0;

20 
ssize_t
 
codg_size
 = 0;

21 
a_c_rv_t
 
v
 = {0,0,0};

22 
edx
;

24 
	`ASN_DEBUG
("Eimg sizoSEQUENCE OF %s", 
td
->
me
);

29 
edx
 = 0;dx < 
li
->
cou
;dx++) {

30 *
memb_r
 = 
li
->
y
[
edx
];

31 if(!
memb_r
) ;

32 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
,

33 0, 
m
->
g
,

35 if(
v
.
coded
 == -1)

36  
v
;

37 
compud_size
 +
v
.
coded
;

43 
codg_size
 = 
	`d_wre_gs
(
td
, 
compud_size
, 
g_mode
, 1, 
g
,

44 
cb
, 
p_key
);

45 if(
codg_size
 == -1) {

46 
v
.
coded
 = -1;

47 
v
.
ed_ty
 = 
td
;

48 
v
.
ruu_r
 = 
r
;

49  
v
;

52 
compud_size
 +
codg_size
;

53 if(!
cb
) {

54 
v
.
coded
 = 
compud_size
;

55 
	`ASN__ENCODED_OK
(
v
);

58 
	`ASN_DEBUG
("Encodg memboSEQUENCE OF %s", 
td
->
me
);

63 
edx
 = 0;dx < 
li
->
cou
;dx++) {

64 *
memb_r
 = 
li
->
y
[
edx
];

65 if(!
memb_r
) ;

66 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
,

67 0, 
m
->
g
,

68 
cb
, 
p_key
);

69 if(
v
.
coded
 == -1)

70  
v
;

71 
codg_size
 +
v
.
coded
;

74 if(
compud_size
 !(
size_t
)
codg_size
) {

78 
v
.
coded
 = -1;

79 
v
.
ed_ty
 = 
td
;

80 
v
.
ruu_r
 = 
r
;

82 
v
.
coded
 = 
compud_size
;

83 
v
.
ruu_r
 = 0;

84 
v
.
ed_ty
 = 0;

87  
v
;

88 
	}
}

90 
a_c_rv_t


91 
	$SEQUENCE_OF_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

92 
ev
, 
x_cod_ags_e
 
ags
,

93 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

94 
a_c_rv_t
 

 = {0,0,0};

95 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

96 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

97 cڡ 
a_ymous_qu_
 *
li
 = 
	`_A_CSEQUENCE_FROM_VOID
(

);

98 cڡ *
mme
 = 
ecs
->
as_XMLVueLi


100 : ((*
m
->
me
?lm->m:lm->
ty
->
xml_g
);

101 
size_t
 
mn
 = 
mme
 ? 
	`
(mname) : 0;

102 
xn
 = (
ags
 & 
XER_F_CANONICAL
);

103 
i
;

105 if(!


ASN__ENCODE_FAILED
;

107 

.
coded
 = 0;

109 
i
 = 0; i < 
li
->
cou
; i++) {

110 
a_c_rv_t
 
tmr
 = {0,0,0};

111 *
memb_r
 = 
li
->
y
[
i
];

112 if(!
memb_r
) ;

114 if(
mme
) {

115 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
);

116 
	`ASN__CALLBACK3
("<", 1, 
mme
, 
mn
, ">", 1);

119 
tmr
 = 
m
->
ty
->

->
	`x_cod
lm->ty, 
memb_r
, 
ev
 + 1,

120 
ags
, 
cb
, 
p_key
);

121 if(
tmr
.
coded
 == -1) mper;

122 

.
coded
 +
tmr
.encoded;

123 if(
tmr
.
coded
 =0 && 
ecs
->
as_XMLVueLi
) {

124 cڡ *
me
 = 
m
->
ty
->
xml_g
;

125 
size_t
 
n
 = 
	`
(
me
);

126 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
 + 1);

127 
	`ASN__CALLBACK3
("<", 1, 
me
, 
n
, "/>", 2);

130 if(
mme
) {

131 
	`ASN__CALLBACK3
("</", 2, 
mme
, 
mn
, ">", 1);

135 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
 - 1);

137 
	`ASN__ENCODED_OK
(

);

138 
cb_ed
:

139 
ASN__ENCODE_FAILED
;

140 
	}
}

142 #ide
ASN_DISABLE_PER_SUPPORT


144 
a_c_rv_t


145 
	$SEQUENCE_OF_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

146 cڡ 
a_r_cڡts_t
 *
cڡts
,

147 cڡ *

, 
a_r_ou_t
 *
po
) {

148 cڡ 
a_ymous_qu_
 *
li
;

149 cڡ 
a_r_cڡt_t
 *

;

150 
a_c_rv_t
 

 = {0,0,0};

151 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

152 
size_t
 
coded_edx
;

154 if(!


ASN__ENCODE_FAILED
;

155 
li
 = 
	`_A_CSEQUENCE_FROM_VOID
(

);

157 

.
coded
 = 0;

159 
	`ASN_DEBUG
("Encodg %aSEQUENCE OF (%d)", 
td
->
me
, 
li
->
cou
);

161 if(
cڡts


 = &cڡts->
size
;

162 if(
td
->
codg_cڡts
.
r_cڡts
)

163 

 = &
td
->
codg_cڡts
.
r_cڡts
->
size
;

164 

 = 0;

167 if(

) {

168 
n__ro
 =

169 (
li
->
cou
 < 

->
low_bound
 ||i->cou > ct->
u_bound
);

170 
	`ASN_DEBUG
("lb %ld ub %ld %s", 

->
low_bound
, ct->
u_bound
,

171 

->
ags
 & 
APC_EXTENSIBLE
 ? "ext" : "fix");

172 if(

->
ags
 & 
APC_EXTENSIBLE
) {

174 if(
	`r_put_w_bs
(
po
, 
n__ro
, 1)
ASN__ENCODE_FAILED
;

175 if(
n__ro


 = 0;

176 } if(
n__ro
 && 

->
efive_bs
 >= 0) {

177 
ASN__ENCODE_FAILED
;

182 if(

 && ct->
efive_bs
 >= 0) {

184 if(
	`r_put_w_bs
(
po
, 
li
->
cou
 - 

->
low_bound
,

185 

->
efive_bs
))

186 
ASN__ENCODE_FAILED
;

187 } if(
li
->
cou
 == 0) {

191 i(
	`ur_put_ngth
(
po
, 0, 0)) {

192 
ASN__ENCODE_FAILED
;

194 
	`ASN__ENCODED_OK
(

);

197 
coded_edx
 = 0; (
ssize_t
ncoded_edx < 
li
->
cou
;) {

198 
ssize_t
 
may_code
;

199 
size_t
 
edx
;

200 
ed_eom
 = 0;

202 if(

 && ct->
efive_bs
 >= 0) {

203 
may_code
 = 
li
->
cou
;

205 
may_code
 =

206 
	`ur_put_ngth
(
po
, 
li
->
cou
 - 
coded_edx
, &
ed_eom
);

207 if(
may_code
 < 0
ASN__ENCODE_FAILED
;

210 
edx
 = 
coded_edx
;dx <ncoded_edx + 
may_code
;dx++) {

211 *
memb_r
 = 
li
->
y
[
edx
];

212 if(!
memb_r

ASN__ENCODE_FAILED
;

213 

 = 
m
->
ty
->

->
	`ur_cod
(

214 
m
->
ty
,lm->
codg_cڡts
.
r_cڡts
, 
memb_r
,

215 
po
);

216 if(

.
coded
 =-1
ASN__ENCODE_FAILED
;

219 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0))

220 
ASN__ENCODE_FAILED
;

222 
coded_edx
 +
may_code
;

225 
	`ASN__ENCODED_OK
(

);

226 
	}
}

228 
a_c_rv_t


229 
	$SEQUENCE_OF_code_
(cڡ 
a_TYPE_dest_t
 *
td
,

230 cڡ 
a_r_cڡts_t
 *
cڡts
,

231 cڡ *

, 
a_r_ou_t
 *
po
) {

232 cڡ 
a_ymous_qu_
 *
li
;

233 cڡ 
a_r_cڡt_t
 *

;

234 
a_c_rv_t
 

 = {0,0,0};

235 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

236 
q
;

238 if(!


ASN__ENCODE_FAILED
;

239 
li
 = 
	`_A_CSEQUENCE_FROM_VOID
(

);

241 

.
coded
 = 0;

243 
	`ASN_DEBUG
("Encodg %aSEQUENCE OF siz(%dusg ALIGNED PER", 
td
->
me
, 
li
->
cou
);

245 if(
cڡts


 = &cڡts->
size
;

246 if(
td
->
codg_cڡts
.
r_cڡts
)

247 

 = &
td
->
codg_cڡts
.
r_cڡts
->
size
;

248 

 = 0;

251 if(

) {

252 
n__ro
 = (
li
->
cou
 < 

->
low_bound


253 || 
li
->
cou
 > 

->
u_bound
);

254 
	`ASN_DEBUG
("lb %ld ub %ld %s",

255 

->
low_bound
, ct->
u_bound
,

256 

->
ags
 & 
APC_EXTENSIBLE
 ? "ext" : "fix");

257 if(

->
ags
 & 
APC_EXTENSIBLE
) {

259 if(
	`r_put_w_bs
(
po
, 
n__ro
, 1))

260 
ASN__ENCODE_FAILED
;

261 if(
n__ro


 = 0;

262 } if(
n__ro
 && 

->
efive_bs
 >= 0)

263 
ASN__ENCODE_FAILED
;

266 if(

 && ct->
efive_bs
 >= 0) {

272 i(
	`_put_ngth
(
po
, 

->
u_bound
 - ct->
low_bound
 + 1, 
li
->
cou
 - ct->lower_bound) < 0)

273 
ASN__ENCODE_FAILED
;

276 
q
 = -1; seq < 
li
->
cou
;) {

277 
ssize_t
 
mayEncode
;

278 if(
q
 < 0) seq = 0;

279 if(

 && ct->
efive_bs
 >= 0) {

280 
mayEncode
 = 
li
->
cou
;

282 
mayEncode
 = 
	`_put_ngth
(
po
, -1, 
li
->
cou
 - 
q
);

283 if(
mayEncode
 < 0
ASN__ENCODE_FAILED
;

286 
mayEncode
--) {

287 *
memb_r
 = 
li
->
y
[
q
++];

288 if(!
memb_r

ASN__ENCODE_FAILED
;

289 

 = 
m
->
ty
->

->
	`_cod
(elm->type,

290 
m
->
codg_cڡts
.
r_cڡts
, 
memb_r
, 
po
);

291 if(

.
coded
 == -1)

292 
ASN__ENCODE_FAILED
;

296 
	`ASN__ENCODED_OK
(

);

297 
	}
}

301 
	$SEQUENCE_OF_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

302 cڡ *
br
) {

303 cڡ 
a_ymous_qu_
 *
a
 = 
	`_A_CSEQUENCE_FROM_VOID
(

);

304 cڡ 
a_ymous_qu_
 *
b
 = 
	`_A_CSEQUENCE_FROM_VOID
(
br
);

305 
ssize_t
 
idx
;

307 if(
a
 && 
b
) {

308 
ssize_t
 
comm_ngth
 = (
a
->
cou
 < 
b
->count ?->count : b->count);

309 
idx
 = 0; idx < 
comm_ngth
; idx++) {

310 
t
 = 
td
->
emts
->
ty
->

->
	`com_ru
(

311 
td
->
emts
->
ty
, 
a
->
y
[
idx
], 
b
->array[idx]);

312 if(
t
) et;

315 if(
idx
 < 
b
->
cou
)

317 if(
idx
 < 
a
->
cou
)  1;

319 } if(!
a
) {

321 } if(!
b
) {

326 
	}
}

329 
a_TYPE_ݔi_t
 
	ga_OP_SEQUENCE_OF
 = {

330 
SEQUENCE_OF_
,

331 
SEQUENCE_OF_t
,

332 
SEQUENCE_OF_com
,

333 
SEQUENCE_OF_decode_b
,

334 
SEQUENCE_OF_code_d
,

335 
SEQUENCE_OF_decode_x
,

336 
SEQUENCE_OF_code_x
,

337 #ifdef 
ASN_DISABLE_OER_SUPPORT


341 
SEQUENCE_OF_decode_r
,

342 
SEQUENCE_OF_code_r
,

344 #ifde
ASN_DISABLE_PER_SUPPORT


350 
SEQUENCE_OF_decode_ur
,

351 
SEQUENCE_OF_code_ur
,

352 
SEQUENCE_OF_decode_
,

353 
SEQUENCE_OF_code_
,

355 
SEQUENCE_OF_ndom_fl
,

	@constr_SET_OF.c

6 
	~<a_.h
>

7 
	~<cڡr_SET_OF.h
>

8 
	~<a_SET_OF.h
>

15 
	#LEFT
 ((
size
<(
size_t
)
x
->

)?size:(size_t)x->)

	)

28 
	#SIZE_VIOLATION
 (
x
->

 >0 && (
size_t
)x-> <
size
)

	)

34 #unde
ADVANCE


35 
	#ADVANCE
(
num_bys
) do { \

36 
size_t
 
num
 = 
num_bys
; \

37 
r
 = ((cڡ *+ 
num
;\

38 
size
 -
num
; \

39 if(
x
->

 >= 0) \

40 
x
->

 -
num
; \

41 
csumed_mylf
 +
num
; \

42 } 0)

	)

47 #unde
NEXT_PHASE


48 #unde
PHASE_OUT


49 
	#NEXT_PHASE
(
x
) do { \

50 
x
->
pha
++; \

51 
x
->

 = 0; \

52 } 0)

	)

53 
	#PHASE_OUT
(
x
d{ ctx->
pha
 = 10; } 0)

	)

58 #unde
RETURN


59 
	#RETURN
(
_code
) do { \

60 
rv
.
code
 = 
_code
; \

61 
rv
.
csumed
 = 
csumed_mylf
;\

62  
rv
; \

63 } 0)

	)

68 
a_dec_rv_t


69 
	$SET_OF_decode_b
(cڡ 
a_codec_x_t
 *
t_codec_x
,

70 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

71 cڡ *
r
, 
size_t
 
size
, 
g_mode
) {

75 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

76 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

81 *

 = *
ru_r
;

82 
a_ru_x_t
 *
x
;

84 
b_v_g_t
 
v_g
;

85 
a_dec_rv_t
 
rv
;

87 
ssize_t
 
csumed_mylf
 = 0;

89 
	`ASN_DEBUG
("Decodg %aSET OF", 
td
->
me
);

94 if(

 == 0) {

95 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

96 if(

 == 0) {

97 
	`RETURN
(
RC_FAIL
);

104 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

109 
x
->
pha
) {

117 
rv
 = 
	`b_check_gs
(
t_codec_x
, 
td
, 
x
, 
r
, 
size
,

118 
g_mode
, 1, &
x
->

, 0);

119 if(
rv
.
code
 !
RC_OK
) {

120 
	`ASN_DEBUG
("%sagging check failed: %d",

121 
td
->
me
, 
rv
.
code
);

122  
rv
;

125 if(
x
->

 >= 0)

126 
x
->

 +
rv
.
csumed
;

127 
	`ADVANCE
(
rv
.
csumed
);

129 
	`ASN_DEBUG
("Structure consumes %ld bytes, "

130 "buf%ld", ()
x
->

, ()
size
);

132 
	`NEXT_PHASE
(
x
);

140 ;; 
x
->

 = 0) {

141 
ssize_t
 
g_n
;

143 if(
x
->

 & 1)

144 
miha2
;

150 if(
x
->

 == 0) {

151 
	`ASN_DEBUG
("End oSET OF %s", 
td
->
me
);

156 
	`PHASE_OUT
(
x
);

157 
	`RETURN
(
RC_OK
);

163 
g_n
 = 
	`b_tch_g
(
r
, 
LEFT
, &
v_g
);

164 
g_n
) {

165 0: if(!
SIZE_VIOLATION

	`RETURN
(
RC_WMORE
);

167 -1: 
	`RETURN
(
RC_FAIL
);

170 if(
x
->

 < 0 && ((cڡ 
ut8_t
 *)
r
)[0] == 0) {

171 if(
LEFT
 < 2) {

172 if(
SIZE_VIOLATION
)

173 
	`RETURN
(
RC_FAIL
);

175 
	`RETURN
(
RC_WMORE
);

176 } if(((cڡ 
ut8_t
 *)
r
)[1] == 0) {

186 if(
m
->
g
 !(
b_v_g_t
)-1) {

187 if(
	`BER_TAGS_EQUAL
(
v_g
, 
m
->
g
)) {

192 
	`ASN_DEBUG
("Unexpectedag %s fixed SET OF %s",

193 
	`b_v_g_rg
(
v_g
), 
td
->
me
);

194 
	`ASN_DEBUG
("%s SET OF hasag %s",

195 
td
->
me
, 
	`b_v_g_rg
(
m
->
g
));

196 
	`RETURN
(
RC_FAIL
);

203 
x
->

 |= 1;

204 
miha2
:

209 
rv
 = 
m
->
ty
->

->
	`b_decod
(
t_codec_x
,

210 
m
->
ty
, &
x
->
r
,, 
LEFT
, 0);

211 
	`ASN_DEBUG
("In %s SET OF %s code %d consumed %d",

212 
td
->
me
, 
m
->
ty
->name,

213 
rv
.
code
, (v.
csumed
);

214 
rv
.
code
) {

215 
RC_OK
:

217 
a_ymous_t_
 *
li
 = 
	`_A_SET_FROM_VOID
(

);

218 if(
	`ASN_SET_ADD
(
li
, 
x
->
r
) != 0)

219 
	`RETURN
(
RC_FAIL
);

221 
x
->
r
 = 0;

224 
RC_WMORE
:

225 if(!
SIZE_VIOLATION
) {

226 
	`ADVANCE
(
rv
.
csumed
);

227 
	`RETURN
(
RC_WMORE
);

230 
RC_FAIL
:

231 
	`ASN_STRUCT_FREE
(*
m
->
ty
, 
x
->
r
);

232 
x
->
r
 = 0;

233 
	`RETURN
(
RC_FAIL
);

236 
	`ADVANCE
(
rv
.
csumed
);

239 
	`NEXT_PHASE
(
x
);

244 
x
->

 < 0) {

245 if(
LEFT
 < 2) {

246 if(
LEFT
 > 0 && ((cڡ *)
r
)[0] != 0) {

248 
	`RETURN
(
RC_FAIL
);

250 
	`RETURN
(
RC_WMORE
);

253 if(((cڡ *)
r
)[0] == 0

254 && ((cڡ *)
r
)[1] == 0) {

255 
	`ADVANCE
(2);

256 
x
->

++;

258 
	`RETURN
(
RC_FAIL
);

262 
	`PHASE_OUT
(
x
);

265 
	`RETURN
(
RC_OK
);

266 
	}
}

271 
	s__bufr
 {

272 
ut8_t
 *
	mbuf
;

273 
size_t
 
	mngth
;

274 
size_t
 
	mlod_size
;

275 
	mbs_unud
;

278 
	$__addbys
(cڡ *
bufr
, 
size_t
 
size
, *
_buf_r
) {

279 
__bufr
 *
_buf
 = (__buf*)
_buf_r
;

281 if(
_buf
->
ngth
 + 
size
 >l_buf->
lod_size
) {

282 
size_t
 
w_size
 = 
_buf
->
lod_size
 ?l_buf->allocated_size : 8;

283 *
p
;

286 
w_size
 <<= 2;

287 } 
_buf
->
ngth
 + 
size
 > 
w_size
);

289 
p
 = 
	`REALLOC
(
_buf
->
buf
, 
w_size
);

290 if(
p
) {

291 
_buf
->
buf
 = 
p
;

292 
_buf
->
lod_size
 = 
w_size
;

298 
	`memy
(
_buf
->
buf
 +l_buf->
ngth
, 
bufr
, 
size
);

300 
_buf
->
ngth
 +
size
;

302 
	}
}

304 
	$as_unud_bs
(cڡ 
__bufr
* 
p
) {

305 if(
p
->
ngth
) {

306 
	`as
((
p
->
buf
[p->
ngth
-1] & ~(0xf<<->
bs_unud
)) == 0);

308 
	`as
(
p
->
bs_unud
 == 0);

310 
	}
}

312 
	$__buf_cmp
(cڡ *

, cڡ *
bp
) {

313 cڡ 
__bufr
 *
a
 = (cڡ __buf*)

;

314 cڡ 
__bufr
 *
b
 = (cڡ __buf*)
bp
;

315 
size_t
 
comm_n
;

316 
t
 = 0;

318 if(
a
->
ngth
 < 
b
->length)

319 
comm_n
 = 
a
->
ngth
;

321 
comm_n
 = 
b
->
ngth
;

323 i(
a
->
buf
 && 
b
->buf) {

324 
t
 = 
	`memcmp
(
a
->
buf
, 
b
->buf, 
comm_n
);

326 if(
t
 == 0) {

327 if(
a
->
ngth
 < 
b
->length)

328 
t
 = -1;

329 if(
a
->
ngth
 > 
b
->length)

330 
t
 = 1;

332 
	`as_unud_bs
(
a
);

333 
	`as_unud_bs
(
b
);

336  
t
;

337 
	}
}

340 
	$SET_OF__code_s܋d_
(
__bufr
 *
_buf
, 
size_t
 
cou
) {

341 
size_t
 
i
;

343 
i
 = 0; i < 
cou
; i++) {

344 
	`FREEMEM
(
_buf
[
i
].
buf
);

347 
	`FREEMEM
(
_buf
);

348 
	}
}

350 
	eSET_OF__code_mhod
 {

351 
	mSOES_DER
,

352 
	mSOES_CUPER


355 
__bufr
 *

356 
	$SET_OF__code_s܋d
(cڡ 
a_TYPE_memb_t
 *
m
,

357 cڡ 
a_ymous_t_
 *
li
,

358 
SET_OF__code_mhod
 
mhod
) {

359 
__bufr
 *
coded_s
;

360 
edx
;

362 
coded_s
 =

363 (
__bufr
 *)
	`CALLOC
(
li
->
cou
, (
coded_s
[0]));

364 if(
coded_s
 =
NULL
) {

365  
NULL
;

371 
edx
 = 0;dx < 
li
->
cou
;dx++) {

372 cڡ *
memb_r
 = 
li
->
y
[
edx
];

373 
__bufr
 *
codg_
 = &
coded_s
[
edx
];

374 
a_c_rv_t
 
v
 = {0,0,0};

376 if(!
memb_r
) ;

381 
mhod
) {

382 
SOES_DER
:

383 
v
 = 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
, 0,lm->
g
,

384 
__addbys
, 
codg_
);

386 
SOES_CUPER
:

387 
v
 = 
	`ur_code
(
m
->
ty
,

388 
m
->
codg_cڡts
.
r_cڡts
,

389 
memb_r
, 
__addbys
, 
codg_
);

390 if(
v
.
coded
 != -1) {

391 
size_t
 
exa_bs
 = 
v
.
coded
 % 8;

392 
	`as
(
codg_
->
ngth
 =(
size_t
)(
v
.
coded
 + 7) / 8);

393 
codg_
->
bs_unud
 = (8 - 
exa_bs
) & 0x7;

397 
	`as
(!"Unreachable");

400 if(
v
.
coded
 < 0) ;

403 if(
edx
 =
li
->
cou
) {

407 
	`qst
(
coded_s
, 
li
->
cou
, ncoded_s[0]), 
__buf_cmp
);

409  
coded_s
;

411 
	`SET_OF__code_s܋d_
(
coded_s
, 
edx
);

412  
NULL
;

414 
	}
}

420 
a_c_rv_t


421 
	$SET_OF_code_d
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

422 
g_mode
, 
b_v_g_t
 
g
, 
a_p_csume_bys_f
 *
cb
,

423 *
p_key
) {

424 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

425 cڡ 
a_ymous_t_
 *
li
 = 
	`_A_CSET_FROM_VOID
(

);

426 
size_t
 
compud_size
 = 0;

427 
ssize_t
 
codg_size
 = 0;

428 
__bufr
 *
coded_s
;

429 
edx
;

431 
	`ASN_DEBUG
("Eimg sizf SET OF %s", 
td
->
me
);

436 
edx
 = 0;dx < 
li
->
cou
;dx++) {

437 *
memb_r
 = 
li
->
y
[
edx
];

438 
a_c_rv_t
 
v
 = {0,0,0};

440 if(!
memb_r

ASN__ENCODE_FAILED
;

442 
v
 =

443 
m
->
ty
->

->
	`d_cod
lm->ty, 
memb_r
, 0,lm->
g
, 0, 0);

444 if(
v
.
coded
 == -1) rval;

445 
compud_size
 +
v
.
coded
;

452 
codg_size
 =

453 
	`d_wre_gs
(
td
, 
compud_size
, 
g_mode
, 1, 
g
, 
cb
, 
p_key
);

454 if(
codg_size
 < 0) {

455 
ASN__ENCODE_FAILED
;

457 
compud_size
 +
codg_size
;

459 if(!
cb
 || 
li
->
cou
 == 0) {

460 
a_c_rv_t
 
v
 = {0,0,0};

461 
v
.
coded
 = 
compud_size
;

462 
	`ASN__ENCODED_OK
(
v
);

465 
	`ASN_DEBUG
("Encodg membo%SET OF", 
td
->
me
);

472 
coded_s
 = 
	`SET_OF__code_s܋d
(
m
, 
li
, 
SOES_DER
);

478 
edx
 = 0;dx < 
li
->
cou
;dx++) {

479 
__bufr
 *
coded_
 = &
coded_s
[
edx
];

481 if(
	`cb
(
coded_
->
buf
,ncoded_->
ngth
, 
p_key
) < 0) {

484 
codg_size
 +
coded_
->
ngth
;

488 
	`SET_OF__code_s܋d_
(
coded_s
, 
li
->
cou
);

490 if(
edx
 =
li
->
cou
) {

491 
a_c_rv_t
 
v
 = {0,0,0};

492 
	`as
(
compud_size
 =(
size_t
)
codg_size
);

493 
v
.
coded
 = 
compud_size
;

494 
	`ASN__ENCODED_OK
(
v
);

496 
ASN__ENCODE_FAILED
;

498 
	}
}

500 #unde
XER_ADVANCE


501 
	#XER_ADVANCE
(
num_bys
) do { \

502 
size_t
 
num
 = 
num_bys
; \

503 
buf_r
 = ((cڡ *)buf_r+ 
num
;\

504 
size
 -
num
; \

505 
csumed_mylf
 +
num
; \

506 } 0)

	)

511 
a_dec_rv_t


512 
	$SET_OF_decode_x
(cڡ 
a_codec_x_t
 *
t_codec_x
,

513 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

514 cڡ *
t_mme
, cڡ *
buf_r
, 
size_t
 
size
) {

518 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

519 cڡ 
a_TYPE_memb_t
 *
emt
 = 
td
->
emts
;

520 cڡ *
m_g
;

521 cڡ *
xml_g
 = 
t_mme
 ? o_mm: 
td
->xml_tag;

526 *

 = *
ru_r
;

527 
a_ru_x_t
 *
x
;

529 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

530 
ssize_t
 
csumed_mylf
 = 0;

535 if(

 == 0) {

536 

 = *
ru_r
 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

537 if(

 =0
	`RETURN
(
RC_FAIL
);

541 if(
ecs
->
as_XMLVueLi
) {

542 
m_g
 = (
ecs
->
as_XMLVueLi
 == 1) ? 0 : "";

544 
m_g
 = (*
emt
->
me
)

545 ? 
emt
->
me
 :mt->
ty
->
xml_g
;

551 
x
 = (
a_ru_x_t
 *)((*)

 + 
ecs
->
x_offt
);

559 ; 
x
->
pha
 <= 2;) {

560 
px_chunk_ty_e
 
ch_ty
;

561 
ssize_t
 
ch_size
;

562 
x_check_g_e
 
tcv
;

567 if(
x
->
pha
 == 2) {

568 
a_dec_rv_t
 
tmv
 = {
RC_OK
, 0};

571 
	`ASN_DEBUG
("XER/SET OFm[%s]", 
m_g
);

572 
tmv
 = 
emt
->
ty
->

->
	`x_decod
(
t_codec_x
,

573 
emt
->
ty
, &
x
->
r
, 
m_g
,

574 
buf_r
, 
size
);

575 if(
tmv
.
code
 =
RC_OK
) {

576 
a_ymous_t_
 *
li
 = 
	`_A_SET_FROM_VOID
(

);

577 if(
	`ASN_SET_ADD
(
li
, 
x
->
r
) != 0)

578 
	`RETURN
(
RC_FAIL
);

579 
x
->
r
 = 0;

580 
	`XER_ADVANCE
(
tmv
.
csumed
);

582 
	`XER_ADVANCE
(
tmv
.
csumed
);

583 
	`RETURN
(
tmv
.
code
);

585 
x
->
pha
 = 1;

586 
	`ASN_DEBUG
("XER/SET OFha => %d", 
x
->
pha
);

593 
ch_size
 = 
	`x_xt_tok
(&
x
->
cڋxt
,

594 
buf_r
, 
size
, &
ch_ty
);

595 if(
ch_size
 == -1) {

596 
	`RETURN
(
RC_FAIL
);

598 
ch_ty
) {

599 
PXER_WMORE
:

600 
	`RETURN
(
RC_WMORE
);

601 
PXER_COMMENT
:

602 
PXER_TEXT
:

603 
	`XER_ADVANCE
(
ch_size
);

605 
PXER_TAG
:

610 
tcv
 = 
	`x_check_g
(
buf_r
, 
ch_size
, 
xml_g
);

611 
	`ASN_DEBUG
("XER/SET OF:cv = %d,h=%d=%s",

612 
tcv
, 
x
->
pha
, 
xml_g
);

613 
tcv
) {

614 
XCT_CLOSING
:

615 if(
x
->
pha
 == 0) ;

616 
x
->
pha
 = 0;

618 
XCT_BOTH
:

619 if(
x
->
pha
 == 0) {

621 
	`XER_ADVANCE
(
ch_size
);

622 
x
->
pha
 = 3;

623 
	`RETURN
(
RC_OK
);

626 
XCT_OPENING
:

627 if(
x
->
pha
 == 0) {

628 
	`XER_ADVANCE
(
ch_size
);

629 
x
->
pha
 = 1;

633 
XCT_UNKNOWN_OP
:

634 
XCT_UNKNOWN_BO
:

636 
	`ASN_DEBUG
("XER/SET OF:cv=%d,h=%d", 
tcv
, 
x
->
pha
);

637 if(
x
->
pha
 == 1) {

641 
x
->
pha
 = 2;

649 
	`ASN_DEBUG
("Unexpected XMLag in SET OF");

653 
x
->
pha
 = 3;

654 
	`RETURN
(
RC_FAIL
);

655 
	}
}

659 
	sx_tmp_c_s
 {

660 *
	mbufr
;

661 
size_t
 
	mofft
;

662 
size_t
 
	msize
;

663 } 
	tx_tmp_c_t
;

665 
	$SET_OF_code_x_back
(cڡ *
bufr
, 
size_t
 
size
, *
key
) {

666 
x_tmp_c_t
 *
t
 = (x_tmp_c_*)
key
;

667 if(
t
->
offt
 + 
size
 >=->size) {

668 
size_t
 
wsize
 = (
t
->
size
 << 2) + size;

669 *
p
 = 
	`REALLOC
(
t
->
bufr
, 
wsize
);

670 if(!
p
)  -1;

671 
t
->
bufr
 = 
p
;

672 
t
->
size
 = 
wsize
;

674 
	`memy
((*)
t
->
bufr
 +->
offt
, bufr, 
size
);

675 
t
->
offt
 +
size
;

677 
	}
}

679 
	$SET_OF_x_d
(cڡ *

, cڡ *
br
) {

680 cڡ 
x_tmp_c_t
 *
a
 = (cڡ x_tmp_c_*)

;

681 cڡ 
x_tmp_c_t
 *
b
 = (cڡ x_tmp_c_*)
br
;

682 
size_t
 
mn
 = 
a
->
offt
;

683 
t
;

684 if(
b
->
offt
 < 
mn
) minlen = b->offset;

686 
t
 = 
	`memcmp
(
a
->
bufr
, 
b
->bufr, 
mn
);

687 if(
t
 != 0) et;

688 if(
a
->
offt
 =
b
->offset)

690 if(
a
->
offt
 =
mn
)

693 
	}
}

696 
a_c_rv_t


697 
	$SET_OF_code_x
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

698 
x_cod_ags_e
 
ags
, 
a_p_csume_bys_f
 *
cb
,

699 *
p_key
) {

700 
a_c_rv_t
 

 = {0,0,0};

701 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

702 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

703 cڡ 
a_ymous_t_
 *
li
 = 
	`_A_CSET_FROM_VOID
(

);

704 cڡ *
mme
 = 
ecs
->
as_XMLVueLi


705 ? 0 : ((*
m
->
me
?lm->m:lm->
ty
->
xml_g
);

706 
size_t
 
mn
 = 
mme
 ? 
	`
(mname) : 0;

707 
xn
 = (
ags
 & 
XER_F_CANONICAL
);

708 
x_tmp_c_t
 *
cs
 = 0;

709 
size_t
 
cs_cou
 = 0;

710 *
ig_p_key
 = 
p_key
;

711 
a_p_csume_bys_f
 *
ig_cb
 = 
cb
;

712 
i
;

714 if(!


ASN__ENCODE_FAILED
;

716 if(
xn
) {

717 
cs
 = (
x_tmp_c_t
 *)
	`MALLOC
(
li
->
cou
 * (encs[0]));

718 if(!
cs

ASN__ENCODE_FAILED
;

719 
cb
 = 
SET_OF_code_x_back
;

722 

.
coded
 = 0;

724 
i
 = 0; i < 
li
->
cou
; i++) {

725 
a_c_rv_t
 
tmr
 = {0,0,0};

727 *
memb_r
 = 
li
->
y
[
i
];

728 if(!
memb_r
) ;

730 if(
cs
) {

731 
	`memt
(&
cs
[
cs_cou
], 0, (encs[0]));

732 
p_key
 = &
cs
[
cs_cou
];

733 
cs_cou
++;

736 if(
mme
) {

737 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
);

738 
	`ASN__CALLBACK3
("<", 1, 
mme
, 
mn
, ">", 1);

741 if(!
xn
 && 
ecs
->
as_XMLVueLi
 == 1)

742 
	`ASN__TEXT_INDENT
(1, 
ev
 + 1);

743 
tmr
 = 
m
->
ty
->

->
	`x_cod
lm->ty, 
memb_r
,

744 
ev
 + (
ecs
->
as_XMLVueLi
 != 2),

745 
ags
, 
cb
, 
p_key
);

746 if(
tmr
.
coded
 == -1) mper;

747 

.
coded
 +
tmr
.encoded;

748 if(
tmr
.
coded
 =0 && 
ecs
->
as_XMLVueLi
) {

749 cڡ *
me
 = 
m
->
ty
->
xml_g
;

750 
size_t
 
n
 = 
	`
(
me
);

751 
	`ASN__CALLBACK3
("<", 1, 
me
, 
n
, "/>", 2);

754 if(
mme
) {

755 
	`ASN__CALLBACK3
("</", 2, 
mme
, 
mn
, ">", 1);

760 if(!
xn

	`ASN__TEXT_INDENT
(1, 
ev
 - 1);

762 if(
cs
) {

763 
x_tmp_c_t
 *
c
 = 
cs
;

764 
x_tmp_c_t
 *
d
 = 
cs
 + 
cs_cou
;

765 
ssize_t
 
cڌ_size
 = 0;

767 

.
coded
 = 0;

768 
cb
 = 
ig_cb
;

769 
p_key
 = 
ig_p_key
;

770 
	`qst
(
cs
, 
cs_cou
, ncs[0]), 
SET_OF_x_d
);

772 ; 
c
 < 
d
;nc++) {

773 
	`ASN__CALLBACK
(
c
->
bufr
,nc->
offt
);

774 
	`FREEMEM
(
c
->
bufr
);

775 
c
->
bufr
 = 0;

776 
cڌ_size
 +
c
->
offt
;

778 
	`as
(
cڌ_size
 =

.
coded
);

781 
nup
;

782 
cb_ed
:

783 
ASN__ENCODE_FAILED
;

784 
nup
:

785 if(
cs
) {

786 
size_t
 
n
;

787 
n
 = 0; < 
cs_cou
;++) {

788 
	`FREEMEM
(
cs
[
n
].
bufr
);

790 
	`FREEMEM
(
cs
);

792 
	`ASN__ENCODED_OK
(

);

793 
	}
}

796 
	$SET_OF_t
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

, 
ev
,

797 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

798 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

799 cڡ 
a_ymous_t_
 *
li
 = 
	`_A_CSET_FROM_VOID
(

);

800 
t
;

801 
i
;

803 if(!

 (
	`cb
("<ab>", 8, 
p_key
) < 0) ? -1 : 0;

806 if(
	`cb
(
td
->
me
, 
	`
d->me), 
p_key
) < 0

807 || 
	`cb
(" ::{", 6, 
p_key
) < 0)

810 
i
 = 0; i < 
li
->
cou
; i++) {

811 cڡ *
memb_r
 = 
li
->
y
[
i
];

812 if(!
memb_r
) ;

814 
	`_i_INDENT
(1);

816 
t
 = 
m
->
ty
->

->
	`t_ru
lm->ty, 
memb_r
,

817 
ev
 + 1, 
cb
, 
p_key
);

818 if(
t
) et;

821 
ev
--;

822 
	`_i_INDENT
(1);

824  (
	`cb
("}", 1, 
p_key
) < 0) ? -1 : 0;

825 
	}
}

828 
	$SET_OF_
(cڡ 
a_TYPE_dest_t
 *
td
, *
r
,

829 
a_ru__mhod
 
mhod
) {

830 if(
td
 && 
r
) {

831 cڡ 
a_SET_OF_ecifics_t
 *
ecs
;

832 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

833 
a_ymous_t_
 *
li
 = 
	`_A_SET_FROM_VOID
(
r
);

834 
a_ru_x_t
 *
x
;

835 
i
;

841 
i
 = 0; i < 
li
->
cou
; i++) {

842 *
memb_r
 = 
li
->
y
[
i
];

843 if(
memb_r
)

844 
	`ASN_STRUCT_FREE
(*
m
->
ty
, 
memb_r
);

846 
li
->
cou
 = 0;

848 
	`a_t_emy
(
li
);

850 
ecs
 = (cڡ 
a_SET_OF_ecifics_t
 *)
td
->
ecifics
;

851 
x
 = (
a_ru_x_t
 *)((*)
r
 + 
ecs
->
x_offt
);

852 if(
x
->
r
) {

853 
	`ASN_STRUCT_FREE
(*
m
->
ty
, 
x
->
r
);

854 
x
->
r
 = 0;

857 
mhod
) {

858 
ASFM_FREE_EVERYTHING
:

859 
	`FREEMEM
(
r
);

861 
ASFM_FREE_UNDERLYING
:

863 
ASFM_FREE_UNDERLYING_AND_RESET
:

864 
	`memt
(
r
, 0, 
ecs
->
ru_size
);

868 
	}
}

871 
	$SET_OF_cڡt
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

872 
a_p_cڡt_ed_f
 *
cb
, *
p_key
) {

873 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

874 
a_cڡr_check_f
 *
cڡr
;

875 cڡ 
a_ymous_t_
 *
li
 = 
	`_A_CSET_FROM_VOID
(

);

876 
i
;

878 if(!

) {

879 
	`ASN__CTFAIL
(
p_key
, 
td
, 

,

881 
td
->
me
, 
__FILE__
, 
__LINE__
);

885 
cڡr
 = 
m
->
codg_cڡts
.
g_cڡts
;

886 if(!
cڡr
cڡ
m
->
ty
->
codg_cڡts
.
g_cڡts
;

892 
i
 = 0; i < 
li
->
cou
; i++) {

893 cڡ *
memb_r
 = 
li
->
y
[
i
];

894 
t
;

896 if(!
memb_r
) ;

898 
t
 = 
	`cڡr
(
m
->
ty
, 
memb_r
, 
cb
, 
p_key
);

899 if(
t
) et;

903 
	}
}

905 #ide
ASN_DISABLE_PER_SUPPORT


907 
a_dec_rv_t


908 
	$SET_OF_decode_ur
(cڡ 
a_codec_x_t
 *
t_codec_x
,

909 cڡ 
a_TYPE_dest_t
 *
td
,

910 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

911 
a_r_da_t
 *
pd
) {

912 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

913 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

914 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

915 *

 = *

;

916 
a_ymous_t_
 *
li
;

917 cڡ 
a_r_cڡt_t
 *

;

918 

 = 0;

919 
ssize_t
 
ms
;

921 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

922 
ASN__DECODE_FAILED
;

927 if(!

) {

928 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

929 if(!


ASN__DECODE_FAILED
;

931 
li
 = 
	`_A_SET_FROM_VOID
(

);

934 if(
cڡts


 = &cڡts->
size
;

935 if(
td
->
codg_cڡts
.
r_cڡts
)

936 

 = &
td
->
codg_cڡts
.
r_cڡts
->
size
;

937 

 = 0;

939 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

940 
vue
 = 
	`r_g_w_bs
(
pd
, 1);

941 if(
vue
 < 0
ASN__DECODE_STARVED
;

942 if(
vue


 = 0;

945 if(

 && ct->
efive_bs
 >= 0) {

947 
ms
 = 
	`r_g_w_bs
(
pd
, 

->
efive_bs
);

948 
	`ASN_DEBUG
("Preparingo fetch %ld+%ldlements from %s",

949 ()
ms
, 

->
low_bound
, 
td
->
me
);

950 if(
ms
 < 0
ASN__DECODE_STARVED
;

951 
ms
 +

->
low_bound
;

953 
ms
 = -1;

957 
i
;

958 if(
ms
 < 0) {

959 
ms
 = 
	`ur_g_ngth
(
pd
, -1, 0, &

);

960 
	`ASN_DEBUG
("Gفdecod%" 
ASN_PRI_SSIZE
 "lements (eff %d)",

961 
ms
, ()(

 ? ct->
efive_bs
 : -1));

962 if(
ms
 < 0
ASN__DECODE_STARVED
;

965 
i
 = 0; i < 
ms
; i++) {

966 *
r
 = 0;

967 
	`ASN_DEBUG
("SET OF %decodg", 
m
->
ty
->
me
);

968 
rv
 = 
m
->
ty
->

->
	`ur_decod
(
t_codec_x
,lm->type,

969 
m
->
codg_cڡts
.
r_cڡts
, &
r
, 
pd
);

970 
	`ASN_DEBUG
("%s SET OF %s decoded %d, %p",

971 
td
->
me
, 
m
->
ty
->me, 
rv
.
code
, 
r
);

972 if(
rv
.
code
 =
RC_OK
) {

973 if(
	`ASN_SET_ADD
(
li
, 
r
) == 0) {

974 if(
rv
.
csumed
 =0 && 
ms
 > 200) {

976 
ASN__DECODE_FAILED
;

980 
	`ASN_DEBUG
("Failedoddlement into %s",

981 
td
->
me
);

983 
rv
.
code
 = 
RC_FAIL
;

985 
	`ASN_DEBUG
("Failed decoding %s of %s (SET OF)",

986 
m
->
ty
->
me
, 
td
->name);

988 if(
r

	`ASN_STRUCT_FREE
(*
m
->
ty
,tr);

989  
rv
;

992 
ms
 = -1;

993 } 

);

995 
	`ASN_DEBUG
("Decoded %aSET OF", 
td
->
me
);

997 
rv
.
code
 = 
RC_OK
;

998 
rv
.
csumed
 = 0;

999  
rv
;

1000 
	}
}

1002 
a_c_rv_t


1003 
	$SET_OF_code_ur
(cڡ 
a_TYPE_dest_t
 *
td
,

1004 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

1005 
a_r_ou_t
 *
po
) {

1006 cڡ 
a_ymous_t_
 *
li
;

1007 cڡ 
a_r_cڡt_t
 *

;

1008 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

1009 
__bufr
 *
coded_s
;

1010 
a_c_rv_t
 

 = {0,0,0};

1011 
size_t
 
coded_edx
;

1013 if(!


ASN__ENCODE_FAILED
;

1015 
li
 = 
	`_A_CSET_FROM_VOID
(

);

1017 

.
coded
 = 0;

1019 
	`ASN_DEBUG
("Encodg %aSEQUENCE OF (%d)", 
td
->
me
, 
li
->
cou
);

1021 if(
cڡts


 = &cڡts->
size
;

1022 if(
td
->
codg_cڡts
.
r_cڡts
)

1023 

 = &
td
->
codg_cڡts
.
r_cڡts
->
size
;

1024 

 = 0;

1027 if(

) {

1028 
n__ro
 =

1029 (
li
->
cou
 < 

->
low_bound
 ||i->cou > ct->
u_bound
);

1030 
	`ASN_DEBUG
("lb %ld ub %ld %s", 

->
low_bound
, ct->
u_bound
,

1031 

->
ags
 & 
APC_EXTENSIBLE
 ? "ext" : "fix");

1032 if(

->
ags
 & 
APC_EXTENSIBLE
) {

1034 if(
	`r_put_w_bs
(
po
, 
n__ro
, 1)
ASN__ENCODE_FAILED
;

1035 if(
n__ro


 = 0;

1036 } if(
n__ro
 && 

->
efive_bs
 >= 0) {

1037 
ASN__ENCODE_FAILED
;

1042 if(

 && ct->
efive_bs
 >= 0) {

1044 if(
	`r_put_w_bs
(
po
, 
li
->
cou
 - 

->
low_bound
,

1045 

->
efive_bs
))

1046 
ASN__ENCODE_FAILED
;

1047 } if(
li
->
cou
 == 0) {

1051 i(
	`ur_put_ngth
(
po
, 0, 0)) {

1052 
ASN__ENCODE_FAILED
;

1054 
	`ASN__ENCODED_OK
(

);

1062 
coded_s
 = 
	`SET_OF__code_s܋d
(
m
, 
li
, 
SOES_CUPER
);

1064 
coded_edx
 = 0; (
ssize_t
ncoded_edx < 
li
->
cou
;) {

1065 
ssize_t
 
may_code
;

1066 
size_t
 
edx
;

1067 
ed_eom
 = 0;

1069 if(

 && ct->
efive_bs
 >= 0) {

1070 
may_code
 = 
li
->
cou
;

1072 
may_code
 =

1073 
	`ur_put_ngth
(
po
, 
li
->
cou
 - 
coded_edx
, &
ed_eom
);

1074 if(
may_code
 < 0
ASN__ENCODE_FAILED
;

1077 
edx
 = 
coded_edx
;dx <ncoded_edx + 
may_code
;dx++) {

1078 cڡ 
__bufr
 *

 = &
coded_s
[
edx
];

1079 if(
	`a_put_my_bs
(
po
, 

->
buf
,

1080 (8 * 

->
ngth
-l->
bs_unud
) < 0) {

1085 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0))

1086 
ASN__ENCODE_FAILED
;

1088 
coded_edx
 +
may_code
;

1091 
	`SET_OF__code_s܋d_
(
coded_s
, 
li
->
cou
);

1093 if((
ssize_t
)
coded_edx
 =
li
->
cou
) {

1094 
	`ASN__ENCODED_OK
(

);

1096 
ASN__ENCODE_FAILED
;

1098 
	}
}

1100 
a_dec_rv_t


1101 
	$SET_OF_decode_
(cڡ 
a_codec_x_t
 *
t_codec_x
,

1102 cڡ 
a_TYPE_dest_t
 *
td
,

1103 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

1104 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

1105 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 = (cڡ_SET_OF_ecifics_*)
td
->
ecifics
;

1106 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

1107 *

 = *

;

1108 
a_ymous_t_
 *
li
;

1109 cڡ 
a_r_cڡt_t
 *

;

1110 

 = 0;

1111 
ssize_t
 
ms
;

1113 if(
	`ASN__STACK_OVERFLOW_CHECK
(
t_codec_x
))

1114 
ASN__DECODE_FAILED
;

1119 if(!

) {

1120 

 = *

 = 
	`CALLOC
(1, 
ecs
->
ru_size
);

1121 if(!


ASN__DECODE_FAILED
;

1123 
li
 = 
	`_A_SET_FROM_VOID
(

);

1126 if(
cڡts


 = &cڡts->
size
;

1127 if(
td
->
codg_cڡts
.
r_cڡts
)

1128 

 = &
td
->
codg_cڡts
.
r_cڡts
->
size
;

1129 

 = 0;

1131 if(

 && ct->
ags
 & 
APC_EXTENSIBLE
) {

1132 
vue
 = 
	`r_g_w_bs
(
pd
, 1);

1133 if(
vue
 < 0
ASN__DECODE_STARVED
;

1134 if(
vue


 = 0;

1137 if(

 && ct->
efive_bs
 >= 0) {

1139 
ms
 = 
	`_g_nnwn
(
pd
, 

->
u_bound
 - ct->
low_bound
 + 1);

1140 
	`ASN_DEBUG
("Preparingo fetch %ld+%ldlements from %s",

1141 ()
ms
, 

->
low_bound
, 
td
->
me
);

1142 if(
ms
 < 0
ASN__DECODE_STARVED
;

1143 
ms
 +

->
low_bound
;

1145 
ms
 = -1;

1149 
i
;

1150 if(
ms
 < 0) {

1151 
ms
 = 
	`_g_ngth
(
pd
, 

 ? ct->
u_bound
 - ct->
low_bound
 + 1 : -1,

1152 

 ? ct->
efive_bs
 : -1, &

);

1153 
	`ASN_DEBUG
("Goto decode %dlements (eff %d)",

1154 ()
ms
, ()(

 ? ct->
efive_bs
 : -1));

1155 if(
ms
 < 0
ASN__DECODE_STARVED
;

1158 
i
 = 0; i < 
ms
; i++) {

1159 *
r
 = 0;

1160 
	`ASN_DEBUG
("SET OF %decodg", 
m
->
ty
->
me
);

1161 
rv
 = 
m
->
ty
->

->
	`_decod
(
t_codec_x
,lm->type,

1162 
m
->
codg_cڡts
.
r_cڡts
, &
r
, 
pd
);

1163 
	`ASN_DEBUG
("%s SET OF %s decoded %d, %p",

1164 
td
->
me
, 
m
->
ty
->me, 
rv
.
code
, 
r
);

1165 if(
rv
.
code
 =
RC_OK
) {

1166 if(
	`ASN_SET_ADD
(
li
, 
r
) == 0)

1168 
	`ASN_DEBUG
("Failedoddlement into %s",

1169 
td
->
me
);

1171 
rv
.
code
 = 
RC_FAIL
;

1173 
	`ASN_DEBUG
("Failed decoding %s of %s (SET OF)",

1174 
m
->
ty
->
me
, 
td
->name);

1176 if(
r

	`ASN_STRUCT_FREE
(*
m
->
ty
,tr);

1177  
rv
;

1180 
ms
 = -1;

1181 } 

);

1183 
	`ASN_DEBUG
("Decoded %aSET OF", 
td
->
me
);

1185 
rv
.
code
 = 
RC_OK
;

1186 
rv
.
csumed
 = 0;

1187  
rv
;

1188 
	}
}

1192 
	scomb_r
 {

1193 cڡ 
a_TYPE_dest_t
 *
	mtd
;

1194 cڡ *
	m
;

1198 
	$SET_OF__com_cb
(cڡ *

, cڡ *
br
) {

1199 cڡ 
comb_r
 *
a
 = 

;

1200 cڡ 
comb_r
 *
b
 = 
br
;

1201 
	`as
(
a
->
td
 =
b
->td);

1202  
a
->
td
->

->
	`com_ru
->td,->

, 
b
->sptr);

1203 
	}
}

1206 
	$SET_OF_com
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

1207 cڡ *
br
) {

1208 cڡ 
a_ymous_t_
 *
a
 = 
	`_A_CSET_FROM_VOID
(

);

1209 cڡ 
a_ymous_t_
 *
b
 = 
	`_A_CSET_FROM_VOID
(
br
);

1211 if(
a
 && 
b
) {

1212 
comb_r
 *
as܋d
;

1213 
comb_r
 *
bs܋d
;

1214 
ssize_t
 
comm_ngth
;

1215 
ssize_t
 
idx
;

1217 if(
a
->
cou
 == 0) {

1218 if(
b
->
cou
)  -1;

1220 } if(
b
->
cou
 == 0) {

1224 
as܋d
 = 
	`MALLOC
(
a
->
cou
 * (asorted[0]));

1225 
bs܋d
 = 
	`MALLOC
(
b
->
cou
 * (bsorted[0]));

1226 if(!
as܋d
 || !
bs܋d
) {

1227 
	`FREEMEM
(
as܋d
);

1228 
	`FREEMEM
(
bs܋d
);

1232 
idx
 = 0; idx < 
a
->
cou
; idx++) {

1233 
as܋d
[
idx
].
td
 =d->
emts
->
ty
;

1234 
as܋d
[
idx
].

 = 
a
->
y
[idx];

1237 
idx
 = 0; idx < 
b
->
cou
; idx++) {

1238 
bs܋d
[
idx
].
td
 =d->
emts
->
ty
;

1239 
bs܋d
[
idx
].

 = 
b
->
y
[idx];

1242 
	`qst
(
as܋d
, 
a
->
cou
, s܋d[0]), 
SET_OF__com_cb
);

1243 
	`qst
(
bs܋d
, 
b
->
cou
, (bs܋d[0]), 
SET_OF__com_cb
);

1245 
comm_ngth
 = (
a
->
cou
 < 
b
->count ?->count : b->count);

1246 
idx
 = 0; idx < 
comm_ngth
; idx++) {

1247 
t
 = 
td
->
emts
->
ty
->

->
	`com_ru
(

1248 
td
->
emts
->
ty
, 
as܋d
[
idx
].

, 
bs܋d
[idx].sptr);

1249 if(
t
) {

1250 
	`FREEMEM
(
as܋d
);

1251 
	`FREEMEM
(
bs܋d
);

1252  
t
;

1256 
	`FREEMEM
(
as܋d
);

1257 
	`FREEMEM
(
bs܋d
);

1259 if(
idx
 < 
b
->
cou
)

1261 if(
idx
 < 
a
->
cou
)  1;

1262 } if(!
a
) {

1264 } if(!
b
) {

1269 
	}
}

1272 
a_TYPE_ݔi_t
 
	ga_OP_SET_OF
 = {

1273 
SET_OF_
,

1274 
SET_OF_t
,

1275 
SET_OF_com
,

1276 
SET_OF_decode_b
,

1277 
SET_OF_code_d
,

1278 
SET_OF_decode_x
,

1279 
SET_OF_code_x
,

1280 #ifde
ASN_DISABLE_OER_SUPPORT


1284 
SET_OF_decode_r
,

1285 
SET_OF_code_r
,

1287 #ifde
ASN_DISABLE_PER_SUPPORT


1293 
SET_OF_decode_ur
,

1294 
SET_OF_code_ur
,

1295 
SET_OF_decode_
,

1298 
SET_OF_ndom_fl
,

1303 
a_ndom_fl_su_t


1304 
	$SET_OF_ndom_fl
(cڡ 
a_TYPE_dest_t
 *
td
, **

,

1305 cڡ 
a_codg_cڡts_t
 *
cڡts
,

1306 
size_t
 
max_ngth
) {

1307 cڡ 
a_SET_OF_ecifics_t
 *
ecs
 =

1308 (cڡ 
a_SET_OF_ecifics_t
 *)
td
->
ecifics
;

1309 
a_ndom_fl_su_t
 
s_ok
 = {
ARFILL_OK
, 0};

1310 
a_ndom_fl_su_t
 
su_ed
 = {
ARFILL_FAILED
, 0};

1311 
a_ndom_fl_su_t
 
su_skd
 = {
ARFILL_SKIPPED
, 0};

1312 cڡ 
a_TYPE_memb_t
 *
m
 = 
td
->
emts
;

1313 *

 = *

;

1314 
max_emts
 = 5;

1315 
b
 = 0;

1316 
sub
 = 0;

1317 
size_t
 
d_n
;

1319 if(
max_ngth
 =0 
su_skd
;

1321 if(

 =
NULL
) {

1322 

 = (*

 = 
	`CALLOC
(1, 
ecs
->
ru_size
));

1323 if(

 =
NULL
) {

1324  
su_ed
;

1328 
	`a_ndom_bwn
(0, 6)) {

1329 0: 
max_emts
 = 0; ;

1330 1: 
max_emts
 = 1; ;

1331 2: 
max_emts
 = 5; ;

1332 3: 
max_emts
 = 
max_ngth
; ;

1333 4: 
max_emts
 = 
max_ngth
 / 2; ;

1334 5: 
max_emts
 = 
max_ngth
 / 4; ;

1337 
sub
 = 
b
 + 
max_emts
;

1339 if(!
cڡts
 || !cڡts->
r_cڡts
)

1340 
cڡts
 = &
td
->
codg_cڡts
;

1341 if(
cڡts
->
r_cڡts
) {

1342 cڡ 
a_r_cڡt_t
 *
pc
 = &
cڡts
->
r_cڡts
->
size
;

1343 if(
pc
->
ags
 & 
APC_SEMI_CONSTRAINED
) {

1344 
b
 = 
pc
->
low_bound
;

1345 
sub
 = 
pc
->
low_bound
 + 
max_emts
;

1346 } if(
pc
->
ags
 & 
APC_CONSTRAINED
) {

1347 
b
 = 
pc
->
low_bound
;

1348 
sub
 = 
pc
->
u_bound
;

1349 if(
sub
 - 
b
 > 
max_emts
) sub = slb + max_elements;

1354 
	`a_ndom_bwn
(-1, 4)) {

1358 if(
cڡts
->
r_cڡts


1359 && (
cڡts
->
r_cڡts
->
size
.
ags
 & 
APC_EXTENSIBLE
)) {

1360 
	`a_ndom_bwn
(0, 5)) {

1363 
d_n
 = 0;

1366 if(
b
 > 0) {

1367 
d_n
 = 
b
 - 1;

1369 
d_n
 = 0;

1373 
d_n
 = 
	`a_ndom_bwn
(0, 
b
);

1376 if(
sub
 < (
ssize_t
)
max_ngth
) {

1377 
d_n
 = 
sub
 + 1;

1379 
d_n
 = 
max_ngth
;

1383 if(
sub
 < (
ssize_t
)
max_ngth
) {

1384 
d_n
 = 
	`a_ndom_bwn
(
sub
 + 1, 
max_ngth
);

1386 
d_n
 = 
max_ngth
;

1390 
d_n
 = 
max_ngth
;

1397 
d_n
 = 
	`a_ndom_bwn
(
b
, 
sub
);

1400 if(
b
 < 
sub
) {

1401 
d_n
 = 
	`a_ndom_bwn
(
b
 + 1, 
sub
);

1406 
d_n
 = 
	`a_ndom_bwn
(
b
, slb);

1409 if(
b
 < 
sub
) {

1410 
d_n
 = 
	`a_ndom_bwn
(
b
, 
sub
 - 1);

1415 
d_n
 = 
	`a_ndom_bwn
(
sub
, sub);

1419 ; 
d_n
 > 0;nd_len--) {

1420 
a_ymous_t_
 *
li
 = 
	`_A_SET_FROM_VOID
(

);

1421 *
r
 = 0;

1422 
a_ndom_fl_su_t
 
tmes
 = 
m
->
ty
->

->
	`ndom_fl
(

1423 
m
->
ty
, &
r
, &m->
codg_cڡts
,

1424 (
max_ngth
 > 
s_ok
.
ngth
 ? max_length -es_ok.length : 0)

1425 / 
d_n
);

1426 
tmes
.
code
) {

1427 
ARFILL_OK
:

1428 
	`ASN_SET_ADD
(
li
, 
r
);

1429 
s_ok
.
ngth
 +
tmes
.length;

1431 
ARFILL_SKIPPED
:

1433 
ARFILL_FAILED
:

1434 
	`as
(
r
 == 0);

1435  
tmes
;

1439  
s_ok
;

1440 
	}
}

	@constr_TYPE.c

5 
	~<a_.h
>

6 
	~<cڡr_TYPE.h
>

7 
	~<o.h
>

12 
	$g_a1c_vmt_vsi
({  
ASN1C_ENVIRONMENT_VERSION
; 
	}
}

14 
a_p_csume_bys_f
 
	g_t2
;

19 
b_v_g_t


20 
	$a_TYPE_outmo_g
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

21 cڡ *
ru_r
, 
g_mode
, 
b_v_g_t
 
g
) {

23 if(
g_mode
)

24  
g
;

26 if(
ty_dest
->
gs_cou
)

27  
ty_dest
->
gs
[0];

29  
ty_dest
->

->
	`outmo_g
y_dest, 
ru_r
, 0, 0);

30 
	}
}

36 
	$a_rt
(
FILE
 *
am
, cڡ 
a_TYPE_dest_t
 *
td
,

37 cڡ *
ru_r
) {

38 if(!
am
衻am = 
dout
;

39 if(!
td
 || !
ru_r
) {

40 
o
 = 
EINVAL
;

45 if(
td
->

->
	`t_ru
d, 
ru_r
, 1, 
_t2
, 
am
)) {

50 if(
	`_t2
("\n", 1, 
am
)) {

54  
	`fush
(
am
);

55 
	}
}

59 
	$_t2
(cڡ *
bufr
, 
size_t
 
size
, *
p_key
) {

60 
FILE
 *
am
 = (FILE *)
p_key
;

62 if(
	`fwre
(
bufr
, 1, 
size
, 
am
) != size)

66 
	}
}

73 
ASN_DEBUG_f
(cڡ *
fmt
, ...);

74 
	$ASN_DEBUG_f
(cڡ *
fmt
, ...) {

75 
va_li
 

;

76 
	`va_t
(

, 
fmt
);

77 
	`vrtf
(
dr
, 
fmt
, 

);

78 
	`rtf
(
dr
, "\n");

79 
	`va_d
(

);

80 
	}
}

	@constraints.c

1 
	~<a_.h
>

2 
	~<cڡts.h
>

5 
	$a_gic_no_cڡt
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

6 cڡ *
ru_r
,

7 
a_p_cڡt_ed_f
 *
cb
, *
key
) {

8 ()
ty_dest
;

9 ()
ru_r
;

10 ()
cb
;

11 ()
key
;

15 
	}
}

18 
	$a_gic_unknown_cڡt
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

19 cڡ *
ru_r
,

20 
a_p_cڡt_ed_f
 *
cb
, *
key
) {

21 ()
ty_dest
;

22 ()
ru_r
;

23 ()
cb
;

24 ()
key
;

28 
	}
}

30 
	srbufDesc
 {

31 cڡ 
a_TYPE_dest_t
 *
	med_ty
;

32 cڡ *
	med_ru_r
;

33 *
	mrbuf
;

34 
size_t
 
	m
;

38 
	$_a_i_cb
(*
key
, cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

39 cڡ *
fmt
, ...) {

40 
rbufDesc
 *
g
 = 
key
;

41 
va_li
 

;

42 
ssize_t
 
vn
;

43 
ssize_t
 
maxn
;

45 
g
->
ed_ty
 = 
td
;

46 
g
->
ed_ru_r
 = 

;

48 
maxn
 = 
g
->

;

49 if(
maxn
 <= 0)

52 
	`va_t
(

, 
fmt
);

53 
vn
 = 
	`vtf
(
g
->
rbuf
, 
maxn
, 
fmt
, 

);

54 
	`va_d
(

);

55 if(
vn
 >
maxn
) {

56 
g
->
rbuf
[
maxn
-1] = '\0';

57 
g
->

 = 
maxn
 - 1;

59 } if(
vn
 >= 0) {

60 
g
->
rbuf
[
vn
] = '\0';

61 
g
->

 = 
vn
;

66 
vn
 = ("<broken vsnprintf>") - 1;

67 
maxn
--;

68 
g
->

 = 
vn
 < 
maxn
 ? vlen : maxlen;

69 
	`memy
(
g
->
rbuf
, "<brok vtf>",rg->

);

70 
g
->
rbuf
[g->

] = 0;

74 
	}
}

77 
	$a_check_cڡts
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

78 cڡ *
ru_r
, *
rbuf
, 
size_t
 *

) {

79 
rbufDesc
 
g
;

80 
t
;

82 
g
.
ed_ty
 = 0;

83 
g
.
ed_ru_r
 = 0;

84 
g
.
rbuf
 =rrbuf;

85 
g
.

 =rrlen ? *errlen : 0;

87 
t
 = 
ty_dest
->
codg_cڡts
.
	`g_cڡts
(

88 
ty_dest
, 
ru_r
, 
_a_i_cb
, &
g
);

89 if(
t
 =-1 && 

* = 
g
.errlen;

91  
t
;

92 
	}
}

	@der_encoder.c

5 
	~<a_.h
>

6 
	~<o.h
>

8 
ssize_t
 
d_wre_TL
(
b_v_g_t
 
g
, 
b_v_n_t
 
n
,

9 
a_p_csume_bys_f
 *
cb
, *
p_key
, 
cڡrued
);

14 
a_c_rv_t


15 
	$d_code
(cڡ 
a_TYPE_dest_t
 *
ty_dest
, cڡ *
ru_r
,

16 
a_p_csume_bys_f
 *
csume_bys
, *
p_key
) {

17 
	`ASN_DEBUG
("DERncoder invoked for %s",

18 
ty_dest
->
me
);

23  
ty_dest
->

->
	`d_cod
(

24 
ty_dest
, 
ru_r
,

25 0, 0, 
csume_bys
, 
p_key
);

26 
	}
}

31 
	sc_to_buf_g
 {

32 *
	mbufr
;

33 
size_t
 
	m
;

34 } 
	tc_to_buf_g
;

35 
	$code_to_bufr_cb
(cڡ *
bufr
, 
size_t
 
size
, *
key
) {

36 
c_to_buf_g
 *
g
 = (c_to_buf_g *)
key
;

38 if(
g
->

 < 
size
)

41 
	`memy
(
g
->
bufr
, bufr, 
size
);

42 
g
->
bufr
 = ((*rg->bufr+ 
size
;

43 
g
->

 -
size
;

46 
	}
}

51 
a_c_rv_t


52 
	$d_code_to_bufr
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

53 cڡ *
ru_r
, *
bufr
, 
size_t
 
bufr_size
) {

54 
c_to_buf_g
 
g
;

55 
a_c_rv_t
 
ec
;

57 
g
.
bufr
 = buffer;

58 
g
.

 = 
bufr_size
;

60 
ec
 = 
ty_dest
->

->
	`d_cod
(type_descriptor,

61 
ru_r
,

62 0, 0, 
code_to_bufr_cb
, &
g
);

63 if(
ec
.
coded
 != -1) {

64 
	`as
(
ec
.
coded
 =(
ssize_t
)(
bufr_size
 - 
g
.

));

67  
ec
;

68 
	}
}

74 
ssize_t


75 
	$d_wre_gs
(cڡ 
a_TYPE_dest_t
 *
sd
, 
size_t
 
ru_ngth
,

76 
g_mode
, 
ϡ_g_fm
,

77 
b_v_g_t
 
g
,

78 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

79 
	#ASN1_DER_MAX_TAGS_COUNT
 4

	)

80 
b_v_g_t


81 
gs_buf_sch
[
ASN1_DER_MAX_TAGS_COUNT
 * (
b_v_g_t
)];

82 
ssize_t
 
ns
[
ASN1_DER_MAX_TAGS_COUNT
 * (ssize_t)];

83 cڡ 
b_v_g_t
 *
gs
;

84 
gs_cou
;

85 
size_t
 
ovl_ngth
;

86 
i
;

88 
	`ASN_DEBUG
("Writingags (%s,m=%d,c=%d,ag=%s, mtc=%d)",

89 
sd
->
me
, 
g_mode
, sd->
gs_cou
,

90 
	`b_v_g_rg
(
g
),

91 
g_mode


92 ?(
sd
->
gs_cou
+1

93 -((
g_mode
 =-1&& 
sd
->
gs_cou
))

94 :
sd
->
gs_cou


97 if(
sd
->
gs_cou
 + 1 > 
ASN1_DER_MAX_TAGS_COUNT
) {

98 
	`ASN_DEBUG
("Syemim %d ogcou", 
ASN1_DER_MAX_TAGS_COUNT
);

102 if(
g_mode
) {

108 
ag_offt
;

109 
b_v_g_t
 *
gs_buf
 = 
gs_buf_sch
;

110 
gs_cou
 = 
sd
->tags_count

112 - ((
g_mode
 =-1&& 
sd
->
gs_cou
);

114 
gs_buf
[0] = 
g
;

115 
ag_offt
 = -1 + ((
g_mode
 =-1&& 
sd
->
gs_cou
);

116 
i
 = 1; i < 
gs_cou
; i++)

117 
gs_buf
[
i
] = 
sd
->
gs
[+ 
ag_offt
];

118 
gs
 = 
gs_buf
;

120 
gs
 = 
sd
->tags;

121 
gs_cou
 = 
sd
->tags_count;

125 if(
gs_cou
 == 0)

132 
ovl_ngth
 = 
ru_ngth
;

133 
i
 = 
gs_cou
 - 1; i >= 0; --i) {

134 
ns
[
i
] = 
	`d_wre_TL
(
gs
[i], 
ovl_ngth
, 0, 0, 0);

135 if(
ns
[
i
] == -1)  -1;

136 
ovl_ngth
 +
ns
[
i
];

137 
ns
[
i
] = 
ovl_ngth
 -ens[i];

140 if(!
cb
 
ovl_ngth
 - 
ru_ngth
;

142 
	`ASN_DEBUG
("Encodg %TL sequ (%dmts)", 
sd
->
me
,

143 
gs_cou
);

148 
i
 = 0; i < 
gs_cou
; i++) {

149 
ssize_t
 
n
;

150 
_cڡr
;

153 
_cڡr
 = (
ϡ_g_fm
 || 
i
 < (
gs_cou
 - 1));

155 
n
 = 
	`d_wre_TL
(
gs
[
i
], 
ns
[i], 
cb
, 
p_key
, 
_cڡr
);

156 if(
n
 == -1)  -1;

159  
ovl_ngth
 - 
ru_ngth
;

160 
	}
}

162 
ssize_t


163 
	$d_wre_TL
(
b_v_g_t
 
g
, 
b_v_n_t
 
n
,

164 
a_p_csume_bys_f
 *
cb
, *
p_key
,

165 
cڡrued
) {

166 
ut8_t
 
buf
[32];

167 
size_t
 
size
 = 0;

168 
buf_size
 = 
cb
?(
buf
):0;

169 
ssize_t
 
tmp
;

172 
tmp
 = 
	`b_v_g_rlize
(
g
, 
buf
, 
buf_size
);

173 if(
tmp
 =-1 ||m> (
ssize_t
)(
buf
))  -1;

174 
size
 +
tmp
;

177 
tmp
 = 
	`d_v_ngth_rlize
(
n
, 
buf
+
size
, 
buf_size
?buf_size-size:0);

178 if(
tmp
 == -1)  -1;

179 
size
 +
tmp
;

181 if(
size
 > (
buf
))

187 if(
cb
) {

188 if(
cڡrued
*
buf
 |= 0x20;

189 if(
	`cb
(
buf
, 
size
, 
p_key
) < 0)

193  
size
;

194 
	}
}

	@oer_decoder.c

5 
	~<a_.h
>

6 
	~<a_codecs_im.h
>

11 
a_dec_rv_t


12 
	$r_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

13 cڡ 
a_TYPE_dest_t
 *
ty_dest
, **
ru_r
,

14 cڡ *
r
, 
size_t
 
size
) {

15 
a_codec_x_t
 
s_codec_x
;

21 if(
t_codec_x
) {

22 if(
t_codec_x
->
max_ack_size
) {

23 
s_codec_x
 = *
t_codec_x
;

24 
t_codec_x
 = &
s_codec_x
;

28 
	`memt
(&
s_codec_x
, 0, (s_codec_ctx));

29 
s_codec_x
.
max_ack_size
 = 
ASN__DEFAULT_STACK_MAX
;

30 
t_codec_x
 = &
s_codec_x
;

36  
ty_dest
->

->
	`r_decod
(
t_codec_x
,ype_descriptor, 0,

37 
ru_r
,

38 
r
, 
size


40 
	}
}

46 
ssize_t


47 
	$r_ݒ_ty_sk
(cڡ *
bu
, 
size_t
 
size
) {

48 
size_t
 
n
 = 0;

49  
	`r_tch_ngth
(
bu
, 
size
, &
n
);

50 
	}
}

59 
ssize_t


60 
	$r_ݒ_ty_g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

61 cڡ 
a_TYPE_dest_s
 *
td
,

62 cڡ 
a_r_cڡts_t
 *
cڡts
, **
ru_r
,

63 cڡ *
bu
, 
size_t
 
size
) {

64 
a_dec_rv_t
 
dr
;

65 
size_t
 
cڏ_n
 = 0;

66 
ssize_t
 
n_n
;

67 
a_ru__mhod
 
dio_mhod
 =

68 (*
ru_r
? 
ASFM_FREE_UNDERLYING_AND_RESET
 : 
ASFM_FREE_EVERYTHING
;

71 
n_n
 = 
	`r_tch_ngth
(
bu
, 
size
, &
cڏ_n
);

72 if(
n_n
 <= 0) {

73  
n_n
;

80 if(
size
 - 
n_n
 < 
cڏ_n
) {

85 
dr
 = 
td
->

->
	`r_decod
(
t_codec_x
,d, 
cڡts
, 
ru_r
,

86 (cڡ 
ut8_t
 *)
bu
 + 
n_n
, 
cڏ_n
);

87 if(
dr
.
code
 =
RC_OK
) {

88  
n_n
 + 
cڏ_n
;

91 
td
->

->
	`_ru
d, *
ru_r
, 
dio_mhod
);

92 *
ru_r
 = 
NULL
;

95 
	}
}

98 
a_dec_rv_t


99 
	$r_decode_imive
(cڡ 
a_codec_x_t
 *
t_codec_x
,

100 cڡ 
a_TYPE_dest_t
 *
td
,

101 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

102 cڡ *
r
, 
size_t
 
size
) {

103 
ASN__PRIMITIVE_TYPE_t
 *

 = (ASN__PRIMITIVE_TYPE_*)*

;

104 
a_dec_rv_t
 
rv
 = {
RC_OK
, 0};

105 
size_t
 
exed_ngth
 = 0;

106 
ssize_t
 
n_n
;

108 ()
td
;

109 ()
t_codec_x
;

110 ()
cڡts
;

112 if(!

) {

113 

 = (
ASN__PRIMITIVE_TYPE_t
 *)(*

 = 
	`CALLOC
(

114 1, (
ASN__PRIMITIVE_TYPE_t
)));

115 if(!


ASN__DECODE_FAILED
;

124 
n_n
 = 
	`r_tch_ngth
(
r
, 
size
, &
exed_ngth
);

125 if(
n_n
 > 0) {

126 
rv
.
csumed
 = 
n_n
;

127 
r
 = (cڡ * + 
n_n
;

128 
size
 -
n_n
;

129 } if(
n_n
 == 0) {

130 
ASN__DECODE_STARVED
;

131 } if(
n_n
 < 0) {

132 
ASN__DECODE_FAILED
;

135 if(
size
 < 
exed_ngth
) {

136 
ASN__DECODE_STARVED
;

138 
ut8_t
 *
buf
 = 
	`MALLOC
(
exed_ngth
 + 1);

139 if(
buf
 =
NULL
) {

140 
ASN__DECODE_FAILED
;

142 
	`memy
(
buf
, 
r
, 
exed_ngth
);

143 
buf
[
exed_ngth
] = '\0';

145 
	`FREEMEM
(

->
buf
);

146 

->
buf
 = buf;

147 

->
size
 = 
exed_ngth
;

149 
rv
.
csumed
 +
exed_ngth
;

150  
rv
;

152 
	}
}

	@oer_encoder.c

5 
	~<a_.h
>

6 
	~<a_codecs_im.h
>

11 
a_c_rv_t


12 
	$r_code
(cڡ 
a_TYPE_dest_t
 *
ty_dest
, cڡ *
ru_r
,

13 
a_p_csume_bys_f
 *
csume_bys
, *
p_key
) {

14 
	`ASN_DEBUG
("OERncod invoked f %s", 
ty_dest
->
me
);

19  
ty_dest
->

->
	`r_cod
(

20 
ty_dest
, 0,

21 
ru_r
,

22 
csume_bys
, 
p_key
);

23 
	}
}

28 
	sc_to_buf_g
 {

29 *
	mbufr
;

30 
size_t
 
	m
;

31 } 
	tc_to_buf_g
;

33 
	$code_to_bufr_cb
(cڡ *
bufr
, 
size_t
 
size
, *
key
) {

34 
c_to_buf_g
 *
g
 = (c_to_buf_g *)
key
;

36 if(
g
->

 < 
size
)  -1;

38 
	`memy
(
g
->
bufr
, bufr, 
size
);

39 
g
->
bufr
 = ((*rg->bufr+ 
size
;

40 
g
->

 -
size
;

43 
	}
}

48 
a_c_rv_t


49 
	$r_code_to_bufr
(cڡ 
a_TYPE_dest_t
 *
ty_dest
,

50 cڡ 
a_r_cڡts_t
 *
cڡts
,

51 cڡ *
ru_r
,

52 *
bufr
,

53 
size_t
 
bufr_size


55 
c_to_buf_g
 
g
;

56 
a_c_rv_t
 
ec
;

58 
g
.
bufr
 = buffer;

59 
g
.

 = 
bufr_size
;

61 if(
ty_dest
->

->
r_cod
 =
NULL
) {

62 
ec
.
coded
 = -1;

63 
ec
.
ed_ty
 = 
ty_dest
;

64 
ec
.
ruu_r
 = 
ru_r
;

65 
	`ASN_DEBUG
("OERncoder isot defined for %s",

66 
ty_dest
->
me
);

68 
ec
 = 
ty_dest
->

->
	`r_cod
(

69 
ty_dest
, 
cڡts
,

70 
ru_r
,

71 
code_to_bufr_cb
, &
g
);

72 if(
ec
.
coded
 != -1) {

73 
	`as
(
ec
.
coded
 =(
ssize_t
)(
bufr_size
 - 
g
.

));

77  
ec
;

78 
	}
}

80 
a_c_rv_t


81 
	$r_code_imive
(cڡ 
a_TYPE_dest_t
 *
td
,

82 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

83 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

84 cڡ 
ASN__PRIMITIVE_TYPE_t
 *

 = (cڡ ASN__PRIMITIVE_TYPE_*)

;

85 
a_c_rv_t
 

 = {0, 0, 0};

86 
ssize_t
 
t
;

88 ()
cڡts
;

90 if(!


ASN__ENCODE_FAILED
;

92 
	`ASN_DEBUG
("Encodg %(%" 
ASN_PRI_SIZE
 " bys)", 
td
 ?d->
me
 : "", 

->
size
);

97 
t
 = 
	`r_rlize_ngth
(

->
size
, 
cb
, 
p_key
);

98 if(
t
 < 0) {

99 
ASN__ENCODE_FAILED
;

101 

.
coded
 +
t
;

103 

.
coded
 +

->
size
;

104 if(
	`cb
(

->
buf
, st->
size
, 
p_key
) < 0) {

105 
ASN__ENCODE_FAILED
;

107 
	`ASN__ENCODED_OK
(

);

109 
	}
}

112 
	$r__cou_bys
(cڡ *
bufr
, 
size_t
 
size
, *
bys_r
) {

113 
size_t
 *
bys
 = 
bys_r
;

114 ()
bufr
;

115 *
bys
 +
size
;

117 
	}
}

119 
ssize_t


120 
	$r_ݒ_ty_put
(cڡ 
a_TYPE_dest_t
 *
td
,

121 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

122 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

123 
size_t
 
rlized_by_cou
 = 0;

124 
a_c_rv_t
 

 = {0,0,0};

125 
ssize_t
 
n_n
;

127 

 = 
td
->

->
	`r_cod
d, 
cڡts
, 

, 
r__cou_bys
,

128 &
rlized_by_cou
);

129 if(

.
coded
 < 0)  -1;

130 
	`as
(
rlized_by_cou
 =(
size_t
)

.
coded
);

132 
n_n
 = 
	`r_rlize_ngth
(
rlized_by_cou
, 
cb
, 
p_key
);

133 if(
n_n
 == -1)  -1;

135 

 = 
td
->

->
	`r_cod
d, 
cڡts
, 

, 
cb
, 
p_key
);

136 if(

.
coded
 < 0)  -1;

137 
	`as
(
rlized_by_cou
 =(
size_t
)

.
coded
);

139  
n_n
 + 

.
coded
;

140 
	}
}

	@oer_support.c

6 
	~<a_syem.h
>

7 
	~<a_.h
>

9 
	~<r_sut.h
>

18 
ssize_t


19 
	$r_tch_ngth
(cڡ *
bu
, 
size_t
 
size
, size_*
n_r
) {

20 
ut8_t
 
f_by
;

21 
size_t
 
n_n
;

22 cڡ 
ut8_t
 *
b
;

23 cڡ 
ut8_t
 *
bd
;

24 
size_t
 
n
;

26 if(
size
 == 0) {

27 *
n_r
 = 0;

31 
f_by
 = *(cڡ 
ut8_t
 *)
bu
;

32 if((
f_by
 & 0x80) == 0) {

33 *
n_r
 = 
f_by
;

37 
n_n
 = (
f_by
 & 0x7f);

38 if((1 + 
n_n
> 
size
) {

39 *
n_r
 = 0;

43 
b
 = (cڡ 
ut8_t
 *)
bu
 + 1;

44 
bd
 = 
b
 + 
n_n
;

46 ; 
b
 < 
bd
 && *b == 0; b++) {

50 if((
bd
 - 
b
> (
ssize_t
)(
size_t
)) {

52 *
n_r
 = 0;

56 
n
 = 0; 
b
 < 
bd
; b++) {

57 
n
 = (<< 8+ *
b
;

60 if(
n
 > 
RSIZE_MAX
) {

61 *
n_r
 = 0;

65 *
n_r
 = 
n
;

66 
	`as
(
n_n
 + 1 =(
size_t
)(
bd
 - (cڡ 
ut8_t
 *)
bu
));

67  
n_n
 + 1;

68 
	}
}

75 
ssize_t


76 
	$r_rlize_ngth
(
size_t
 
ngth
, 
a_p_csume_bys_f
 *
cb
,

77 *
p_key
) {

78 
ut8_t
 
sch
[1 + (
ngth
)];

79 
ut8_t
 *

 = 
sch
;

80 
leEndn
 = 1;

81 cڡ 
ut8_t
 *
pt
;

82 cڡ 
ut8_t
 *
nd
;

83 cڡ 
ut8_t
 *
p
;

84 
add
;

86 if(
ngth
 <= 127) {

87 
ut8_t
 
b
 = 
ngth
;

88 if(
	`cb
(&
b
, 1, 
p_key
) < 0) {

94 if(*(*)&
leEndn
) {

95 
pt
 = (cڡ 
ut8_t
 *)&
ngth
 + (length) - 1;

96 
nd
 = (cڡ 
ut8_t
 *)&
ngth
;

97 
add
 = -1;

99 
pt
 = (cڡ 
ut8_t
 *)&
ngth
;

100 
nd
 = 
pt
 + (
ngth
);

101 
add
 = 1;

104 
p
 = 
pt
; !
nd
; +
add
) {

106 if(*
p
) ;

109 

 = 
sch
 + 1; ; 
p
 +
add
) {

110 *

++ = *
p
;

111 if(
p
 =
nd
) ;

113 
	`as
((

 - 
sch
) - 1 <= 0x7f);

114 
sch
[0] = 0x80 + ((

 - scratch) - 1);

116 if(
	`cb
(
sch
, 

 - sch, 
p_key
) < 0) {

120  

 - 
sch
;

121 
	}
}

	@per_decoder.c

1 
	~<a_iti.h
>

2 
	~<a_.h
>

3 
	~<r_decod.h
>

10 
a_dec_rv_t


11 
	$ur_decode_come
(cڡ 
a_codec_x_t
 *
t_codec_x
,

12 cڡ 
a_TYPE_dest_t
 *
td
, **

,

13 cڡ *
bufr
, 
size_t
 
size
) {

14 
a_dec_rv_t
 
rv
;

16 
rv
 = 
	`ur_decode
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
, 0, 0);

17 if(
rv
.
csumed
) {

22 
rv
.
csumed
 += 7;

23 
rv
.
csumed
 >>= 3;

24 } if(
rv
.
code
 =
RC_OK
) {

25 if(
size
) {

26 if(((cڡ 
ut8_t
 *)
bufr
)[0] == 0) {

27 
rv
.
csumed
 = 1;

29 
	`ASN_DEBUG
("Expecting single zeroed byte");

30 
rv
.
code
 = 
RC_FAIL
;

34 
rv
.
code
 = 
RC_WMORE
;

38  
rv
;

39 
	}
}

41 
a_dec_rv_t


42 
	$ur_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

43 cڡ 
a_TYPE_dest_t
 *
td
, **

, cڡ *
bufr
,

44 
size_t
 
size
, 
sk_bs
, 
unud_bs
) {

45 
a_codec_x_t
 
s_codec_x
;

46 
a_dec_rv_t
 
rv
;

47 
a_r_da_t
 
pd
;

49 if(
sk_bs
 < 0 || skip_bits > 7

50 || 
unud_bs
 < 0 || unused_bits > 7

51 || (
unud_bs
 > 0 && !
size
))

52 
ASN__DECODE_FAILED
;

58 if(
t_codec_x
) {

59 if(
t_codec_x
->
max_ack_size
) {

60 
s_codec_x
 = *
t_codec_x
;

61 
t_codec_x
 = &
s_codec_x
;

65 
	`memt
(&
s_codec_x
, 0, (s_codec_ctx));

66 
s_codec_x
.
max_ack_size
 = 
ASN__DEFAULT_STACK_MAX
;

67 
t_codec_x
 = &
s_codec_x
;

71 
	`memt
(&
pd
, 0, (pd));

72 
pd
.
bufr
 = (cڡ 
ut8_t
 *)buffer;

73 
pd
.
nboff
 = 
sk_bs
;

74 
pd
.
nbs
 = 8 * 
size
 - 
unud_bs
;

75 if(
pd
.
nboff
 >d.
nbs
)

76 
ASN__DECODE_FAILED
;

81 if(!
td
->

->
ur_decod
)

82 
ASN__DECODE_FAILED
;

83 
rv
 = 
td
->

->
	`ur_decod
(
t_codec_x
,d, 0, 

, &
pd
);

84 if(
rv
.
code
 =
RC_OK
) {

86 
rv
.
csumed
 = ((
pd
.
bufr
 - (cڡ 
ut8_t
 *)buffer) << 3)

87 + 
pd
.
nboff
 - 
sk_bs
;

88 
	`ASN_DEBUG
("PER decoding consumed %ld, counted %ld",

89 ()
rv
.
csumed
, ()
pd
.
moved
);

90 
	`as
(
rv
.
csumed
 =
pd
.
moved
);

93 
rv
.
csumed
 = 0;

95  
rv
;

96 
	}
}

98 
a_dec_rv_t


99 
	$_decode_come
(cڡ 
a_codec_x_t
 *
t_codec_x
,

100 cڡ 
a_TYPE_dest_t
 *
td
, **

,

101 cڡ *
bufr
, 
size_t
 
size
) {

102 
a_dec_rv_t
 
rv
;

104 
rv
 = 
	`_decode
(
t_codec_x
, 
td
, 

, 
bufr
, 
size
, 0, 0);

105 if(
rv
.
csumed
) {

110 
rv
.
csumed
 += 7;

111 
rv
.
csumed
 >>= 3;

112 } if(
rv
.
code
 =
RC_OK
) {

113 if(
size
) {

114 if(((cڡ 
ut8_t
 *)
bufr
)[0] == 0) {

115 
rv
.
csumed
 = 1;

117 
	`ASN_DEBUG
("Expecting single zeroed byte");

118 
rv
.
code
 = 
RC_FAIL
;

122 
rv
.
code
 = 
RC_WMORE
;

126  
rv
;

127 
	}
}

129 
a_dec_rv_t


130 
	$_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

131 cڡ 
a_TYPE_dest_t
 *
td
, **

, cڡ *
bufr
,

132 
size_t
 
size
, 
sk_bs
, 
unud_bs
) {

133 
a_codec_x_t
 
s_codec_x
;

134 
a_dec_rv_t
 
rv
;

135 
a_r_da_t
 
pd
;

137 if(
sk_bs
 < 0 || skip_bits > 7

138 || 
unud_bs
 < 0 || unused_bits > 7

139 || (
unud_bs
 > 0 && !
size
))

140 
ASN__DECODE_FAILED
;

146 if(
t_codec_x
) {

147 if(
t_codec_x
->
max_ack_size
) {

148 
s_codec_x
 = *
t_codec_x
;

149 
t_codec_x
 = &
s_codec_x
;

153 
	`memt
(&
s_codec_x
, 0, (s_codec_ctx));

154 
s_codec_x
.
max_ack_size
 = 
ASN__DEFAULT_STACK_MAX
;

155 
t_codec_x
 = &
s_codec_x
;

159 
	`memt
(&
pd
, 0, (pd));

160 
pd
.
bufr
 = (cڡ 
ut8_t
 *)buffer;

161 
pd
.
nboff
 = 
sk_bs
;

162 
pd
.
nbs
 = 8 * 
size
 - 
unud_bs
;

163 if(
pd
.
nboff
 >d.
nbs
)

164 
ASN__DECODE_FAILED
;

169 if(!
td
->

->
_decod
)

170 
ASN__DECODE_FAILED
;

171 
rv
 = 
td
->

->
	`_decod
(
t_codec_x
,d, 0, 

, &
pd
);

172 if(
rv
.
code
 =
RC_OK
) {

174 
rv
.
csumed
 = ((
pd
.
bufr
 - (cڡ 
ut8_t
 *)buffer) << 3)

175 + 
pd
.
nboff
 - 
sk_bs
;

176 
	`ASN_DEBUG
("PER decoding consumed %zu, counted %zu",

177 
rv
.
csumed
, 
pd
.
moved
);

178 
	`as
(
rv
.
csumed
 =
pd
.
moved
);

181 
rv
.
csumed
 = 0;

183  
rv
;

184 
	}
}

	@per_encoder.c

1 
	~<a_iti.h
>

2 
	~<a_.h
>

3 
	~<r_cod.h
>

5 
_ur_code_ush_ou
(
a_r_ou_t
 *
po
);

8 
	$igne_ouut
(cڡ *
da
, 
size_t
 
size
, *
p_key
) {

9 ()
da
;

10 ()
size
;

11 ()
p_key
;

13 
	}
}

15 
a_c_rv_t


16 
	$ur_code
(cڡ 
a_TYPE_dest_t
 *
td
,

17 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

18 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

19 
a_r_ou_t
 
po
;

20 
a_c_rv_t
 

 = {0,0,0};

25 if(!
td
 || !td->

->
ur_cod
)

26 
ASN__ENCODE_FAILED
;

28 
po
.
bufr
 =o.
tmpa
;

29 
po
.
nboff
 = 0;

30 
po
.
nbs
 = 8 * o.
tmpa
);

31 
po
.
ouut
 = 
cb
 ? cb : 
igne_ouut
;

32 
po
.
_key
 = 
p_key
;

33 
po
.
ushed_bys
 = 0;

35 

 = 
td
->

->
	`ur_cod
d, 
cڡts
, 

, &
po
);

36 if(

.
coded
 != -1) {

37 
size_t
 
bs_to_ush
;

39 
bs_to_ush
 = ((
po
.
bufr
 -o.
tmpa
<< 3+o.
nboff
;

42 

.
coded
 = (
po
.
ushed_bys
 << 3+ 
bs_to_ush
;

44 if(
	`_ur_code_ush_ou
(&
po
)
ASN__ENCODE_FAILED
;

47  

;

48 
	}
}

53 
	sc_to_buf_g
 {

54 *
	mbufr
;

55 
size_t
 
	m
;

56 } 
	tc_to_buf_g
;

57 
	$code_to_bufr_cb
(cڡ *
bufr
, 
size_t
 
size
, *
key
) {

58 
c_to_buf_g
 *
g
 = (c_to_buf_g *)
key
;

60 if(
g
->

 < 
size
)

63 
	`memy
(
g
->
bufr
, bufr, 
size
);

64 
g
->
bufr
 = ((*rg->bufr+ 
size
;

65 
g
->

 -
size
;

68 
	}
}

70 
a_c_rv_t


71 
	$ur_code_to_bufr
(cڡ 
a_TYPE_dest_t
 *
td
,

72 cڡ 
a_r_cڡts_t
 *
cڡts
,

73 cڡ *

, *
bufr
, 
size_t
 
bufr_size
) {

74 
c_to_buf_g
 
key
;

76 
key
.
bufr
 = buffer;

77 
key
.

 = 
bufr_size
;

79 if(
td

	`ASN_DEBUG
("Encodg \"%s\" usg UNALIGNED PER",d->
me
);

81  
	`ur_code
(
td
, 
cڡts
, 

, 
code_to_bufr_cb
, &
key
);

82 
	}
}

84 
	sc_dyn_g
 {

85 *
	mbufr
;

86 
size_t
 
	mngth
;

87 
size_t
 
	mlod
;

88 } 
	tc_dyn_g
;

90 
	$code_dyn_cb
(cڡ *
bufr
, 
size_t
 
size
, *
key
) {

91 
c_dyn_g
 *
g
 = 
key
;

92 if(
g
->
ngth
 + 
size
 >g->
lod
) {

93 
size_t
 
w_size
 = 
g
->
lod
 ?rg->allocated : 8;

94 *
p
;

97 
w_size
 <<= 2;

98 } 
g
->
ngth
 + 
size
 >
w_size
);

100 
p
 = 
	`REALLOC
(
g
->
bufr
, 
w_size
);

101 if(!
p
) {

102 
	`FREEMEM
(
g
->
bufr
);

103 
	`memt
(
g
, 0, (*arg));

106 
g
->
bufr
 = 
p
;

107 
g
->
lod
 = 
w_size
;

109 
	`memy
(((*)
g
->
bufr
+rg->
ngth
, bufr, 
size
);

110 
g
->
ngth
 +
size
;

112 
	}
}

113 
ssize_t


114 
	$ur_code_to_w_bufr
(cڡ 
a_TYPE_dest_t
 *
td
,

115 cڡ 
a_r_cڡts_t
 *
cڡts
,

116 cڡ *

, **
bufr_r
) {

117 
a_c_rv_t
 

 = {0,0,0};

118 
c_dyn_g
 
key
;

120 
	`memt
(&
key
, 0, (key));

122 

 = 
	`ur_code
(
td
, 
cڡts
, 

, 
code_dyn_cb
, &
key
);

123 

.
coded
) {

125 
	`FREEMEM
(
key
.
bufr
);

128 
	`FREEMEM
(
key
.
bufr
);

129 
key
.
bufr
 = 
	`MALLOC
(1);

130 if(
key
.
bufr
) {

131 *(*)
key
.
bufr
 = '\0';

132 *
bufr_r
 = 
key
.
bufr
;

138 *
bufr_r
 = 
key
.
bufr
;

139 
	`ASN_DEBUG
("Comcoded i%ld bs", ()

.
coded
);

140  ((

.
coded
 + 7) >> 3);

142 
	}
}

150 
	$_ur_code_ush_ou
(
a_r_ou_t
 *
po
) {

151 
ut8_t
 *
buf
;

153 if(
po
->
nboff
 =0 &&o->
bufr
 =po->
tmpa
)

156 
buf
 = 
po
->
bufr
 + (po->
nboff
 >> 3);

158 if(
po
->
nboff
 & 0x07) {

159 
buf
[0] &0xf<< (8 - (
po
->
nboff
 & 0x07));

160 
buf
++;

163  
po
->
	`ouut
o->
tmpa
, 
buf
 -o->tmpa,o->
_key
);

164 
	}
}

166 
a_c_rv_t


167 
	$_code_to_bufr
(cڡ 
a_TYPE_dest_t
 *
td
,

168 cڡ 
a_r_cڡts_t
 *
cڡts
,

169 cڡ *

, *
bufr
, 
size_t
 
bufr_size
) {

170 
c_to_buf_g
 
key
;

172 
key
.
bufr
 = buffer;

173 
key
.

 = 
bufr_size
;

175 if(
td

	`ASN_DEBUG
("Encodg \"%s\" usg ALIGNED PER",d->
me
);

177  
	`_code
(
td
, 
cڡts
, 

, 
code_to_bufr_cb
, &
key
);

178 
	}
}

180 
ssize_t


181 
	$_code_to_w_bufr
(cڡ 
a_TYPE_dest_t
 *
td
,

182 cڡ 
a_r_cڡts_t
 *
cڡts
,

183 cڡ *

, **
bufr_r
) {

184 
a_c_rv_t
 

 = {0,0,0};

185 
c_dyn_g
 
key
;

187 
	`memt
(&
key
, 0, (key));

189 

 = 
	`_code
(
td
, 
cڡts
, 

, 
code_dyn_cb
, &
key
);

190 

.
coded
) {

192 
	`FREEMEM
(
key
.
bufr
);

195 
	`FREEMEM
(
key
.
bufr
);

196 
key
.
bufr
 = 
	`MALLOC
(1);

197 if(
key
.
bufr
) {

198 *(*)
key
.
bufr
 = '\0';

199 *
bufr_r
 = 
key
.
bufr
;

205 *
bufr_r
 = 
key
.
bufr
;

206 
	`ASN_DEBUG
("Comcoded i%ld bs", ()

.
coded
);

207  ((

.
coded
 + 7) >> 3);

209 
	}
}

212 
	$__code_ush_ou
(
a_r_ou_t
 *
po
) {

213 
ut8_t
 *
buf
;

215 if(
po
->
nboff
 =0 &&o->
bufr
 =po->
tmpa
)

218 
buf
 = 
po
->
bufr
 + (po->
nboff
 >> 3);

220 if(
po
->
nboff
 & 0x07) {

221 
buf
[0] &0xf<< (8 - (
po
->
nboff
 & 0x07));

222 
buf
++;

225 i(
po
->
ouut
) {

226  
po
->
	`ouut
o->
tmpa
, 
buf
 -o->tmpa,o->
_key
);

229 
	}
}

231 
a_c_rv_t


232 
	$_code
(cڡ 
a_TYPE_dest_t
 *
td
,

233 cڡ 
a_r_cڡts_t
 *
cڡts
,

234 cڡ *

, 
a_p_csume_bys_f
 *
cb
, *
p_key
) {

235 
a_r_ou_t
 
po
;

236 
a_c_rv_t
 

 = {0,0,0};

241 if(!
td
 || !td->

->
_cod
)

242 
ASN__ENCODE_FAILED
;

244 
po
.
bufr
 =o.
tmpa
;

245 
po
.
nboff
 = 0;

246 
po
.
nbs
 = 8 * o.
tmpa
);

247 
po
.
ouut
 = 
cb
;

248 
po
.
_key
 = 
p_key
;

249 
po
.
ushed_bys
 = 0;

251 

 = 
td
->

->
	`_cod
d, 
cڡts
, 

, &
po
);

252 if(

.
coded
 != -1) {

253 
size_t
 
bs_to_ush
;

255 
bs_to_ush
 = ((
po
.
bufr
 -o.
tmpa
<< 3+o.
nboff
;

258 

.
coded
 = (
po
.
ushed_bys
 << 3+ 
bs_to_ush
;

260 if(
	`__code_ush_ou
(&
po
))

261 
ASN__ENCODE_FAILED
;

264  

;

265 
	}
}

	@per_opentype.c

5 
	~<a_.h
>

6 
	~<r_sut.h
>

7 
	~<cڡr_TYPE.h
>

8 
	~<r_ݒty.h
>

10 
	sur_ug_key
 {

11 
a_r_da_t
 
	mdpd
;

12 
size_t
 
	munaimed
;

13 
size_t
 
	m_moved
;

14 
	m
;

15 } 
	tur_ug_key
;

17 
ur_ug_fl
(
a_r_da_t
 *
pd
);

18 
r_sk_bs
(
a_r_da_t
 *
pd
, 
sk_nbs
);

19 
a_dec_rv_t
 
ur_s_suck
(cڡ 
a_codec_x_t
 *,

20 cڡ 
a_TYPE_dest_t
 *
td
,

21 cڡ 
a_r_cڡts_t
 *
cڡts
,

22 **

, 
a_r_da_t
 *
pd
);

29 
	$ur_ݒ_ty_put
(cڡ 
a_TYPE_dest_t
 *
td
,

30 cڡ 
a_r_cڡts_t
 *
cڡts
, cڡ *

,

31 
a_r_ou_t
 *
po
) {

32 *
buf
;

33 *
br
;

34 
ssize_t
 
size
;

36 
	`ASN_DEBUG
("Otyu%...", 
td
->
me
);

38 
size
 = 
	`ur_code_to_w_bufr
(
td
, 
cڡts
, 

, &
buf
);

39 if(
size
 <= 0)  -1;

41 
	`ASN_DEBUG
("Otyu%ongth %" 
ASN_PRI_SSIZE
 " + ovhd (1by?)", 
td
->
me
,

42 
size
);

44 
br
 = 
buf
;

46 
ed_eom
 = 0;

47 
ssize_t
 
may_ve
 = 
	`ur_put_ngth
(
po
, 
size
, &
ed_eom
);

48 
	`ASN_DEBUG
("Pndggth %" 
ASN_PRI_SSIZE


49 "%dowgاv%" 
ASN_PRI_SSIZE
,

50 
size
, 
td
->
me
, 
may_ve
);

51 if(
may_ve
 < 0) ;

52 if(
	`r_put_my_bs
(
po
, 
br
, 
may_ve
 * 8)) ;

53 
br
 = (*)b+ 
may_ve
;

54 
size
 -
may_ve
;

55 if(
ed_eom
 && 
	`ur_put_ngth
(
po
, 0, 0)) {

56 
	`FREEMEM
(
buf
);

59 } 
size
);

61 
	`FREEMEM
(
buf
);

62 if(
size
)  -1;

65 
	}
}

67 
a_dec_rv_t


68 
	$ur_ݒ_ty_g_sime
(cڡ 
a_codec_x_t
 *
x
,

69 cڡ 
a_TYPE_dest_t
 *
td
,

70 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

71 
a_r_da_t
 *
pd
) {

72 
a_dec_rv_t
 
rv
;

73 
ssize_t
 
chunk_bys
;

74 

;

75 
ut8_t
 *
buf
 = 0;

76 
size_t
 
bufL
 = 0;

77 
size_t
 
bufSize
 = 0;

78 
a_r_da_t
 
d
;

79 
size_t
 
ddg
;

81 
	`ASN__STACK_OVERFLOW_CHECK
(
x
);

83 
	`ASN_DEBUG
("Gtg oty %s...", 
td
->
me
);

86 
chunk_bys
 = 
	`ur_g_ngth
(
pd
, -1, 0, &

);

87 if(
chunk_bys
 < 0) {

88 
	`FREEMEM
(
buf
);

89 
ASN__DECODE_STARVED
;

91 if(
bufL
 + 
chunk_bys
 > 
bufSize
) {

92 *
r
;

93 
bufSize
 = 
chunk_bys
 + (bufSize << 2);

94 
r
 = 
	`REALLOC
(
buf
, 
bufSize
);

95 if(!
r
) {

96 
	`FREEMEM
(
buf
);

97 
ASN__DECODE_FAILED
;

99 
buf
 = 
r
;

101 if(
	`r_g_my_bs
(
pd
, 
buf
 + 
bufL
, 0, 
chunk_bys
 << 3)) {

102 
	`FREEMEM
(
buf
);

103 
ASN__DECODE_STARVED
;

105 
bufL
 +
chunk_bys
;

106 } 

);

108 
	`ASN_DEBUG
("Gtg oty %coded i%ld bys", 
td
->
me
,

109 ()
bufL
);

111 
	`memt
(&
d
, 0, (spd));

112 
d
.
bufr
 = 
buf
;

113 
d
.
nbs
 = 
bufL
 << 3;

115 
	`ASN_DEBUG_INDENT_ADD
(+4);

116 
rv
 = 
td
->

->
	`ur_decod
(
x
,d, 
cڡts
, 

, &
d
);

117 
	`ASN_DEBUG_INDENT_ADD
(-4);

119 if(
rv
.
code
 =
RC_OK
) {

121 
ddg
 = 
d
.
nbs
 - spd.
nboff
;

122 i(((
ddg
 > 0 &&adding < 8) ||

124 (
d
.
nboff
 =0 && spd.
nbs
 =8 && spd.
bufr
 =
buf
)) &&

125 
	`r_g_w_bs
(&
d
, 
ddg
) == 0) {

127 
	`FREEMEM
(
buf
);

128  
rv
;

130 
	`FREEMEM
(
buf
);

131 if(
ddg
 >= 8) {

132 
	`ASN_DEBUG
("Torgddg %d iݒy", ()
ddg
);

133 
ASN__DECODE_FAILED
;

135 
	`ASN_DEBUG
("Noadding");

138 
	`FREEMEM
(
buf
);

140 
rv
.
code
 = 
RC_FAIL
;

143  
rv
;

144 
	}
}

146 
a_dec_rv_t
 
CC_NOTUSED


147 
	$ur_ݒ_ty_g_comex
(cڡ 
a_codec_x_t
 *
x
,

148 cڡ 
a_TYPE_dest_t
 *
td
,

149 
a_r_cڡts_t
 *
cڡts
, **

,

150 
a_r_da_t
 *
pd
) {

151 
ur_ug_key
 
g
;

152 
a_dec_rv_t
 
rv
;

153 
ssize_t
 
ddg
;

155 
	`ASN__STACK_OVERFLOW_CHECK
(
x
);

157 
	`ASN_DEBUG
("Gtg oty %om %s", 
td
->
me
,

158 
	`a_b_da_rg
(
pd
));

159 
g
.
dpd
 = *
pd
;

160 
g
.
unaimed
 = 0;

161 
g
.
_moved
 = 0;

162 
g
.

 = 1;

163 
pd
->
fl
 = 
ur_ug_fl
;

164 
pd
->
fl_key
 = &
g
;

165 
pd
->
nbs
 =d->
nboff
;

166 
pd
->
moved
 = 0;

168 
	`ASN_DEBUG_INDENT_ADD
(+4);

169 
rv
 = 
td
->

->
	`ur_decod
(
x
,d, 
cڡts
, 

, 
pd
);

170 
	`ASN_DEBUG_INDENT_ADD
(-4);

172 
	#UPDRESTOREPD
 do { \

174 
pd
->
nbs
 = 
g
.
dpd
.nb- (pd->
moved
 -rg.
_moved
); \

175 
pd
->
moved
 = 
g
.
dpd
.moved + (pd->moved -rg.
_moved
); \

176 
pd
->
fl
 = 
g
.
dpd
.refill; \

177 
pd
->
fl_key
 = 
g
.
dpd
.refill_key; \

178 } 0)

	)

180 if(
rv
.
code
 !
RC_OK
) {

181 
UPDRESTOREPD
;

182  
rv
;

185 
	`ASN_DEBUG
("OnTy %pd%d%unaimed=%d,t=%d", 
td
->
me
,

186 
	`a_b_da_rg
(
pd
),

187 
	`a_b_da_rg
(&
g
.
dpd
),

188 ()
g
.
unaimed
, (rg.

);

190 
ddg
 = 
pd
->
moved
 % 8;

191 if(
ddg
) {

192 
t32_t
 
pvue
;

193 if(
ddg
 > 7) {

194 
	`ASN_DEBUG
("Tooargeadding %d in openype",

195 ()
ddg
);

196 
rv
.
code
 = 
RC_FAIL
;

197 
UPDRESTOREPD
;

198  
rv
;

200 
ddg
 = 8 -adding;

201 
	`ASN_DEBUG
("Gtgaddg o%d bs", ()
ddg
);

202 
pvue
 = 
	`r_g_w_bs
(
pd
, 
ddg
);

203 
pvue
) {

205 
	`ASN_DEBUG
("Padding skip failed");

206 
UPDRESTOREPD
;

207 
ASN__DECODE_STARVED
;

210 
	`ASN_DEBUG
("Non-blankadding (%d bits 0x%02x)",

211 ()
ddg
, ()
pvue
);

212 
UPDRESTOREPD
;

213 
ASN__DECODE_FAILED
;

216 if(
pd
->
nboff
 !pd->
nbs
) {

217 
	`ASN_DEBUG
("Oty %ovhdd%d%s", 
td
->
me
,

218 
	`a_b_da_rg
(
pd
),_b_da_rg(&
g
.
dpd
));

220 
UPDRESTOREPD
;

221 
ASN__DECODE_FAILED
;

223 
g
.
unaimed
 +
pd
->
nbs
 -d->
nboff
;

228 
UPDRESTOREPD
;

231 if(
g
.
unaimed
) {

232 
	`ASN_DEBUG
("Gtg unaimed %d", ()
g
.
unaimed
);

233 
	`r_sk_bs
(
pd
, 
g
.
unaimed
)) {

235 
	`ASN_DEBUG
("Cim o%d faed", ()
g
.
unaimed
);

236 
ASN__DECODE_STARVED
;

238 
	`ASN_DEBUG
("G cim o%d", ()
g
.
unaimed
);

242 
	`ASN_DEBUG
("Non-blank unconsumedadding");

243 
ASN__DECODE_FAILED
;

245 
g
.
unaimed
 = 0;

248 if(
g
.

) {

249 
	`ASN_DEBUG
("Not consumedhe wholehing");

250 
rv
.
code
 = 
RC_FAIL
;

251  
rv
;

254  
rv
;

255 
	}
}

258 
a_dec_rv_t


259 
	$ur_ݒ_ty_g
(cڡ 
a_codec_x_t
 *
x
, cڡ 
a_TYPE_dest_t
 *
td
,

260 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

261 
a_r_da_t
 *
pd
) {

262  
	`ur_ݒ_ty_g_sime
(
x
, 
td
, 
cڡts
, 

, 
pd
);

263 
	}
}

266 
	$ur_ݒ_ty_sk
(cڡ 
a_codec_x_t
 *
x
, 
a_r_da_t
 *
pd
) {

267 
a_TYPE_dest_t
 
s_td
;

268 
a_TYPE_ݔi_t
 
s_
;

269 
a_dec_rv_t
 
rv
;

271 
s_td
.
me
 = "<unknownxtension>";

272 
s_td
.

 = &
s_
;

273 
s_
.
ur_decod
 = 
ur_s_suck
;

275 
rv
 = 
	`ur_ݒ_ty_g
(
x
, &
s_td
, 0, 0, 
pd
);

276 if(
rv
.
code
 !
RC_OK
)

280 
	}
}

286 
a_dec_rv_t


287 
	$ur_s_suck
(cڡ 
a_codec_x_t
 *
x
, cڡ 
a_TYPE_dest_t
 *
td
,

288 cڡ 
a_r_cڡts_t
 *
cڡts
, **

,

289 
a_r_da_t
 *
pd
) {

290 
a_dec_rv_t
 
rv
;

292 ()
x
;

293 ()
td
;

294 ()
cڡts
;

295 ()

;

297 
	`r_g_w_bs
(
pd
, 1) >= 0);

299 
rv
.
code
 = 
RC_OK
;

300 
rv
.
csumed
 = 
pd
->
moved
;

302  
rv
;

303 
	}
}

306 
	$ur_ug_fl
(
a_r_da_t
 *
pd
) {

307 
ur_ug_key
 *
g
 = 
pd
->
fl_key
;

308 
ssize_t
 
xt_chunk_bys
, 
xt_chunk_bs
;

309 
ssize_t
 
ava
;

311 
a_r_da_t
 *
dpd
 = &
g
->oldpd;

313 
	`ASN_DEBUG
("REFILLINGd->moved=%ld, oldpd->moved=%ld",

314 ()
pd
->
moved
, ()
dpd
->moved);

317 
dpd
->
bufr
 = 
pd
->buffer;

318 
dpd
->
nboff
 = 
pd
->nboff;

319 
dpd
->
nbs
 -
pd
->
moved
 - 
g
->
_moved
;

320 
dpd
->
moved
 +
pd
->moved - 
g
->
_moved
;

321 
g
->
_moved
 = 
pd
->
moved
;

323 if(
g
->
unaimed
) {

325 if(
	`r_g_w_bs
(
dpd
, 1))

327 if(
dpd
->
nboff
 == 0) {

328 
	`as
(0);

331 
pd
->
bufr
 = 
dpd
->buffer;

332 
pd
->
nboff
 = 
dpd
->nboff - 1;

333 
pd
->
nbs
 = 
dpd
->nbits;

334 
	`ASN_DEBUG
("UNCLAIMED <-eturn from (pd->moved=%ld)",

335 ()
pd
->
moved
);

339 if(!
g
->

) {

340 
	`ASN_DEBUG
("Want more butefill doesn't have it");

344 
xt_chunk_bys
 = 
	`ur_g_ngth
(
dpd
, -1, 0, &
g
->

);

345 
	`ASN_DEBUG
("Openype LENGTH %ld bytest off %ld,epeat %ld",

346 ()
xt_chunk_bys
, ()
dpd
->
moved
, ()
g
->

);

347 if(
xt_chunk_bys
 < 0)  -1;

348 if(
xt_chunk_bys
 == 0) {

349 
pd
->
fl
 = 0;

350 
	`as
(!
g
->

);

352 
xt_chunk_bs
 = 
xt_chunk_bys
 << 3;

353 
ava
 = 
dpd
->
nbs
 - oldpd->
nboff
;

354 if(
ava
 >
xt_chunk_bs
) {

355 
pd
->
nbs
 = 
dpd
->
nboff
 + 
xt_chunk_bs
;

356 
g
->
unaimed
 = 0;

357 
	`ASN_DEBUG
("!+Parent frame %ld bits,lloting %ld [%ld..%ld] (%ld)",

358 ()
xt_chunk_bs
, ()
dpd
->
moved
,

359 ()
dpd
->
nboff
, ()dpd->
nbs
,

360 ()(
dpd
->
nbs
 - oldpd->
nboff
));

362 
pd
->
nbs
 = 
dpd
->nbits;

363 
g
->
unaimed
 = 
xt_chunk_bs
 - 
ava
;

364 
	`ASN_DEBUG
("!-Parent frame %ld,equire %ld, will claim %ld",

365 ()
ava
, ()
xt_chunk_bs
,

366 ()
g
->
unaimed
);

368 
pd
->
bufr
 = 
dpd
->buffer;

369 
pd
->
nboff
 = 
dpd
->nboff;

370 
	`ASN_DEBUG
("Refilledd%s old%s",

371 
	`a_b_da_rg
(
pd
),_b_da_rg(
dpd
));

373 
	}
}

376 
	$r_sk_bs
(
a_r_da_t
 *
pd
, 
sk_nbs
) {

377 
hasNZoBs
 = 0;

378 
sk_nbs
 > 0) {

379 
sk
;

382 if(
sk_nbs
 < 24)

383 
sk
 = 
sk_nbs
;

385 
sk
 = 24;

386 
sk_nbs
 -
sk
;

388 
	`r_g_w_bs
(
pd
, 
sk
)) {

391 : 
hasNZoBs
 = 1; ;

394  
hasNZoBs
;

395 
	}
}

397 
a_dec_rv_t


398 
	$_ݒ_ty_g_sime
(cڡ 
a_codec_x_t
 *
x
,

399 cڡ 
a_TYPE_dest_t
 *
td
,

400 cڡ 
a_r_cڡts_t
 *
cڡts
, **

, 
a_r_da_t
 *
pd
) {

401 
a_dec_rv_t
 
rv
;

402 
ssize_t
 
chunk_bys
;

403 

;

404 
ut8_t
 *
buf
 = 0;

405 
size_t
 
bufL
 = 0;

406 
size_t
 
bufSize
 = 0;

407 
a_r_da_t
 
d
;

408 
size_t
 
ddg
;

410 
	`ASN__STACK_OVERFLOW_CHECK
(
x
);

412 
	`ASN_DEBUG
("Gtg oty %s...", 
td
->
me
);

415 
chunk_bys
 = 
	`_g_ngth
(
pd
, -1, -1, &

);

416 if(
chunk_bys
 < 0) {

417 
	`FREEMEM
(
buf
);

418 
ASN__DECODE_STARVED
;

420 if(
bufL
 + 
chunk_bys
 > 
bufSize
) {

421 *
r
;

422 
bufSize
 = 
chunk_bys
 + (bufSize << 2);

423 
r
 = 
	`REALLOC
(
buf
, 
bufSize
);

424 if(!
r
) {

425 
	`FREEMEM
(
buf
);

426 
ASN__DECODE_FAILED
;

428 
buf
 = 
r
;

430 if(
	`r_g_my_bs
(
pd
, 
buf
 + 
bufL
, 0, 
chunk_bys
 << 3)) {

431 
	`FREEMEM
(
buf
);

432 
ASN__DECODE_STARVED
;

434 
bufL
 +
chunk_bys
;

435 } 

);

437 
	`ASN_DEBUG
("Gtg oty %coded i%ld bys", 
td
->
me
,

438 ()
bufL
);

440 
	`memt
(&
d
, 0, (spd));

441 
d
.
bufr
 = 
buf
;

442 
d
.
nbs
 = 
bufL
 << 3;

444 
	`ASN_DEBUG_INDENT_ADD
(+4);

445 
rv
 = 
td
->

->
	`_decod
(
x
,d, 
cڡts
, 

, &
d
);

446 
	`ASN_DEBUG_INDENT_ADD
(-4);

448 if(
rv
.
code
 =
RC_OK
) {

450 
ddg
 = 
d
.
nbs
 - spd.
nboff
;

451 i(((
ddg
 > 0 &&adding < 8) ||

453 (
d
.
nboff
 =0 && spd.
nbs
 =8 && spd.
bufr
 =
buf
)) &&

454 
	`r_g_w_bs
(&
d
, 
ddg
) == 0) {

456 
	`FREEMEM
(
buf
);

457  
rv
;

459 
	`FREEMEM
(
buf
);

460 if(
ddg
 >= 8) {

461 
	`ASN_DEBUG
("Torgddg %d iݒy", ()
ddg
);

462 
ASN__DECODE_FAILED
;

464 
	`ASN_DEBUG
("Noadding");

467 
	`FREEMEM
(
buf
);

469 
rv
.
code
 = 
RC_FAIL
;

472  
rv
;

473 
	}
}

476 
	$_ݒ_ty_put
(cڡ 
a_TYPE_dest_t
 *
td
,

477 cڡ 
a_r_cڡts_t
 *
cڡts
,

478 cڡ *

, 
a_r_ou_t
 *
po
) {

479 *
buf
;

480 *
br
;

481 
ssize_t
 
size
;

482 
size_t
 
toGo
;

484 
	`ASN_DEBUG
("Otyu%...", 
td
->
me
);

486 
size
 = 
	`_code_to_w_bufr
(
td
, 
cڡts
, 

, &
buf
);

487 if(
size
 <= 0)  -1;

489 
br
 = 
buf
, 
toGo
 = 
size
;oGo;) {

490 
ssize_t
 
maySave
 = 
	`_put_ngth
(
po
, -1, 
toGo
);

491 if(
maySave
 < 0) ;

492 if(
	`r_put_my_bs
(
po
, 
br
, 
maySave
 * 8)) ;

493 
br
 = (*)b+ 
maySave
;

494 
toGo
 -
maySave
;

497 
	`FREEMEM
(
buf
);

498 if(
toGo
)  -1;

500 
	`ASN_DEBUG
("Openypeut %s ofength %ld + overhead (1byte?)",

501 
td
->
me
, 
size
);

504 
	}
}

506 
a_dec_rv_t


507 
	$_ݒ_ty_g
(cڡ 
a_codec_x_t
 *
x
,

508 cڡ 
a_TYPE_dest_t
 *
td
,

509 cڡ 
a_r_cڡts_t
 *
cڡts
,

510 **

, 
a_r_da_t
 *
pd
) {

512  
	`_ݒ_ty_g_sime
(
x
, 
td
, 
cڡts
, 

, 
pd
);

513 
	}
}

516 
	$_ݒ_ty_sk
(cڡ 
a_codec_x_t
 *
x
, 
a_r_da_t
 *
pd
) {

517 
a_TYPE_dest_t
 
s_td
;

518 
a_dec_rv_t
 
rv
;

519 
a_TYPE_ݔi_t
 
_t
;

521 
	`memt
(&
_t
, 0, (op_t));

522 
s_td
.
me
 = "<unknownxtension>";

523 
s_td
.

 = &
_t
;

524 
s_td
.

->
_decod
 = 
ur_s_suck
;

526 
rv
 = 
	`_ݒ_ty_g
(
x
, &
s_td
, 0, 0, 
pd
);

527 if(
rv
.
code
 !
RC_OK
)

531 
	}
}

	@per_support.c

5 
	~<a_syem.h
>

6 
	~<a_.h
>

7 
	~<r_sut.h
>

13 
ssize_t


14 
	$ur_g_ngth
(
a_r_da_t
 *
pd
, 
ebs
, 
size_t
 
low_bound
,

15 *

) {

16 
ssize_t
 
vue
;

18 *

 = 0;

21 if(
ebs
 >= 0 &&bits <= 16) {

22 
vue
 = 
	`r_g_w_bs
(
pd
, 
ebs
);

23 if(
vue
 >0vu+
low_bound
;

24  
vue
;

27 
vue
 = 
	`r_g_w_bs
(
pd
, 8);

28 if((
vue
 & 0x80) == 0) {

29  (
vue
 & 0x7F);

30 } if((
vue
 & 0x40) == 0) {

32 
vue
 = ((vu& 0x3f<< 8| 
	`r_g_w_bs
(
pd
, 8);

33  
vue
;

34 } if(
vue
 < 0) {

35 
	`ASN_DEBUG
("END of streameached for PER");

38 
vue
 &= 0x3f;

39 if(
vue
 < 1 || value > 4) {

42 *

 = 1;

43  (16384 * 
vue
);

44 
	}
}

51 
ssize_t


52 
	$ur_g_ngth
(
a_r_da_t
 *
pd
) {

53 
ssize_t
 
ngth
;

55 
	`ASN_DEBUG
("Gettingormally smallength");

57 if(
	`r_g_w_bs
(
pd
, 1) == 0) {

58 
ngth
 = 
	`r_g_w_bs
(
pd
, 6) + 1;

59 if(
ngth
 <= 0)  -1;

60 
	`ASN_DEBUG
("l=%d", ()
ngth
);

61  
ngth
;

63 

;

64 
ngth
 = 
	`ur_g_ngth
(
pd
, -1, 0, &

);

65 if(
ngth
 >0 && !

) ength;

68 
	}
}

74 
ssize_t


75 
	$ur_g_nnwn
(
a_r_da_t
 *
pd
) {

76 
ssize_t
 
vue
;

78 
vue
 = 
	`r_g_w_bs
(
pd
, 7);

79 if(
vue
 & 64) {

80 
vue
 &= 63;

81 
vue
 <<= 2;

82 
vue
 |
	`r_g_w_bs
(
pd
, 2);

83 if(
vue
 & 128)

85 if(
vue
 == 0)

87 if(
vue
 >= 3)

89 
vue
 = 
	`r_g_w_bs
(
pd
, 8 * value);

90  
vue
;

93  
vue
;

94 
	}
}

101 
	$ur_put_nnwn
(
a_r_ou_t
 *
po
, 
n
) {

102 
bys
;

104 if(
n
 <= 63) {

105 if(
n
 < 0)  -1;

106  
	`r_put_w_bs
(
po
, 
n
, 7);

108 if(
n
 < 256)

109 
bys
 = 1;

110 if(
n
 < 65536)

111 
bys
 = 2;

112 if(
n
 < 256 * 65536)

113 
bys
 = 3;

116 if(
	`r_put_w_bs
(
po
, 
bys
, 8))

119  
	`r_put_w_bs
(
po
, 
n
, 8 * 
bys
);

120 
	}
}

124 
	$ur_g_cڡed_whe_numb
(
a_r_da_t
 *
pd
, *
out_vue
, 
nbs
) {

125 
lhf
;

126 
hf
;

128 if(
nbs
 <= 31) {

129 
hf
 = 
	`r_g_w_bs
(
pd
, 
nbs
);

130 if(
hf
 < 0)  -1;

131 *
out_vue
 = 
hf
;

135 if((
size_t
)
nbs
 > 8 * (*
out_vue
))

138 
hf
 = 
	`r_g_w_bs
(
pd
, 31);

139 if(
hf
 < 0)  -1;

141 if(
	`ur_g_cڡed_whe_numb
(
pd
, &
lhf
, 
nbs
 - 31))

144 *
out_vue
 = (()
hf
 << (
nbs
 - 31)| 
lhf
;

146 
	}
}

151 
	$ur_put_cڡed_whe_numb_u
(
a_r_ou_t
 *
po
, 
v
,

152 
nbs
) {

153 if(
nbs
 <= 31) {

154  
	`r_put_w_bs
(
po
, 
v
, 
nbs
);

157 if(
	`ur_put_cڡed_whe_numb_u
(
po
, 
v
 >> 31, 
nbs
 - 31))

159  
	`r_put_w_bs
(
po
, 
v
, 31);

161 
	}
}

167 
ssize_t


168 
	$ur_put_ngth
(
a_r_ou_t
 *
po
, 
size_t
 
ngth
, *
ed_eom
) {

169 
dummy
 = 0;

170 if(!
ed_eom
ed_eom = &
dummy
;

172 if(
ngth
 <= 127) {

173 *
ed_eom
 = 0;

174  
	`r_put_w_bs
(
po
, 
ngth
, 8)

175 ? -1 : (
ssize_t
)
ngth
;

176 } if(
ngth
 < 16384) {

177 *
ed_eom
 = 0;

178  
	`r_put_w_bs
(
po
, 
ngth
|0x8000, 16)

179 ? -1 : (
ssize_t
)
ngth
;

182 *
ed_eom
 = 0 =(
ngth
 & 16383);

183 
ngth
 >>= 14;

184 if(
ngth
 > 4) {

185 *
ed_eom
 = 0;

186 
ngth
 = 4;

189  
	`r_put_w_bs
(
po
, 0xC0 | 
ngth
, 8)

190 ? -1 : (
ssize_t
)(
ngth
 << 14);

192 
	}
}

201 
	$ur_put_ngth
(
a_r_ou_t
 *
po
, 
size_t
 
ngth
) {

202 if(
ngth
 <= 64) {

204 if(
ngth
 == 0)  -1;

205  
	`r_put_w_bs
(
po
, 
ngth
 - 1, 7) ? -1 : 0;

207 
ed_eom
 = 0;

208 if(
	`ur_put_ngth
(
po
, 
ngth
, &
ed_eom
!(
ssize_t
)length

209 || 
ed_eom
) {

216 
	}
}

219 
	$r__lg_nge
(
lb
, 
ub
, *
nge_r
) {

220 
bounds_nge
;

221 if((
ub
 < 0=(
lb
 < 0)) {

222 
bounds_nge
 = 
ub
 - 
lb
;

223 } if(
lb
 < 0) {

224 
	`as
(
ub
 >= 0);

225 
bounds_nge
 = 1 + (()
ub
 + ()-(
lb
 + 1));

227 
	`as
(!"Unreachable");

230 *
nge_r
 = 
bounds_nge
;

232 
	}
}

235 
	$r_lg_nge_ba
(
v
, 
lb
, 
ub
, *
ouut
) {

236 
nge
;

238 
	`as
(
lb
 <
ub
);

240 if(
v
 < 
lb
 || v > 
ub
 || 
	`r__lg_nge
b, ub, &
nge
) < 0) {

252 if((
v
 < 0=(
lb
 < 0)) {

253 *
ouut
 = 
v
-
lb
;

255 } if(
v
 < 0) {

256 
bad
 = 1 + ()-(
v
+1+ ()
lb
;

257 
	`as
(
bad
 <
nge
);

258 *
ouut
 = 
bad
;

260 } if(
lb
 < 0) {

261 
bad
 = 1 + ()-(
lb
+1+ ()
v
;

262 
	`as
(
bad
 <
nge
);

263 *
ouut
 = 
bad
;

266 
	`as
(!"Unreachable");

269 
	}
}

272 
	$r_lg_nge_ueba
(
p
, 
lb
, 
ub
, *
ou
) {

273 
nge
;

275 if(
	`r__lg_nge
(
lb
, 
ub
, &
nge
) != 0) {

279 if(
p
 > 
nge
) {

288 if(
p
 <
LONG_MAX
) {

289 *
ou
 = ()
p
 + 
lb
;

291 *
ou
 = (
lb
 + 
LONG_MAX
 + 1+ ()((
p
 - LONG_MAX) - 1);

295 
	}
}

297 
t32_t


298 
	$_g_ign
(
a_r_da_t
 *
pd
) {

300 if(
pd
->
nboff
 & 0x7) {

301 
	`ASN_DEBUG
("Aligng %ld bs", 8 - (()
pd
->
nboff
 & 0x7));

302  
	`r_g_w_bs
(
pd
, 8 - (pd->
nboff
 & 0x7));

305 
	}
}

307 
ssize_t


308 
	$_g_ngth
(
a_r_da_t
 *
pd
, 
nge
, 
ebs
, *

) {

309 
ssize_t
 
vue
;

311 *

 = 0;

314 i(
ebs
 >= 0) {

315 i(
nge
 <= 65536 &&ange >= 0)

316  
	`_g_nnwn
(
pd
, 
nge
);

319 i(
	`_g_ign
(
pd
) < 0)

322 if(
ebs
 >0 
	`r_g_w_bs
(
pd
,bits);

324 
vue
 = 
	`r_g_w_bs
(
pd
, 8);

325 if(
vue
 < 0)  -1;

326 if((
vue
 & 128) == 0)

327  (
vue
 & 0x7F);

328 if((
vue
 & 64) == 0) {

329 
vue
 = ((vu& 63<< 8| 
	`r_g_w_bs
(
pd
, 8);

330 if(
vue
 < 0)  -1;

331  
vue
;

333 
vue
 &= 63;

334 if(
vue
 < 1 || value > 4)

336 *

 = 1;

337  (16384 * 
vue
);

338 
	}
}

340 
ssize_t


341 
	$_g_ngth
(
a_r_da_t
 *
pd
) {

342 
ssize_t
 
ngth
;

344 
	`ASN_DEBUG
("Gettingormally smallength");

346 if(
	`r_g_w_bs
(
pd
, 1) == 0) {

347 
ngth
 = 
	`r_g_w_bs
(
pd
, 6) + 1;

348 if(
ngth
 <= 0)  -1;

349 
	`ASN_DEBUG
("l=%ld", 
ngth
);

350  
ngth
;

352 

;

353 
ngth
 = 
	`_g_ngth
(
pd
, -1, -1, &

);

354 if(
ngth
 >0 && !

) ength;

357 
	}
}

359 
ssize_t


360 
	$_g_nnwn
(
a_r_da_t
 *
pd
, 
nge
) {

361 
ssize_t
 
vue
;

362 
bys
 = 0;

364 
	`ASN_DEBUG
("gtgnwwhg%d", 
nge
);

366 if(
nge
 <= 255) {

367 
i
;

369 i(
nge
 < 0)  -1;

371 
i
 = 1; i <= 8; i++) {

372 
u
 = 1 << 
i
;

373 i(
u
 >
nge
)

376 
vue
 = 
	`r_g_w_bs
(
pd
, 
i
);

377  
vue
;

378 } i(
nge
 == 256){

380 
bys
 = 1;

381 } i(
nge
 <= 65536) {

383 
bys
 = 2;

387 i(
	`_g_ign
(
pd
) < 0)

389 
vue
 = 
	`r_g_w_bs
(
pd
, 8 * 
bys
);

390  
vue
;

391 
	}
}

393 
	$_put_ign
(
a_r_ou_t
 *
po
) {

395 if(
po
->
nboff
 & 0x7) {

396 
	`ASN_DEBUG
("Aligng %ld bs", 8 - (()
po
->
nboff
 & 0x7));

397 if(
	`r_put_w_bs
(
po
, 0x00, (8 - (po->
nboff
 & 0x7))))

401 
	}
}

403 
ssize_t


404 
	$_put_ngth
(
a_r_ou_t
 *
po
, 
nge
, 
size_t
 
ngth
) {

406 
	`ASN_DEBUG
("APERungth %zu whg%d", 
ngth
, 
nge
);

409 i(
nge
 <= 65536 &&ange >= 0)

410  
	`_put_nnwn
(
po
, 
nge
, 
ngth
);

412 i(
	`_put_ign
(
po
) < 0)

415 if(
ngth
 <= 127) {

416  
	`r_put_w_bs
(
po
, 
ngth
, 8)

417 ? -1 : (
ssize_t
)
ngth
;

419 if(
ngth
 < 16384)

420  
	`r_put_w_bs
(
po
, 
ngth
|0x8000, 16)

421 ? -1 : (
ssize_t
)
ngth
;

423 
ngth
 >>= 14;

424 if(
ngth
 > 4)ength = 4;

426  
	`r_put_w_bs
(
po
, 0xC0 | 
ngth
, 8)

427 ? -1 : (
ssize_t
)(
ngth
 << 14);

428 
	}
}

432 
	$_put_ngth
(
a_r_ou_t
 *
po
, 
size_t
 
ngth
) {

434 if(
ngth
 <= 64) {

436 if(
ngth
 == 0)  -1;

437  
	`r_put_w_bs
(
po
, 
ngth
-1, 7) ? -1 : 0;

439 if(
	`_put_ngth
(
po
, -1, 
ngth
!(
ssize_t
)length) {

446 
	}
}

449 
	$_put_nnwn
(
a_r_ou_t
 *
po
, 
nge
, 
numb
) {

450 
bys
;

452 
	`ASN_DEBUG
("unnw%d whg%d", 
numb
, 
nge
);

454 if(
nge
 < 0) {

455 
i
;

456 
i
 = 1; ; i++) {

457 
bs
 = 1 << (8 * 
i
);

458 i(
numb
 <
bs
)

461 
bys
 = 
i
;

462 
	`as
(
i
 <= 4);

464 if(
nge
 <= 255) {

465 
i
;

466 
i
 = 1; i <= 8; i++) {

467 
bs
 = 1 << 
i
;

468 i(
nge
 <
bs
)

471  
	`r_put_w_bs
(
po
, 
numb
, 
i
);

472 } if(
nge
 == 256) {

473 
bys
 = 1;

474 } if(
nge
 <= 65536) {

475 
bys
 = 2;

477 
i
;

478 
i
 = 1; ; i++) {

479 
bs
 = 1 << (8 * 
i
);

480 i(
nge
 <
bs
)

483 
	`as
(
i
 <= 4);

484 
bys
 = 
i
;

486 if(
	`_put_ign
(
po
) < 0)

491  
	`r_put_w_bs
(
po
, 
numb
, 8 * 
bys
);

492 
	}
}

	@xer_decoder.c

5 
	~<a_iti.h
>

6 
	~<a_.h
>

7 
	~<x_sut.h
>

13 
a_dec_rv_t


14 
	$x_decode
(cڡ 
a_codec_x_t
 *
t_codec_x
,

15 cڡ 
a_TYPE_dest_t
 *
td
, **
ru_r
,

16 cڡ *
bufr
, 
size_t
 
size
) {

17 
a_codec_x_t
 
s_codec_x
;

23 if(
t_codec_x
) {

24 if(
t_codec_x
->
max_ack_size
) {

25 
s_codec_x
 = *
t_codec_x
;

26 
t_codec_x
 = &
s_codec_x
;

30 
	`memt
(&
s_codec_x
, 0, (s_codec_ctx));

31 
s_codec_x
.
max_ack_size
 = 
ASN__DEFAULT_STACK_MAX
;

32 
t_codec_x
 = &
s_codec_x
;

38  
td
->

->
	`x_decod
(
t_codec_x
,d, 
ru_r
, 0, 
bufr
, 
size
);

39 
	}
}

43 
	sx__cb_g
 {

44 
pxml_chunk_ty_e
 
	mchunk_ty
;

45 
size_t
 
	mchunk_size
;

46 cڡ *
	mchunk_buf
;

47 
	mback_n_voked
;

51 
	$x__tok_cb
(
pxml_chunk_ty_e
 
ty
, cڡ *
_chunk_da
, 
size_t
 
_chunk_size
, *
key
) {

52 
x__cb_g
 *
g
 = (x__cb_g *)
key
;

53 
g
->
chunk_ty
 = 
ty
;

54 
g
->
chunk_size
 = 
_chunk_size
;

55 
g
->
chunk_buf
 = 
_chunk_da
;

56 
g
->
back_n_voked
 = 0;

58 
	}
}

63 
ssize_t


64 
	$x_xt_tok
(*
eCڋxt
, cڡ *
bufr
, 
size_t
 
size
, 
px_chunk_ty_e
 *
ch_ty
) {

65 
x__cb_g
 
g
;

66 
w_eCڋxt
 = *
eCڋxt
;

67 
ssize_t
 
t
;

69 
g
.
back_n_voked
 = 1;

70 
t
 = 
	`pxml_r
(&
w_eCڋxt
, 
bufr
, 
size
, 
x__tok_cb
, &
g
);

71 if(
t
 < 0)  -1;

72 if(
g
.
back_n_voked
) {

73 
	`as
(
t
 == 0);

74 *
ch_ty
 = 
PXER_WMORE
;

77 
	`as
(
g
.
chunk_size
);

78 
	`as
(
g
.
chunk_buf
 =
bufr
);

84 
g
.
chunk_ty
) {

85 
PXML_TEXT
:

86 *
ch_ty
 = 
PXER_TEXT
;

88 
PXML_TAG
:

89 *
ch_ty
 = 
PXER_WMORE
;

91 
PXML_TAG_END
:

92 *
ch_ty
 = 
PXER_TAG
;

94 
PXML_COMMENT
:

95 
PXML_COMMENT_END
:

96 *
ch_ty
 = 
PXER_COMMENT
;

100 *
eCڋxt
 = 
w_eCڋxt
;

101  
g
.
chunk_size
;

102 
	}
}

104 
	#CSLASH
 0x2

	)

105 
	#LANGLE
 0x3

	)

106 
	#RANGLE
 0x3

	)

108 
x_check_g_e


109 
	$x_check_g
(cڡ *
buf_r
, 
size
, cڡ *
ed_g
) {

110 cڡ *
buf
 = (cڡ *)
buf_r
;

111 cڡ *
d
;

112 
x_check_g_e
 

 = 
XCT_OPENING
;

114 if(
size
 < 2 || 
buf
[0] !
LANGLE
 || buf[size-1] !
RANGLE
) {

115 if(
size
 >= 2)

116 
	`ASN_DEBUG
("Broken XMLag: \"%c...%c\"",

117 
buf
[0], buf[
size
 - 1]);

118  
XCT_BROKEN
;

124 if(
buf
[1] =
CSLASH
) {

125 
buf
 += 2;

126 
size
 -= 3;

127 

 = 
XCT_CLOSING
;

128 if(
size
 > 0 && 
buf
[size-1] =
CSLASH
)

129  
XCT_BROKEN
;

131 
buf
++;

132 
size
 -= 2;

133 if(
size
 > 0 && 
buf
[size-1] =
CSLASH
) {

134 

 = 
XCT_BOTH
;

135 
size
--;

140 if(!
ed_g
 || !*need_tag)

141  (
x_check_g_e
)(
XCT__UNK__MASK
 | 

);

146 
d
 = 
buf
 + 
size
; bu<nd; buf++, 
ed_g
++) {

147 
b
 = *
buf
, 
n
 = *
ed_g
;

148 if(
b
 !
n
) {

149 if(
n
 == 0) {

150 
b
) {

154  

;

157  (
x_check_g_e
)(
XCT__UNK__MASK
 | 

);

159 if(
b
 == 0)

160  
XCT_BROKEN
;

162 if(*
ed_g
)

163  (
x_check_g_e
)(
XCT__UNK__MASK
 | 

);

165  

;

166 
	}
}

169 #unde
ADVANCE


170 
	#ADVANCE
(
num_bys
) do { \

171 
size_t
 
num
 = (
num_bys
); \

172 
buf_r
 = ((cڡ *)buf_r+ 
num
; \

173 
size
 -
num
; \

174 
csumed_mylf
 +
num
; \

175 } 0)

	)

177 #unde
RETURN


178 
	#RETURN
(
_code
) do { \

179 
rv
.
code
 = 
_code
; \

180 
rv
.
csumed
 = 
csumed_mylf
; \

181 if(
rv
.
code
 !
RC_OK
) \

182 
	`ASN_DEBUG
("Faed wh %d", 
rv
.
code
); \

183  
rv
; \

184 } 0)

	)

186 
	#XER_GOT_BODY
(
chunk_buf
, 
chunk_size
, 
size
) do { \

187 
ssize_t
 
cvd_size
 = 
body_iv
 \

188 (
ru_key
, 
chunk_buf
, 
chunk_size
, \

189 (
size_t
)
chunk_size
 < 
size
); \

190 if(
cvd_size
 =-1
	`RETURN
(
RC_FAIL
); \

191 if(
cvd_size
 == 0 \

192 && 
size
 =(
size_t
)
chunk_size
) \

193 
	`RETURN
(
RC_WMORE
); \

194 
chunk_size
 = 
cvd_size
; \

195 } 0)

	)

196 
	#XER_GOT_EMPTY
() do { \

197 if(
	`body_iv
(
ru_key
, 0, 0, 
size
 > 0) == -1) \

198 
	`RETURN
(
RC_FAIL
); \

199 } 0)

	)

204 
a_dec_rv_t


205 
x_decode_g
(cڡ 
a_codec_x_t
 *
t_codec_x
,

206 
a_ru_x_t
 *
x
,

207 *
ru_key
,

208 cڡ *
xml_g
,

209 cڡ *
buf_r
, 
size_t
 
size
,

210 (*
t_uxed_g_decod
)

211 (*
ru_key
, cڡ *
chunk_buf
, 
size_t
 
chunk_size
),

212 
	$ssize_t
 (*
body_iv
)

213 (*
ru_key
, cڡ *
chunk_buf
, 
size_t
 
chunk_size
,

214 
have_me
)

217 
a_dec_rv_t
 
rv
;

218 
ssize_t
 
csumed_mylf
 = 0;

220 ()
t_codec_x
;

227 if(
x
->
pha
 > 1
	`RETURN
(
RC_FAIL
);

229 
px_chunk_ty_e
 
ch_ty
;

230 
ssize_t
 
ch_size
;

231 
x_check_g_e
 
tcv
;

236 
ch_size
 = 
	`x_xt_tok
(&
x
->
cڋxt
, 
buf_r
, 
size
,

237 &
ch_ty
);

238 if(
ch_size
 == -1) {

239 
	`RETURN
(
RC_FAIL
);

241 
ch_ty
) {

242 
PXER_WMORE
:

243 
	`RETURN
(
RC_WMORE
);

244 
PXER_COMMENT
:

245 
	`ADVANCE
(
ch_size
);

247 
PXER_TEXT
:

248 if(
x
->
pha
 == 0) {

256 
	`XER_GOT_BODY
(
buf_r
, 
ch_size
, 
size
);

258 
	`ADVANCE
(
ch_size
);

260 
PXER_TAG
:

265 
	`as
(
ch_ty
 =
PXER_TAG
 && 
size
);

267 
tcv
 = 
	`x_check_g
(
buf_r
, 
ch_size
, 
xml_g
);

275 
tcv
) {

276 
XCT_BOTH
:

277 if(
x
->
pha
) ;

279 
	`XER_GOT_EMPTY
();

280 
	`ADVANCE
(
ch_size
);

281 
x
->
pha
 = 2;

282 
	`RETURN
(
RC_OK
);

283 
XCT_OPENING
:

284 if(
x
->
pha
) ;

285 
	`ADVANCE
(
ch_size
);

286 
x
->
pha
 = 1;

288 
XCT_CLOSING
:

289 if(!
x
->
pha
) ;

290 
	`ADVANCE
(
ch_size
);

291 
x
->
pha
 = 2;

292 
	`RETURN
(
RC_OK
);

293 
XCT_UNKNOWN_BO
:

297 if(
t_uxed_g_decod


298 && 
	`t_uxed_g_decod
(
ru_key
,

299 
buf_r
, 
ch_size
) >= 0) {

301 
	`ADVANCE
(
ch_size
);

302 if(!
x
->
pha
) {

305 
x
->
pha
 = 2;

306 
	`RETURN
(
RC_OK
);

315 
	`ASN_DEBUG
("Uxed XMLag (exed \"%s\")", 
xml_g
);

319 
	`RETURN
(
RC_FAIL
);

320 
	}
}

323 
size_t


324 
	$x_whea_
(cڡ *
chunk_buf
, 
size_t
 
chunk_size
) {

325 cڡ *
p
 = (cڡ *)
chunk_buf
;

326 cڡ *
nd
 = 
p
 + 
chunk_size
;

328 ; 
p
 < 
nd
;++) {

329 *
p
) {

343  (
p
 - (cڡ *)
chunk_buf
);

344 
	}
}

350 
	$x_sk_unknown
(
x_check_g_e
 
tcv
, 
b_v_n_t
 *
dth
) {

351 
	`as
(*
dth
 > 0);

352 
tcv
) {

353 
XCT_BOTH
:

354 
XCT_UNKNOWN_BO
:

357 
XCT_OPENING
:

358 
XCT_UNKNOWN_OP
:

359 ++(*
dth
);

361 
XCT_CLOSING
:

362 
XCT_UNKNOWN_CL
:

363 if(--(*
dth
) == 0)

364  (
tcv
 =
XCT_CLOSING
) ? 2 : 1;

369 
	}
}

	@xer_encoder.c

5 
	~<a_.h
>

6 
	~<dio.h
>

7 
	~<o.h
>

12 
a_c_rv_t


13 
	$x_code
(cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

,

14 
x_cod_ags_e
 
x_ags
, 
a_p_csume_bys_f
 *
cb
,

15 *
p_key
) {

16 
a_c_rv_t
 

 = {0, 0, 0};

17 
a_c_rv_t
 
tmr
;

18 cڡ *
mme
;

19 
size_t
 
mn
;

20 
xn
 = (
x_ags
 & 
XER_F_CANONICAL
) ? 1 : 2;

22 if(!
td
 || !


cb_ed
;

24 
mme
 = 
td
->
xml_g
;

25 
mn
 = 
	`
(
mme
);

27 
	`ASN__CALLBACK3
("<", 1, 
mme
, 
mn
, ">", 1);

29 
tmr
 = 
td
->

->
	`x_cod
d, 

, 1, 
x_ags
, 
cb
, 
p_key
);

30 if(
tmr
.
coded
 == -1) mper;

31 

.
coded
 +
tmr
.encoded;

33 
	`ASN__CALLBACK3
("</", 2, 
mme
, 
mn
, ">\n", 
xn
);

35 
	`ASN__ENCODED_OK
(

);

36 
cb_ed
:

37 
ASN__ENCODE_FAILED
;

38 
	}
}

45 
	$x__t2
(cڡ *
bufr
, 
size_t
 
size
, *
p_key
) {

46 
FILE
 *
am
 = (FILE *)
p_key
;

48 if(
	`fwre
(
bufr
, 1, 
size
, 
am
) != size)

52 
	}
}

55 
	$x_rt
(
FILE
 *
am
, cڡ 
a_TYPE_dest_t
 *
td
, cڡ *

) {

56 
a_c_rv_t
 

 = {0,0,0};

58 if(!
am
衻am = 
dout
;

59 if(!
td
 || !

)

62 

 = 
	`x_code
(
td
, 

, 
XER_F_BASIC
, 
x__t2
, 
am
);

63 if(

.
coded
 == -1)

66  
	`fush
(
am
);

67 
	}
}

69 
	sx_bufr
 {

70 *
	mbufr
;

71 
size_t
 
	mbufr_size
;

72 
size_t
 
	mlod_size
;

76 
	$x__bufr_nd
(cڡ *
bufr
, 
size_t
 
size
, *
p_key
) {

77 
x_bufr
 *
xb
 = 
p_key
;

79 
xb
->
bufr_size
 + 
size
 + 1 > xb->
lod_size
) {

80 
size_t
 
w_size
 = 2 * (
xb
->
lod_size
 ? xb->allocated_size : 64);

81 *
w_buf
 = 
	`MALLOC
(
w_size
);

82 if(!
w_buf
)  -1;

83 i(
xb
->
bufr
) {

84 
	`memy
(
w_buf
, 
xb
->
bufr
, xb->
bufr_size
);

86 
	`FREEMEM
(
xb
->
bufr
);

87 
xb
->
bufr
 = 
w_buf
;

88 
xb
->
lod_size
 = 
w_size
;

91 
	`memy
(
xb
->
bufr
 + xb->
bufr_size
, bufr, 
size
);

92 
xb
->
bufr_size
 +
size
;

93 
xb
->
bufr
[xb->
bufr_size
] = '\0';

95 
	}
}

97 
x_equiv_e


98 
	$x_equivt
(cڡ 
a_TYPE_dest_s
 *
td
, cڡ *
ru1
,

99 cڡ *
ru2
, 
FILE
 *
t_debug_am
) {

100 
x_bufr
 
xb1
 = {0, 0, 0};

101 
x_bufr
 
xb2
 = {0, 0, 0};

102 
a_c_rv_t
 
e1
, 
e2
;

103 
a_dec_rv_t
 
rv
;

104 *

 = 
NULL
;

106 if(!
td
 || !
ru1
 || !
ru2
) {

107 if(
t_debug_am
) {

108 if(!
td

	`rtf
(
t_debug_am
, "Type descriptor missing\n");

109 if(!
ru1

	`rtf
(
t_debug_am
, "Structure 1 missing\n");

110 if(!
ru2

	`rtf
(
t_debug_am
, "Structure 2 missing\n");

112  
XEQ_FAILURE
;

115 
e1
 = 
	`x_code
(
td
, 
ru1
, 
XER_F_BASIC
, 
x__bufr_nd
, &
xb1
);

116 if(
e1
.
coded
 == -1) {

117 if(
t_debug_am
) {

118 
	`rtf
(
dr
, "XER Encodg o%ed\n", 
td
->
me
);

120 
	`FREEMEM
(
xb1
.
bufr
);

121  
XEQ_ENCODE1_FAILED
;

124 
e2
 = 
	`x_code
(
td
, 
ru2
, 
XER_F_BASIC
, 
x__bufr_nd
, &
xb2
);

125 if(
e2
.
coded
 == -1) {

126 if(
t_debug_am
) {

127 
	`rtf
(
dr
, "XER Encodg o%ed\n", 
td
->
me
);

129 
	`FREEMEM
(
xb1
.
bufr
);

130 
	`FREEMEM
(
xb2
.
bufr
);

131  
XEQ_ENCODE1_FAILED
;

134 if(
xb1
.
bufr_size
 !
xb2
.buffer_size

135 || 
	`memcmp
(
xb1
.
bufr
, 
xb2
.bufr, xb1.
bufr_size
) != 0) {

136 if(
t_debug_am
) {

137 
	`rtf
(
t_debug_am
,

140 
xb1
.
bufr
, 
xb2
.buffer);

142 
	`FREEMEM
(
xb1
.
bufr
);

143 
	`FREEMEM
(
xb2
.
bufr
);

144  
XEQ_DIFFERENT
;

146 if(
t_debug_am
) {

147 
	`rtf
(
t_debug_am
,

149 "osiz%" 
ASN_PRI_SIZE
 ":\n%s",

150 
xb1
.
bufr_size
, xb1.
bufr
);

154 
rv
 = 
	`x_decode
(
NULL
, 
td
, (**)&

, 
xb1
.
bufr
,

155 
xb1
.
bufr_size
);

156 
rv
.
code
) {

157 
RC_OK
:

159 
RC_WMORE
:

160 if(
t_debug_am
) {

161 
	`rtf
(
t_debug_am
,

164 
td
->
me
, 
xb1
.
bufr
);

167 
RC_FAIL
:

169 if(
t_debug_am
) {

170 
	`rtf
(
t_debug_am
,

172 
td
->
me
);

174 
	`ASN_STRUCT_FREE
(*
td
, 

);

175 
	`FREEMEM
(
xb1
.
bufr
);

176 
	`FREEMEM
(
xb2
.
bufr
);

177  
XEQ_DECODE_FAILED
;

180 if(
rv
.
csumed
 !
xb1
.
bufr_size


181 && ((
rv
.
csumed
 > 
xb1
.
bufr_size
)

182 || 
	`x_whea_
(
xb1
.
bufr
 + 
rv
.
csumed
,

183 
xb1
.
bufr_size
 - 
rv
.
csumed
)

184 !(
xb1
.
bufr_size
 - 
rv
.
csumed
))) {

185 if(
t_debug_am
) {

186 
	`rtf
(
t_debug_am
,

187 "Round- decodo%quedesby(%" 
ASN_PRI_SIZE
 ")han "

188 "coded (%" 
ASN_PRI_SIZE
 ")\n",

189 
td
->
me
, 
rv
.
csumed
, 
xb1
.
bufr_size
);

191 
	`ASN_STRUCT_FREE
(*
td
, 

);

192 
	`FREEMEM
(
xb1
.
bufr
);

193 
	`FREEMEM
(
xb2
.
bufr
);

194  
XEQ_ROUND_TRIP_FAILED
;

200 
	`FREEMEM
(
xb2
.
bufr
);

201 
	`memt
(&
xb2
, 0, (xb2));

203 
e2
 = 
	`x_code
(
td
, 

, 
XER_F_BASIC
, 
x__bufr_nd
, &
xb2
);

204 if(
e2
.
coded
 == -1) {

205 if(
t_debug_am
) {

206 
	`rtf
(
dr
, "XER Encoding ofound-trip decode of %s failed\n",

207 
td
->
me
);

209 
	`ASN_STRUCT_FREE
(*
td
, 

);

210 
	`FREEMEM
(
xb1
.
bufr
);

211 
	`FREEMEM
(
xb2
.
bufr
);

212  
XEQ_ROUND_TRIP_FAILED
;

215 
	`ASN_STRUCT_FREE
(*
td
, 

);

216 

 = 0;

218 if(
xb1
.
bufr_size
 !
xb2
.buffer_size

219 || 
	`memcmp
(
xb1
.
bufr
, 
xb2
.bufr, xb1.
bufr_size
) != 0) {

220 if(
t_debug_am
) {

221 
	`rtf
(
t_debug_am
,

226 
xb1
.
bufr
, 
xb2
.bufr, 
td
->
me
);

228 
	`FREEMEM
(
xb1
.
bufr
);

229 
	`FREEMEM
(
xb2
.
bufr
);

230  
XEQ_ROUND_TRIP_FAILED
;

233 
	`FREEMEM
(
xb1
.
bufr
);

234 
	`FREEMEM
(
xb2
.
bufr
);

235  
XEQ_SUCCESS
;

236 
	}
}

	@xer_support.c

7 
	~<a_syem.h
>

8 
	~<x_sut.h
>

12 
	mST_TEXT
,

13 
	mST_TAG_START
,

14 
	mST_TAG_BODY
,

15 
	mST_TAG_QUOTE_WAIT
,

16 
	mST_TAG_QUOTED_STRING
,

17 
	mST_TAG_UNQUOTED_STRING
,

18 
	mST_COMMENT_WAIT_DASH1
,

19 
	mST_COMMENT_WAIT_DASH2
,

20 
	mST_COMMENT
,

21 
	mST_COMMENT_CLO_DASH2
,

22 
	mST_COMMENT_CLO_RT


23 } 
	tpe_e
;

26 
	g_chass
[256] = {

36 
	#WHITESPACE
(
c
(
_chass
[()(c)] =1)

	)

37 
	#ALNUM
(
c
(
_chass
[()(c)] >2)

	)

38 
	#ALPHA
(
c
(
_chass
[()(c)] =3)

	)

41 
	#EXCLAM
 0x21

	)

42 
	#CQUOTE
 0x22

	)

43 
	#CDASH
 0x2d

	)

44 
	#CSLASH
 0x2

	)

45 
	#LANGLE
 0x3

	)

46 
	#CEQUAL
 0x3d

	)

47 
	#RANGLE
 0x3

	)

48 
	#CQUEST
 0x3

	)

51 
	#TOKEN_CB_CALL
(
ty
, 
_ns
, 
_cut_too
, 
_f
) do { \

52 
_t
; \

53 
pe_e
 
ns
 = 
_ns
; \

54 
ssize_t
 
_sz
 = (
p
 - 
chunk_t
+ 
_cut_too
; \

55 i(!
_sz
) { \

57 
e
 = 
_ns
; \

60 
_t
 = 
	`cb
(
ty
, 
chunk_t
, 
_sz
, 
key
); \

61 if(
_t
 < 
_sz
) { \

62 if(
_cut_too
 && 
_t
 == -1) \

63 
e
 = 
ns
; \

64 
fish
; \

66 
chunk_t
 = 
p
 + 
_cut_too
; \

67 
e
 = 
ns
; \

68 } 0)

	)

70 
	#TOKEN_CB
(
_ty
, 
_ns
, 
_cut_too
) \

71 
	`TOKEN_CB_CALL
(
_ty
, 
_ns
, 
_cut_too
, 0)

	)

73 
	#PXML_TAG_FINAL_CHUNK_TYPE
 
PXML_TAG_END


	)

74 
	#PXML_COMMENT_FINAL_CHUNK_TYPE
 
PXML_COMMENT_END


	)

76 
	#TOKEN_CB_FINAL
(
_ty
, 
_ns
, 
_cut_too
) \

77 
	`TOKEN_CB_CALL

_ty
 ## 
_FINAL_CHUNK_TYPE
 , 
_ns
, 
_cut_too
, 1)

	)

82 
ssize_t
 
	$pxml_r
(*
eCڋxt
, cڡ *
xmlbuf
, 
size_t
 
size
, 
pxml_back_f
 *
cb
, *
key
) {

83 
pe_e
 
e
 = (pe_e)*
eCڋxt
;

84 cڡ *
chunk_t
 = (cڡ *)
xmlbuf
;

85 cڡ *
p
 = 
chunk_t
;

86 cڡ *
d
 = 
p
 + 
size
;

88 ; 
p
 < 
d
;++) {

89 
C
 = *(cڡ *)
p
;

90 
e
) {

91 
ST_TEXT
:

96 i(
C
 =
LANGLE
)

98 
	`TOKEN_CB
(
PXML_TEXT
, 
ST_TAG_START
, 0);

100 
ST_TAG_START
:

101 i(
	`ALPHA
(
C
|| (C =
CSLASH
))

102 
e
 = 
ST_TAG_BODY
;

103 i(
C
 =
EXCLAM
)

104 
e
 = 
ST_COMMENT_WAIT_DASH1
;

110 
	`TOKEN_CB
(
PXML_TEXT
, 
ST_TEXT
, 1);

112 
ST_TAG_BODY
:

113 
C
) {

114 
RANGLE
:

116 
	`TOKEN_CB_FINAL
(
PXML_TAG
, 
ST_TEXT
, 1);

118 
LANGLE
:

123 
	`TOKEN_CB_FINAL
(
PXML_TAG
, 
ST_TAG_START
, 0);

125 
CEQUAL
:

126 
e
 = 
ST_TAG_QUOTE_WAIT
;

130 
ST_TAG_QUOTE_WAIT
:

134 
C
) {

135 
CQUOTE
:

136 
e
 = 
ST_TAG_QUOTED_STRING
;

138 
RANGLE
:

140 
	`TOKEN_CB_FINAL
(
PXML_TAG
, 
ST_TEXT
, 1);

143 if(!
	`WHITESPACE
(
C
))

145 
e
 = 
ST_TAG_UNQUOTED_STRING
;

148 
ST_TAG_QUOTED_STRING
:

152 if(
C
 =
CQUOTE
) {

154 
e
 = 
ST_TAG_BODY
;

157 
ST_TAG_UNQUOTED_STRING
:

158 if(
C
 =
RANGLE
) {

160 
	`TOKEN_CB_FINAL
(
PXML_TAG
, 
ST_TEXT
, 1);

161 } if(
	`WHITESPACE
(
C
)) {

163 
e
 = 
ST_TAG_BODY
;

166 
ST_COMMENT_WAIT_DASH1
:

167 if(
C
 =
CDASH
) {

168 
e
 = 
ST_COMMENT_WAIT_DASH2
;

171 
e
 = 
ST_TAG_BODY
;

174 
ST_COMMENT_WAIT_DASH2
:

175 if(
C
 =
CDASH
) {

177 
e
 = 
ST_COMMENT
;

180 
e
 = 
ST_TAG_BODY
;

183 
ST_COMMENT
:

184 if(
C
 =
CDASH
) {

185 
e
 = 
ST_COMMENT_CLO_DASH2
;

188 
ST_COMMENT_CLO_DASH2
:

189 if(
C
 =
CDASH
) {

190 
e
 = 
ST_COMMENT_CLO_RT
;

193 
e
 = 
ST_COMMENT
;

196 
ST_COMMENT_CLO_RT
:

197 if(
C
 =
RANGLE
) {

198 
	`TOKEN_CB_FINAL
(
PXML_COMMENT
, 
ST_TEXT
, 1);

199 } if(
C
 =
CDASH
) {

202 
e
 = 
ST_COMMENT
;

211 if(
p
 - 
chunk_t
) {

212 
e
) {

213 
ST_COMMENT
:

214 
	`TOKEN_CB
(
PXML_COMMENT
, 
e
, 0);

216 
ST_TEXT
:

217 
	`TOKEN_CB
(
PXML_TEXT
, 
e
, 0);

223 
fish
:

224 *
eCڋxt
 = ()
e
;

225  
chunk_t
 - (cڡ *)
xmlbuf
;

226 
	}
}

	@/usr/include/errno.h

22 #idef 
_ERRNO_H


23 
	#_ERRNO_H
 1

	)

25 
	~<us.h
>

28 
	~<bs/o.h
>

32 #ide
__ASSEMBLER__


34 
__BEGIN_DECLS


37 *
	$__o_loti
 (
__THROW
 
__ibu_cڡ__
;

38 
	#o
 (*
	`__o_loti
 ())

	)

40 #ifde
__USE_GNU


45 *
ogm_voti_me
;

46 *
ogm_voti_sht_me
;

50 #ide
__r_t_defed


51 
	#__r_t_defed
 1

	)

52 
	tr_t
;

57 
__END_DECLS


	@/usr/include/math.h

23 #idef 
_MATH_H


24 
	#_MATH_H
 1

	)

26 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

27 
	~<bs/libc-hd-t.h
>

29 #i
defed
 
log
 && defed 
__GNUC__


30 #wng 
A
 
mao
 
ed
 
log
 
was
 
ady
 
defed
 
wh
 <
mh
.
h
> wa
uded
.

31 #wng 
This
 
wl
 
u
 
compi
 
obms
.

34 
	g__BEGIN_DECLS


37 
	~<bs/tys.h
>

40 
	~<bs/mh-ve.h
>

43 
	~<bs/ߊ.h
>

47 #i
__GNUC_PREREQ
 (3, 3)

48 
	#HUGE_VAL
 (
	`__but_huge_v
 ())

	)

55 
	#HUGE_VAL
 1e10000

	)

57 #ifde
__USE_ISOC99


58 #i
__GNUC_PREREQ
 (3, 3)

59 
	#HUGE_VALF
 (
	`__but_huge_vf
 ())

	)

60 
	#HUGE_VALL
 (
	`__but_huge_vl
 ())

	)

62 
	#HUGE_VALF
 1e10000f

	)

63 
	#HUGE_VALL
 1e10000L

	)

66 #i
__HAVE_FLOAT16
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

67 
	#HUGE_VAL_F16
 (
	`__but_huge_vf16
 ())

	)

69 #i
__HAVE_FLOAT32
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

70 
	#HUGE_VAL_F32
 (
	`__but_huge_vf32
 ())

	)

72 #i
__HAVE_FLOAT64
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

73 
	#HUGE_VAL_F64
 (
	`__but_huge_vf64
 ())

	)

75 #i
__HAVE_FLOAT128
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

76 
	#HUGE_VAL_F128
 (
	`__but_huge_vf128
 ())

	)

78 #i
__HAVE_FLOAT32X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

79 
	#HUGE_VAL_F32X
 (
	`__but_huge_vf32x
 ())

	)

81 #i
__HAVE_FLOAT64X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

82 
	#HUGE_VAL_F64X
 (
	`__but_huge_vf64x
 ())

	)

84 #i
__HAVE_FLOAT128X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

85 
	#HUGE_VAL_F128X
 (
	`__but_huge_vf128x
 ())

	)

88 #ifde
__USE_ISOC99


90 #i
__GNUC_PREREQ
 (3, 3)

91 
	#INFINITY
 (
	`__but_ff
 ())

	)

93 
	#INFINITY
 
HUGE_VALF


	)

97 #i
__GNUC_PREREQ
 (3, 3)

98 
	#NAN
 (
	`__but_nf
 (""))

	)

103 
	#NAN
 (0.0/ 0.0f)

	)

107 #i
__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

109 #i
__GNUC_PREREQ
 (3, 3)

110 
	#SNANF
 (
	`__but_nsf
 (""))

	)

111 
	#SNAN
 (
	`__but_ns
 (""))

	)

112 
	#SNANL
 (
	`__but_n
 (""))

	)

115 #i
__HAVE_FLOAT16
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

116 
	#SNANF16
 (
	`__but_nsf16
 (""))

	)

118 #i
__HAVE_FLOAT32
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

119 
	#SNANF32
 (
	`__but_nsf32
 (""))

	)

121 #i
__HAVE_FLOAT64
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

122 
	#SNANF64
 (
	`__but_nsf64
 (""))

	)

124 #i
__HAVE_FLOAT128
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

125 
	#SNANF128
 (
	`__but_nsf128
 (""))

	)

127 #i
__HAVE_FLOAT32X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

128 
	#SNANF32X
 (
	`__but_nsf32x
 (""))

	)

130 #i
__HAVE_FLOAT64X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

131 
	#SNANF64X
 (
	`__but_nsf64x
 (""))

	)

133 #i
__HAVE_FLOAT128X
 && 
__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

134 
	#SNANF128X
 (
	`__but_nsf128x
 (""))

	)

138 
	~<bs/t-ev-mhod.h
>

140 #ifde
__USE_ISOC99


148 #i
__GLIBC_FLT_EVAL_METHOD
 == 0 || __GLIBC_FLT_EVAL_METHOD == 16

149 
	tt_t
;

150 
	tdoub_t
;

151 #i
__GLIBC_FLT_EVAL_METHOD
 == 1

152 
	tt_t
;

153 
	tdoub_t
;

154 #i
__GLIBC_FLT_EVAL_METHOD
 == 2

155 
	tt_t
;

156 
	tdoub_t
;

157 #i
__GLIBC_FLT_EVAL_METHOD
 == 32

158 
_Flt32
 
	tt_t
;

159 
	tdoub_t
;

160 #i
__GLIBC_FLT_EVAL_METHOD
 == 33

161 
_Flt32x
 
	tt_t
;

162 
_Flt32x
 
	tdoub_t
;

163 #i
__GLIBC_FLT_EVAL_METHOD
 == 64

164 
_Flt64
 
	tt_t
;

165 
_Flt64
 
	tdoub_t
;

166 #i
__GLIBC_FLT_EVAL_METHOD
 == 65

167 
_Flt64x
 
	tt_t
;

168 
_Flt64x
 
	tdoub_t
;

169 #i
__GLIBC_FLT_EVAL_METHOD
 == 128

170 
_Flt128
 
	tt_t
;

171 
_Flt128
 
	tdoub_t
;

172 #i
__GLIBC_FLT_EVAL_METHOD
 == 129

173 
_Flt128x
 
	tt_t
;

174 
_Flt128x
 
	tdoub_t
;

190 
	~<bs/-logb.h
>

191 #ifde
__USE_ISOC99


192 #i
__FP_LOGB0_IS_MIN


193 
	#FP_ILOGB0
 (-2147483647 - 1)

	)

195 
	#FP_ILOGB0
 (-2147483647)

	)

197 #i
__FP_LOGBNAN_IS_MIN


198 
	#FP_ILOGBNAN
 (-2147483647 - 1)

	)

200 
	#FP_ILOGBNAN
 2147483647

	)

203 #i
__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

204 #i
__WORDSIZE
 == 32

205 
	#__FP_LONG_MAX
 0x7fffffffL

	)

207 
	#__FP_LONG_MAX
 0x7fffffffffffffffL

	)

209 #i
__FP_LOGB0_IS_MIN


210 
	#FP_LLOGB0
 (-
__FP_LONG_MAX
 - 1)

	)

212 
	#FP_LLOGB0
 (-
__FP_LONG_MAX
)

	)

214 #i
__FP_LOGBNAN_IS_MIN


215 
	#FP_LLOGBNAN
 (-
__FP_LONG_MAX
 - 1)

	)

217 
	#FP_LLOGBNAN
 
__FP_LONG_MAX


	)

233 
	~<bs/-.h
>

235 #i
__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

239 
	mFP_INT_UPWARD
 =

240 
	#FP_INT_UPWARD
 0

	)

241 
FP_INT_UPWARD
,

242 
	mFP_INT_DOWNWARD
 =

243 
	#FP_INT_DOWNWARD
 1

	)

244 
FP_INT_DOWNWARD
,

245 
	mFP_INT_TOWARDZERO
 =

246 
	#FP_INT_TOWARDZERO
 2

	)

247 
FP_INT_TOWARDZERO
,

248 
	mFP_INT_TONEARESTFROMZERO
 =

249 
	#FP_INT_TONEARESTFROMZERO
 3

	)

250 
FP_INT_TONEARESTFROMZERO
,

251 
	mFP_INT_TONEAREST
 =

252 
	#FP_INT_TONEAREST
 4

	)

253 
FP_INT_TONEAREST
,

262 
	#__SIMD_DECL
(
funi

	`__CONCAT
 (
__DECL_SIMD_
, funi)

	)

264 
	#__MATHCALL_VEC
(
funi
, 
suffix
, 
gs
) \

265 
	`__SIMD_DECL
 (
	`__MATH_PRECNAME
 (
funi
, 
suffix
)) \

266 
	`__MATHCALL
 (
funi
, 
suffix
, 
gs
)

	)

268 
	#__MATHDECL_VEC
(
ty
, 
funi
,
suffix
, 
gs
) \

269 
	`__SIMD_DECL
 (
	`__MATH_PRECNAME
 (
funi
, 
suffix
)) \

270 
	`__MATHDECL
(
ty
, 
funi
,
suffix
, 
gs
)

	)

272 
	#__MATHCALL
(
funi
,
suffix
, 
gs
) \

273 
	`__MATHDECL
 (
_Mdoub_
,
funi
,
suffix
, 
gs
)

	)

274 
	#__MATHDECL
(
ty
, 
funi
,
suffix
, 
gs
) \

275 
	`__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
); \

276 
	`__MATHDECL_1
(
ty
, 
	`__CONCAT
(
__
,
funi
),
suffix
, 
gs
)

	)

277 
	#__MATHCALLX
(
funi
,
suffix
, 
gs
, 
ib
) \

278 
	`__MATHDECLX
 (
_Mdoub_
,
funi
,
suffix
, 
gs
, 
ib
)

	)

279 
	#__MATHDECLX
(
ty
, 
funi
,
suffix
, 
gs
, 
ib
) \

280 
	`__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs

	`__ibu__
 (
ib
); \

281 
	`__MATHDECL_1
(
ty
, 
	`__CONCAT
(
__
,
funi
),
suffix
, 
gs

	`__ibu__
 (
ib
)

	)

282 
	#__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
) \

283 
ty
 
	`__MATH_PRECNAME
(
funi
,
suffix

gs
 
__THROW


	)

285 
	#_Mdoub_
 

	)

286 
	#__MATH_PRECNAME
(
me
,
r

	`__CONCAT
ame,r)

	)

287 
	#__MATH_DECLARING_DOUBLE
 1

	)

288 
	#__MATH_DECLARING_FLOATN
 0

	)

289 
	~<bs/mhs-hr-funis.h
>

290 
	~<bs/mhs.h
>

291 #unde
_Mdoub_


292 #unde
__MATH_PRECNAME


293 #unde
__MATH_DECLARING_DOUBLE


294 #unde
__MATH_DECLARING_FLOATN


296 #ifde
__USE_ISOC99


302 
	#_Mdoub_
 

	)

303 
	#__MATH_PRECNAME
(
me
,
r
me##
f
##
	)
r

304 
	#__MATH_DECLARING_DOUBLE
 0

	)

305 
	#__MATH_DECLARING_FLOATN
 0

	)

306 
	~<bs/mhs-hr-funis.h
>

307 
	~<bs/mhs.h
>

308 #unde
_Mdoub_


309 #unde
__MATH_PRECNAME


310 #unde
__MATH_DECLARING_DOUBLE


311 #unde
__MATH_DECLARING_FLOATN


313 #i!(
defed
 
__NO_LONG_DOUBLE_MATH
 && defed 
_LIBC
) \

314 || 
defed
 
__LDBL_COMPAT
 \

315 || 
defed
 
_LIBC_TEST


316 #ifde
__LDBL_COMPAT


318 #ifde
__USE_ISOC99


319 
	$__dbl_xowdf
 (
__x
, 
__y
)

320 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

321 #ifde
__REDIRECT_NTH


322 
	`__REDIRECT_NTH
 (
xowdf
, (
__x
, 
__y
),

323 
__dbl_xowdf
)

324 
	`__ibu__
 ((
__cڡ__
));

325 
	`__REDIRECT_NTH
 (
xowd
, (
__x
, 
__y
),

326 
x

	`__ibu__
 ((
__cڡ__
));

327 
	`__REDIRECT_NTH
 (
xowdl
,

328 (
__x
, 
__y
),

329 
x

	`__ibu__
 ((
__cڡ__
));

333 #unde
__MATHDECL_1


334 
	#__MATHDECL_2
(
ty
, 
funi
,
suffix
, 
gs
, 
s
) \

335 
ty
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
funi
,
suffix
), \

336 
gs
, 
s
)

	)

337 
	#__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
) \

338 
	`__MATHDECL_2
(
ty
, 
funi
,
suffix
, 
gs
, 
	`__CONCAT
(funi,suffix))

	)

344 
	#_Mdoub_
 

	)

345 
	#__MATH_PRECNAME
(
me
,
r
me##
l
##
	)
r

346 
	#__MATH_DECLARING_DOUBLE
 0

	)

347 
	#__MATH_DECLARING_FLOATN
 0

	)

348 
	#__MATH_DECLARE_LDOUBLE
 1

	)

349 
	~<bs/mhs-hr-funis.h
>

350 
	~<bs/mhs.h
>

351 #unde
_Mdoub_


352 #unde
__MATH_PRECNAME


353 #unde
__MATH_DECLARING_DOUBLE


354 #unde
__MATH_DECLARING_FLOATN


363 #i
__HAVE_DISTINCT_FLOAT16
 || (
__HAVE_FLOAT16
 && !
defed
 
_LIBC
)

364 
	#_Mdoub_
 
_Flt16


	)

365 
	#__MATH_PRECNAME
(
me
,
r
me##
f16
##
	)
r

366 
	#__MATH_DECLARING_DOUBLE
 0

	)

367 
	#__MATH_DECLARING_FLOATN
 1

	)

368 #i
__HAVE_DISTINCT_FLOAT16


369 
	~<bs/mhs-hr-funis.h
>

371 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

372 
	~<bs/mhs.h
>

374 #unde
_Mdoub_


375 #unde
__MATH_PRECNAME


376 #unde
__MATH_DECLARING_DOUBLE


377 #unde
__MATH_DECLARING_FLOATN


380 #i
__HAVE_DISTINCT_FLOAT32
 || (
__HAVE_FLOAT32
 && !
defed
 
_LIBC
)

381 
	#_Mdoub_
 
_Flt32


	)

382 
	#__MATH_PRECNAME
(
me
,
r
me##
f32
##
	)
r

383 
	#__MATH_DECLARING_DOUBLE
 0

	)

384 
	#__MATH_DECLARING_FLOATN
 1

	)

385 #i
__HAVE_DISTINCT_FLOAT32


386 
	~<bs/mhs-hr-funis.h
>

388 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

389 
	~<bs/mhs.h
>

391 #unde
_Mdoub_


392 #unde
__MATH_PRECNAME


393 #unde
__MATH_DECLARING_DOUBLE


394 #unde
__MATH_DECLARING_FLOATN


397 #i
__HAVE_DISTINCT_FLOAT64
 || (
__HAVE_FLOAT64
 && !
defed
 
_LIBC
)

398 
	#_Mdoub_
 
_Flt64


	)

399 
	#__MATH_PRECNAME
(
me
,
r
me##
f64
##
	)
r

400 
	#__MATH_DECLARING_DOUBLE
 0

	)

401 
	#__MATH_DECLARING_FLOATN
 1

	)

402 #i
__HAVE_DISTINCT_FLOAT64


403 
	~<bs/mhs-hr-funis.h
>

405 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

406 
	~<bs/mhs.h
>

408 #unde
_Mdoub_


409 #unde
__MATH_PRECNAME


410 #unde
__MATH_DECLARING_DOUBLE


411 #unde
__MATH_DECLARING_FLOATN


414 #i
__HAVE_DISTINCT_FLOAT128
 || (
__HAVE_FLOAT128
 && !
defed
 
_LIBC
)

415 
	#_Mdoub_
 
_Flt128


	)

416 
	#__MATH_PRECNAME
(
me
,
r
me##
f128
##
	)
r

417 
	#__MATH_DECLARING_DOUBLE
 0

	)

418 
	#__MATH_DECLARING_FLOATN
 1

	)

419 #i
__HAVE_DISTINCT_FLOAT128


420 
	~<bs/mhs-hr-funis.h
>

422 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

423 
	~<bs/mhs.h
>

425 #unde
_Mdoub_


426 #unde
__MATH_PRECNAME


427 #unde
__MATH_DECLARING_DOUBLE


428 #unde
__MATH_DECLARING_FLOATN


431 #i
__HAVE_DISTINCT_FLOAT32X
 || (
__HAVE_FLOAT32X
 && !
defed
 
_LIBC
)

432 
	#_Mdoub_
 
_Flt32x


	)

433 
	#__MATH_PRECNAME
(
me
,
r
me##
f32x
##
	)
r

434 
	#__MATH_DECLARING_DOUBLE
 0

	)

435 
	#__MATH_DECLARING_FLOATN
 1

	)

436 #i
__HAVE_DISTINCT_FLOAT32X


437 
	~<bs/mhs-hr-funis.h
>

439 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

440 
	~<bs/mhs.h
>

442 #unde
_Mdoub_


443 #unde
__MATH_PRECNAME


444 #unde
__MATH_DECLARING_DOUBLE


445 #unde
__MATH_DECLARING_FLOATN


448 #i
__HAVE_DISTINCT_FLOAT64X
 || (
__HAVE_FLOAT64X
 && !
defed
 
_LIBC
)

449 
	#_Mdoub_
 
_Flt64x


	)

450 
	#__MATH_PRECNAME
(
me
,
r
me##
f64x
##
	)
r

451 
	#__MATH_DECLARING_DOUBLE
 0

	)

452 
	#__MATH_DECLARING_FLOATN
 1

	)

453 #i
__HAVE_DISTINCT_FLOAT64X


454 
	~<bs/mhs-hr-funis.h
>

456 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

457 
	~<bs/mhs.h
>

459 #unde
_Mdoub_


460 #unde
__MATH_PRECNAME


461 #unde
__MATH_DECLARING_DOUBLE


462 #unde
__MATH_DECLARING_FLOATN


465 #i
__HAVE_DISTINCT_FLOAT128X
 || (
__HAVE_FLOAT128X
 && !
defed
 
_LIBC
)

466 
	#_Mdoub_
 
_Flt128x


	)

467 
	#__MATH_PRECNAME
(
me
,
r
me##
f128x
##
	)
r

468 
	#__MATH_DECLARING_DOUBLE
 0

	)

469 
	#__MATH_DECLARING_FLOATN
 1

	)

470 #i
__HAVE_DISTINCT_FLOAT128X


471 
	~<bs/mhs-hr-funis.h
>

473 #i
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

474 
	~<bs/mhs.h
>

476 #unde
_Mdoub_


477 #unde
__MATH_PRECNAME


478 #unde
__MATH_DECLARING_DOUBLE


479 #unde
__MATH_DECLARING_FLOATN


482 #unde
__MATHDECL_1


483 #unde
__MATHDECL


484 #unde
__MATHCALL


487 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


489 
signgam
;

492 #i(
__HAVE_DISTINCT_FLOAT16
 \

493 || 
__HAVE_DISTINCT_FLOAT32
 \

494 || 
__HAVE_DISTINCT_FLOAT64
 \

495 || 
__HAVE_DISTINCT_FLOAT32X
 \

496 || 
__HAVE_DISTINCT_FLOAT64X
 \

497 || 
__HAVE_DISTINCT_FLOAT128X
)

510 #ifde
__NO_LONG_DOUBLE_MATH


511 #i
__HAVE_DISTINCT_FLOAT128


514 
	#__MATH_TG
(
TG_ARG
, 
FUNC
, 
ARGS
) \

515 ( (
TG_ARG
= (? 
FUNC
 ## 
f
 
ARGS
 : FUNC ARGS)

	)

516 #i
__HAVE_DISTINCT_FLOAT128


517 #i
__HAVE_GENERIC_SELECTION


518 #i
__HAVE_FLOATN_NOT_TYPEDEF
 && 
__HAVE_FLOAT32


519 
	#__MATH_TG_F32
(
FUNC
, 
ARGS

_Flt32
: FUNC ## 
f
 ARGS,

	)

521 
	#__MATH_TG_F32
(
FUNC
, 
ARGS
)

	)

523 #i
__HAVE_FLOATN_NOT_TYPEDEF
 && 
__HAVE_FLOAT64X


524 #i
__HAVE_FLOAT64X_LONG_DOUBLE


525 
	#__MATH_TG_F64X
(
FUNC
, 
ARGS

_Flt64x
: FUNC ## 
l
 ARGS,

	)

527 
	#__MATH_TG_F64X
(
FUNC
, 
ARGS

_Flt64x
: FUNC ## 
f128
 ARGS,

	)

530 
	#__MATH_TG_F64X
(
FUNC
, 
ARGS
)

	)

532 
	#__MATH_TG
(
TG_ARG
, 
FUNC
, 
ARGS
) \

533 
	`_Gic
 ((
TG_ARG
), \

534 : 
FUNC
 ## 
f
 
ARGS
, \

535 
	`__MATH_TG_F32
 (
FUNC
, 
ARGS
) \

536 : 
FUNC
 
ARGS
, \

537 : 
FUNC
 ## 
l
 
ARGS
, \

538 
	`__MATH_TG_F64X
 (
FUNC
, 
ARGS
) \

539 
_Flt128
: 
FUNC
 ## 
f128
 
ARGS
)

	)

541 #i
__HAVE_FLOATN_NOT_TYPEDEF


544 
	#__MATH_TG
(
TG_ARG
, 
FUNC
, 
ARGS
) \

545 
__but_choo_ex
 \

546 (
	`__but_tys_comtib_p
 (
	`__tyof
 (
TG_ARG
), ), \

547 
FUNC
 ## 
f
 
ARGS
, \

548 
__but_choo_ex
 \

549 (
	`__but_tys_comtib_p
 (
	`__tyof
 (
TG_ARG
), ), \

550 
FUNC
 
ARGS
, \

551 
__but_choo_ex
 \

552 (
	`__but_tys_comtib_p
 (
	`__tyof
 (
TG_ARG
), ), \

553 
FUNC
 ## 
l
 
ARGS
, \

554 
FUNC
 ## 
f128
 
ARGS
)))

	)

557 
	#__MATH_TG
(
TG_ARG
, 
FUNC
, 
ARGS
) \

558 ( (
TG_ARG
) ==  () \

559 ? 
FUNC
 ## 
f
 
ARGS
 \

560 :  (
TG_ARG
) ==  () \

561 ? 
FUNC
 
ARGS
 \

562 : 
FUNC
 ## 
l
 
ARGS
)

	)

566 #ifde
__USE_ISOC99


571 
FP_NAN
 =

572 
	#FP_NAN
 0

	)

573 
FP_NAN
,

574 
FP_INFINITE
 =

575 
	#FP_INFINITE
 1

	)

576 
FP_INFINITE
,

577 
FP_ZERO
 =

578 
	#FP_ZERO
 2

	)

579 
FP_ZERO
,

580 
FP_SUBNORMAL
 =

581 
	#FP_SUBNORMAL
 3

	)

582 
FP_SUBNORMAL
,

583 
FP_NORMAL
 =

584 
	#FP_NORMAL
 4

	)

585 
FP_NORMAL


593 #i
	`__GNUC_PREREQ
 (4,4&& !
defed
 
__SUPPORT_SNAN__
 \

594 && (!
defed
 
__OPTIMIZE_SIZE__
 || defed 
__lulus
)

601 
	#assify
(
x

	`__but_assify
 (
FP_NAN
, 
FP_INFINITE
, \

602 
FP_NORMAL
, 
FP_SUBNORMAL
, 
FP_ZERO
, 
x
)

	)

604 
	#assify
(
x

	`__MATH_TG
 ((x), 
__assify
, (x))

	)

608 #i
	`__GNUC_PREREQ
 (6,0)

609 
	#signb
(
x

	`__but_signb
 (x)

	)

610 #i
defed
 
__lulus


618 
	#signb
(
x

	`__but_signbl
 (x)

	)

619 #i
	`__GNUC_PREREQ
 (4,0)

620 
	#signb
(
x

	`__MATH_TG
 ((x), 
__but_signb
, (x))

	)

622 
	#signb
(
x

	`__MATH_TG
 ((x), 
__signb
, (x))

	)

626 #i
	`__GNUC_PREREQ
 (4,4&& !
defed
 
__SUPPORT_SNAN__


627 
	#isfe
(
x

	`__but_isfe
 (x)

	)

629 
	#isfe
(
x

	`__MATH_TG
 ((x), 
__fe
, (x))

	)

633 #i
	`__GNUC_PREREQ
 (4,4&& !
defed
 
__SUPPORT_SNAN__


634 
	#im
(
x

	`__but_im
 (x)

	)

636 
	#im
(
x
(
	`assify
 (x=
FP_NORMAL
)

	)

641 #i
	`__GNUC_PREREQ
 (4,4&& !
defed
 
__SUPPORT_SNAN__


642 
	#i
(
x

	`__but_i
 (x)

	)

644 
	#i
(
x

	`__MATH_TG
 ((x), 
__i
, (x))

	)

648 #i
__HAVE_DISTINCT_FLOAT128
 && !
	`__GNUC_PREREQ
 (7,0) \

649 && !
defed
 
__SUPPORT_SNAN__
 && !defed 
__lulus


655 
	#isf
(
x
) \

656 (
	`__but_tys_comtib_p
 (
	`__tyof
 (
x
), 
_Flt128
) \

657 ? 
	`__isff128
 (
x
: 
	`__but_isf_sign
 (x))

	)

658 #i
	`__GNUC_PREREQ
 (4,4&& !
defed
 
__SUPPORT_SNAN__


659 
	#isf
(
x

	`__but_isf_sign
 (x)

	)

661 
	#isf
(
x

	`__MATH_TG
 ((x), 
__isf
, (x))

	)

665 
	#MATH_ERRNO
 1

	)

666 
	#MATH_ERREXCEPT
 2

	)

673 #ifde
__FAST_MATH__


674 
	#mh_rhdlg
 0

	)

675 #i
defed
 
__NO_MATH_ERRNO__


676 
	#mh_rhdlg
 (
MATH_ERREXCEPT
)

	)

678 
	#mh_rhdlg
 (
MATH_ERRNO
 | 
MATH_ERREXCEPT
)

	)

683 #i
	`__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

684 
	~<bs/isnil.h
>

687 #ide
__lulus


688 
	#issiglg
(
x

	`__MATH_TG
 ((x), 
__issiglg
, (x))

	)

697 
le
 
	`issiglg
 (
__v
{  
	`__issiglgf
 (__val); }

698 
le
 
	`issiglg
 (
__v
{  
	`__issiglg
 (__val); }

699 
le
 

700 
	`issiglg
 (
__v
)

702 #ifde
__NO_LONG_DOUBLE_MATH


703  
	`__issiglg
 (
__v
);

705  
	`__issiglgl
 (
__v
);

708 #i
__HAVE_DISTINCT_FLOAT128


709 
le
 
	`issiglg
 (
_Flt128
 
__v
{  
	`__issiglgf128
 (__val); }

711 
	}
}

715 
	#issubnm
(
x
(
	`assify
 (x=
FP_SUBNORMAL
)

	)

718 #ide
__lulus


719 #ifde
__SUPPORT_SNAN__


720 
	#iszo
(
x
(
	`assify
 (x=
FP_ZERO
)

	)

722 
	#iszo
(
x
(((
	`__tyof
 (x)(x)=0)

	)

726 #ifde
__SUPPORT_SNAN__


727 
le
 

728 
iszo
 (
__v
)

730  
__assifyf
 (
__v
=
FP_ZERO
;

732 
le
 

733 
iszo
 (
__v
)

735  
__assify
 (
__v
=
FP_ZERO
;

737 
le
 

738 
iszo
 (
__v
)

740 #ifde
__NO_LONG_DOUBLE_MATH


741  
__assify
 (
__v
=
FP_ZERO
;

743  
__assifyl
 (
__v
=
FP_ZERO
;

746 #i
__HAVE_DISTINCT_FLOAT128


747 
le
 

748 
iszo
 (
_Flt128
 
__v
)

750  
__assifyf128
 (
__v
=
FP_ZERO
;

754 
me
 <
ass
 
__T
> 
le
 
bo


755 
iszo
 (
__T
 
__v
)

757  
__v
 == 0;

764 #ifde
__USE_XOPEN


766 
	#MAXFLOAT
 3.40282347e+38F

	)

771 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


772 
	#M_E
 2.7182818284590452354

	)

773 
	#M_LOG2E
 1.4426950408889634074

	)

774 
	#M_LOG10E
 0.43429448190325182765

	)

775 
	#M_LN2
 0.69314718055994530942

	)

776 
	#M_LN10
 2.30258509299404568402

	)

777 
	#M_PI
 3.14159265358979323846

	)

778 
	#M_PI_2
 1.57079632679489661923

	)

779 
	#M_PI_4
 0.78539816339744830962

	)

780 
	#M_1_PI
 0.31830988618379067154

	)

781 
	#M_2_PI
 0.63661977236758134308

	)

782 
	#M_2_SQRTPI
 1.12837916709551257390

	)

783 
	#M_SQRT2
 1.41421356237309504880

	)

784 
	#M_SQRT1_2
 0.70710678118654752440

	)

790 #ifde
__USE_GNU


791 
	#M_El
 2.718281828459045235360287471352662498L

	)

792 
	#M_LOG2El
 1.442695040888963407359924681001892137L

	)

793 
	#M_LOG10El
 0.434294481903251827651128918916605082L

	)

794 
	#M_LN2l
 0.693147180559945309417232121458176568L

	)

795 
	#M_LN10l
 2.302585092994045684017991454684364208L

	)

796 
	#M_PIl
 3.141592653589793238462643383279502884L

	)

797 
	#M_PI_2l
 1.570796326794896619231321691639751442L

	)

798 
	#M_PI_4l
 0.785398163397448309615660845819875721L

	)

799 
	#M_1_PIl
 0.318309886183790671537767526745028724L

	)

800 
	#M_2_PIl
 0.636619772367581343075535053490057448L

	)

801 
	#M_2_SQRTPIl
 1.128379167095512573896158903121545172L

	)

802 
	#M_SQRT2l
 1.414213562373095048801688724209698079L

	)

803 
	#M_SQRT1_2l
 0.707106781186547524400844362104849039L

	)

806 #i
__HAVE_FLOAT16
 && 
defed
 
__USE_GNU


807 
	#M_Ef16
 
	`__f16
 (2.718281828459045235360287471352662498

	)

808 
	#M_LOG2Ef16
 
	`__f16
 (1.442695040888963407359924681001892137

	)

809 
	#M_LOG10Ef16
 
	`__f16
 (0.434294481903251827651128918916605082

	)

810 
	#M_LN2f16
 
	`__f16
 (0.693147180559945309417232121458176568

	)

811 
	#M_LN10f16
 
	`__f16
 (2.302585092994045684017991454684364208

	)

812 
	#M_PIf16
 
	`__f16
 (3.141592653589793238462643383279502884

	)

813 
	#M_PI_2f16
 
	`__f16
 (1.570796326794896619231321691639751442

	)

814 
	#M_PI_4f16
 
	`__f16
 (0.785398163397448309615660845819875721

	)

815 
	#M_1_PIf16
 
	`__f16
 (0.318309886183790671537767526745028724

	)

816 
	#M_2_PIf16
 
	`__f16
 (0.636619772367581343075535053490057448

	)

817 
	#M_2_SQRTPIf16
 
	`__f16
 (1.128379167095512573896158903121545172

	)

818 
	#M_SQRT2f16
 
	`__f16
 (1.414213562373095048801688724209698079

	)

819 
	#M_SQRT1_2f16
 
	`__f16
 (0.707106781186547524400844362104849039

	)

822 #i
__HAVE_FLOAT32
 && 
defed
 
__USE_GNU


823 
	#M_Ef32
 
	`__f32
 (2.718281828459045235360287471352662498

	)

824 
	#M_LOG2Ef32
 
	`__f32
 (1.442695040888963407359924681001892137

	)

825 
	#M_LOG10Ef32
 
	`__f32
 (0.434294481903251827651128918916605082

	)

826 
	#M_LN2f32
 
	`__f32
 (0.693147180559945309417232121458176568

	)

827 
	#M_LN10f32
 
	`__f32
 (2.302585092994045684017991454684364208

	)

828 
	#M_PIf32
 
	`__f32
 (3.141592653589793238462643383279502884

	)

829 
	#M_PI_2f32
 
	`__f32
 (1.570796326794896619231321691639751442

	)

830 
	#M_PI_4f32
 
	`__f32
 (0.785398163397448309615660845819875721

	)

831 
	#M_1_PIf32
 
	`__f32
 (0.318309886183790671537767526745028724

	)

832 
	#M_2_PIf32
 
	`__f32
 (0.636619772367581343075535053490057448

	)

833 
	#M_2_SQRTPIf32
 
	`__f32
 (1.128379167095512573896158903121545172

	)

834 
	#M_SQRT2f32
 
	`__f32
 (1.414213562373095048801688724209698079

	)

835 
	#M_SQRT1_2f32
 
	`__f32
 (0.707106781186547524400844362104849039

	)

838 #i
__HAVE_FLOAT64
 && 
defed
 
__USE_GNU


839 
	#M_Ef64
 
	`__f64
 (2.718281828459045235360287471352662498

	)

840 
	#M_LOG2Ef64
 
	`__f64
 (1.442695040888963407359924681001892137

	)

841 
	#M_LOG10Ef64
 
	`__f64
 (0.434294481903251827651128918916605082

	)

842 
	#M_LN2f64
 
	`__f64
 (0.693147180559945309417232121458176568

	)

843 
	#M_LN10f64
 
	`__f64
 (2.302585092994045684017991454684364208

	)

844 
	#M_PIf64
 
	`__f64
 (3.141592653589793238462643383279502884

	)

845 
	#M_PI_2f64
 
	`__f64
 (1.570796326794896619231321691639751442

	)

846 
	#M_PI_4f64
 
	`__f64
 (0.785398163397448309615660845819875721

	)

847 
	#M_1_PIf64
 
	`__f64
 (0.318309886183790671537767526745028724

	)

848 
	#M_2_PIf64
 
	`__f64
 (0.636619772367581343075535053490057448

	)

849 
	#M_2_SQRTPIf64
 
	`__f64
 (1.128379167095512573896158903121545172

	)

850 
	#M_SQRT2f64
 
	`__f64
 (1.414213562373095048801688724209698079

	)

851 
	#M_SQRT1_2f64
 
	`__f64
 (0.707106781186547524400844362104849039

	)

854 #i
__HAVE_FLOAT128
 && 
defed
 
__USE_GNU


855 
	#M_Ef128
 
	`__f128
 (2.718281828459045235360287471352662498

	)

856 
	#M_LOG2Ef128
 
	`__f128
 (1.442695040888963407359924681001892137

	)

857 
	#M_LOG10Ef128
 
	`__f128
 (0.434294481903251827651128918916605082

	)

858 
	#M_LN2f128
 
	`__f128
 (0.693147180559945309417232121458176568

	)

859 
	#M_LN10f128
 
	`__f128
 (2.302585092994045684017991454684364208

	)

860 
	#M_PIf128
 
	`__f128
 (3.141592653589793238462643383279502884

	)

861 
	#M_PI_2f128
 
	`__f128
 (1.570796326794896619231321691639751442

	)

862 
	#M_PI_4f128
 
	`__f128
 (0.785398163397448309615660845819875721

	)

863 
	#M_1_PIf128
 
	`__f128
 (0.318309886183790671537767526745028724

	)

864 
	#M_2_PIf128
 
	`__f128
 (0.636619772367581343075535053490057448

	)

865 
	#M_2_SQRTPIf128
 
	`__f128
 (1.128379167095512573896158903121545172

	)

866 
	#M_SQRT2f128
 
	`__f128
 (1.414213562373095048801688724209698079

	)

867 
	#M_SQRT1_2f128
 
	`__f128
 (0.707106781186547524400844362104849039

	)

870 #i
__HAVE_FLOAT32X
 && 
defed
 
__USE_GNU


871 
	#M_Ef32x
 
	`__f32x
 (2.718281828459045235360287471352662498

	)

872 
	#M_LOG2Ef32x
 
	`__f32x
 (1.442695040888963407359924681001892137

	)

873 
	#M_LOG10Ef32x
 
	`__f32x
 (0.434294481903251827651128918916605082

	)

874 
	#M_LN2f32x
 
	`__f32x
 (0.693147180559945309417232121458176568

	)

875 
	#M_LN10f32x
 
	`__f32x
 (2.302585092994045684017991454684364208

	)

876 
	#M_PIf32x
 
	`__f32x
 (3.141592653589793238462643383279502884

	)

877 
	#M_PI_2f32x
 
	`__f32x
 (1.570796326794896619231321691639751442

	)

878 
	#M_PI_4f32x
 
	`__f32x
 (0.785398163397448309615660845819875721

	)

879 
	#M_1_PIf32x
 
	`__f32x
 (0.318309886183790671537767526745028724

	)

880 
	#M_2_PIf32x
 
	`__f32x
 (0.636619772367581343075535053490057448

	)

881 
	#M_2_SQRTPIf32x
 
	`__f32x
 (1.128379167095512573896158903121545172

	)

882 
	#M_SQRT2f32x
 
	`__f32x
 (1.414213562373095048801688724209698079

	)

883 
	#M_SQRT1_2f32x
 
	`__f32x
 (0.707106781186547524400844362104849039

	)

886 #i
__HAVE_FLOAT64X
 && 
defed
 
__USE_GNU


887 
	#M_Ef64x
 
	`__f64x
 (2.718281828459045235360287471352662498

	)

888 
	#M_LOG2Ef64x
 
	`__f64x
 (1.442695040888963407359924681001892137

	)

889 
	#M_LOG10Ef64x
 
	`__f64x
 (0.434294481903251827651128918916605082

	)

890 
	#M_LN2f64x
 
	`__f64x
 (0.693147180559945309417232121458176568

	)

891 
	#M_LN10f64x
 
	`__f64x
 (2.302585092994045684017991454684364208

	)

892 
	#M_PIf64x
 
	`__f64x
 (3.141592653589793238462643383279502884

	)

893 
	#M_PI_2f64x
 
	`__f64x
 (1.570796326794896619231321691639751442

	)

894 
	#M_PI_4f64x
 
	`__f64x
 (0.785398163397448309615660845819875721

	)

895 
	#M_1_PIf64x
 
	`__f64x
 (0.318309886183790671537767526745028724

	)

896 
	#M_2_PIf64x
 
	`__f64x
 (0.636619772367581343075535053490057448

	)

897 
	#M_2_SQRTPIf64x
 
	`__f64x
 (1.128379167095512573896158903121545172

	)

898 
	#M_SQRT2f64x
 
	`__f64x
 (1.414213562373095048801688724209698079

	)

899 
	#M_SQRT1_2f64x
 
	`__f64x
 (0.707106781186547524400844362104849039

	)

902 #i
__HAVE_FLOAT128X
 && 
defed
 
__USE_GNU


909 #i
defed
 
__STRICT_ANSI__
 && !defed 
__NO_MATH_INLINES


910 
	#__NO_MATH_INLINES
 1

	)

913 #ifde
__USE_ISOC99


914 #i
__GNUC_PREREQ
 (3, 1)

921 
	#isg
(
x
, 
y

	`__but_isg
(x, y)

	)

922 
	#isgequ
(
x
, 
y

	`__but_isgequ
(x, y)

	)

923 
	#iess
(
x
, 
y

	`__but_iess
(x, y)

	)

924 
	#iesqu
(
x
, 
y

	`__but_iesqu
(x, y)

	)

925 
	#iessg
(
x
, 
y

	`__but_iessg
(x, y)

	)

926 
	#isunded
(
x
, 
y

	`__but_isunded
(x, y)

	)

928 
	#isg
(
x
, 
y
) \

929 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__x
 = (x); __tyof__ (
y

__y
 = (y); \

930 !
	`isunded
 (
__x
, 
__y
&& __x > __y; }))

	)

931 
	#isgequ
(
x
, 
y
) \

932 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__x
 = (x); __tyof__ (
y

__y
 = (y); \

933 !
	`isunded
 (
__x
, 
__y
&& __x >__y; }))

	)

934 
	#iess
(
x
, 
y
) \

935 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__x
 = (x); __tyof__ (
y

__y
 = (y); \

936 !
	`isunded
 (
__x
, 
__y
&& __x < __y; }))

	)

937 
	#iesqu
(
x
, 
y
) \

938 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__x
 = (x); __tyof__ (
y

__y
 = (y); \

939 !
	`isunded
 (
__x
, 
__y
&& __x <__y; }))

	)

940 
	#iessg
(
x
, 
y
) \

941 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__x
 = (x); __tyof__ (
y

__y
 = (y); \

942 !
	`isunded
 (
__x
, 
__y
&& __x !__y; }))

	)

944 
	#isunded
(
x
, 
y
) \

945 (
	`__exnsi__
 ({ 
	`__tyof__
 (
x

__u
 = (x); __tyof__ (
y

__v
 = (y); \

946 
__u
 !
__v
 && (__u !__u || __v !__v); }))

	)

951 #ifde
__USE_EXTERN_INLINES


952 
	~<bs/mhle.h
>

957 #i
defed
 
__FINITE_MATH_ONLY__
 && __FINITE_MATH_ONLY__ > 0

960 
	#_Mdoub_
 

	)

961 
	#__MATH_DECLARING_DOUBLE
 1

	)

962 
	#__MATH_DECLARING_FLOATN
 0

	)

963 
	#__REDIRFROM_X
(
funi
, 
t
) \

964 
funi
 ## 
t


	)

965 
	#__REDIRTO_X
(
funi
, 
t
) \

966 
__
 ## 
funi
 ## 
t
 ## 
_fe


	)

967 
	~<bs/mh-fe.h
>

968 #unde
_Mdoub_


969 #unde
__MATH_DECLARING_DOUBLE


970 #unde
__MATH_DECLARING_FLOATN


971 #unde
__REDIRFROM_X


972 #unde
__REDIRTO_X


976 #ifde
__USE_ISOC99


979 
	#_Mdoub_
 

	)

980 
	#__MATH_DECLARING_DOUBLE
 0

	)

981 
	#__MATH_DECLARING_FLOATN
 0

	)

982 
	#__REDIRFROM_X
(
funi
, 
t
) \

983 
funi
 ## 
f
 ## 
t


	)

984 
	#__REDIRTO_X
(
funi
, 
t
) \

985 
__
 ## 
funi
 ## 
f
 ## 
t
 ## 
_fe


	)

986 
	~<bs/mh-fe.h
>

987 #unde
_Mdoub_


988 #unde
__MATH_DECLARING_DOUBLE


989 #unde
__MATH_DECLARING_FLOATN


990 #unde
__REDIRFROM_X


991 #unde
__REDIRTO_X


994 #ifde
__MATH_DECLARE_LDOUBLE


995 
	#_Mdoub_
 

	)

996 
	#__MATH_DECLARING_DOUBLE
 0

	)

997 
	#__MATH_DECLARING_FLOATN
 0

	)

998 
	#__REDIRFROM_X
(
funi
, 
t
) \

999 
funi
 ## 
l
 ## 
t


	)

1000 #ifde
__NO_LONG_DOUBLE_MATH


1001 
	#__REDIRTO_X
(
funi
, 
t
) \

1002 
__
 ## 
funi
 ## 
t
 ## 
_fe


	)

1004 
	#__REDIRTO_X
(
funi
, 
t
) \

1005 
__
 ## 
funi
 ## 
l
 ## 
t
 ## 
_fe


	)

1007 
	~<bs/mh-fe.h
>

1008 #unde
_Mdoub_


1009 #unde
__MATH_DECLARING_DOUBLE


1010 #unde
__MATH_DECLARING_FLOATN


1011 #unde
__REDIRFROM_X


1012 #unde
__REDIRTO_X


1019 #i(
__HAVE_DISTINCT_FLOAT16
 || (
__HAVE_FLOAT16
 && !
defed
 
_LIBC
)) \

1020 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1021 
	#_Mdoub_
 
_Flt16


	)

1022 
	#__MATH_DECLARING_DOUBLE
 0

	)

1023 
	#__MATH_DECLARING_FLOATN
 1

	)

1024 
	#__REDIRFROM_X
(
funi
, 
t
) \

1025 
funi
 ## 
f16
 ## 
t


	)

1026 #i
__HAVE_DISTINCT_FLOAT16


1027 
	#__REDIRTO_X
(
funi
, 
t
) \

1028 
__
 ## 
funi
 ## 
f16
 ## 
t
 ## 
_fe


	)

1032 
	~<bs/mh-fe.h
>

1033 #unde
_Mdoub_


1034 #unde
__MATH_DECLARING_DOUBLE


1035 #unde
__MATH_DECLARING_FLOATN


1036 #unde
__REDIRFROM_X


1037 #unde
__REDIRTO_X


1040 #i(
__HAVE_DISTINCT_FLOAT32
 || (
__HAVE_FLOAT32
 && !
defed
 
_LIBC
)) \

1041 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1042 
	#_Mdoub_
 
_Flt32


	)

1043 
	#__MATH_DECLARING_DOUBLE
 0

	)

1044 
	#__MATH_DECLARING_FLOATN
 1

	)

1045 
	#__REDIRFROM_X
(
funi
, 
t
) \

1046 
funi
 ## 
f32
 ## 
t


	)

1047 #i
__HAVE_DISTINCT_FLOAT32


1048 
	#__REDIRTO_X
(
funi
, 
t
) \

1049 
__
 ## 
funi
 ## 
f32
 ## 
t
 ## 
_fe


	)

1051 
	#__REDIRTO_X
(
funi
, 
t
) \

1052 
__
 ## 
funi
 ## 
f
 ## 
t
 ## 
_fe


	)

1054 
	~<bs/mh-fe.h
>

1055 #unde
_Mdoub_


1056 #unde
__MATH_DECLARING_DOUBLE


1057 #unde
__MATH_DECLARING_FLOATN


1058 #unde
__REDIRFROM_X


1059 #unde
__REDIRTO_X


1062 #i(
__HAVE_DISTINCT_FLOAT64
 || (
__HAVE_FLOAT64
 && !
defed
 
_LIBC
)) \

1063 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1064 
	#_Mdoub_
 
_Flt64


	)

1065 
	#__MATH_DECLARING_DOUBLE
 0

	)

1066 
	#__MATH_DECLARING_FLOATN
 1

	)

1067 
	#__REDIRFROM_X
(
funi
, 
t
) \

1068 
funi
 ## 
f64
 ## 
t


	)

1069 #i
__HAVE_DISTINCT_FLOAT64


1070 
	#__REDIRTO_X
(
funi
, 
t
) \

1071 
__
 ## 
funi
 ## 
f64
 ## 
t
 ## 
_fe


	)

1073 
	#__REDIRTO_X
(
funi
, 
t
) \

1074 
__
 ## 
funi
 ## 
t
 ## 
_fe


	)

1076 
	~<bs/mh-fe.h
>

1077 #unde
_Mdoub_


1078 #unde
__MATH_DECLARING_DOUBLE


1079 #unde
__MATH_DECLARING_FLOATN


1080 #unde
__REDIRFROM_X


1081 #unde
__REDIRTO_X


1084 #i(
__HAVE_DISTINCT_FLOAT128
 || (
__HAVE_FLOAT128
 && !
defed
 
_LIBC
)) \

1085 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1086 
	#_Mdoub_
 
_Flt128


	)

1087 
	#__MATH_DECLARING_DOUBLE
 0

	)

1088 
	#__MATH_DECLARING_FLOATN
 1

	)

1089 
	#__REDIRFROM_X
(
funi
, 
t
) \

1090 
funi
 ## 
f128
 ## 
t


	)

1091 #i
__HAVE_DISTINCT_FLOAT128


1092 
	#__REDIRTO_X
(
funi
, 
t
) \

1093 
__
 ## 
funi
 ## 
f128
 ## 
t
 ## 
_fe


	)

1095 
	#__REDIRTO_X
(
funi
, 
t
) \

1096 
__
 ## 
funi
 ## 
l
 ## 
t
 ## 
_fe


	)

1098 
	~<bs/mh-fe.h
>

1099 #unde
_Mdoub_


1100 #unde
__MATH_DECLARING_DOUBLE


1101 #unde
__MATH_DECLARING_FLOATN


1102 #unde
__REDIRFROM_X


1103 #unde
__REDIRTO_X


1106 #i(
__HAVE_DISTINCT_FLOAT32X
 || (
__HAVE_FLOAT32X
 && !
defed
 
_LIBC
)) \

1107 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1108 
	#_Mdoub_
 
_Flt32x


	)

1109 
	#__MATH_DECLARING_DOUBLE
 0

	)

1110 
	#__MATH_DECLARING_FLOATN
 1

	)

1111 
	#__REDIRFROM_X
(
funi
, 
t
) \

1112 
funi
 ## 
f32x
 ## 
t


	)

1113 #i
__HAVE_DISTINCT_FLOAT32X


1114 
	#__REDIRTO_X
(
funi
, 
t
) \

1115 
__
 ## 
funi
 ## 
f32x
 ## 
t
 ## 
_fe


	)

1117 
	#__REDIRTO_X
(
funi
, 
t
) \

1118 
__
 ## 
funi
 ## 
t
 ## 
_fe


	)

1120 
	~<bs/mh-fe.h
>

1121 #unde
_Mdoub_


1122 #unde
__MATH_DECLARING_DOUBLE


1123 #unde
__MATH_DECLARING_FLOATN


1124 #unde
__REDIRFROM_X


1125 #unde
__REDIRTO_X


1128 #i(
__HAVE_DISTINCT_FLOAT64X
 || (
__HAVE_FLOAT64X
 && !
defed
 
_LIBC
)) \

1129 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1130 
	#_Mdoub_
 
_Flt64x


	)

1131 
	#__MATH_DECLARING_DOUBLE
 0

	)

1132 
	#__MATH_DECLARING_FLOATN
 1

	)

1133 
	#__REDIRFROM_X
(
funi
, 
t
) \

1134 
funi
 ## 
f64x
 ## 
t


	)

1135 #i
__HAVE_DISTINCT_FLOAT64X


1136 
	#__REDIRTO_X
(
funi
, 
t
) \

1137 
__
 ## 
funi
 ## 
f64x
 ## 
t
 ## 
_fe


	)

1138 #i
__HAVE_FLOAT64X_LONG_DOUBLE


1139 
	#__REDIRTO_X
(
funi
, 
t
) \

1140 
__
 ## 
funi
 ## 
l
 ## 
t
 ## 
_fe


	)

1142 
	#__REDIRTO_X
(
funi
, 
t
) \

1143 
__
 ## 
funi
 ## 
f128
 ## 
t
 ## 
_fe


	)

1145 
	~<bs/mh-fe.h
>

1146 #unde
_Mdoub_


1147 #unde
__MATH_DECLARING_DOUBLE


1148 #unde
__MATH_DECLARING_FLOATN


1149 #unde
__REDIRFROM_X


1150 #unde
__REDIRTO_X


1153 #i(
__HAVE_DISTINCT_FLOAT128X
 || (
__HAVE_FLOAT128X
 && !
defed
 
_LIBC
)) \

1154 && 
	$__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

1155 
	#_Mdoub_
 
_Flt128x


	)

1156 
	#__MATH_DECLARING_DOUBLE
 0

	)

1157 
	#__MATH_DECLARING_FLOATN
 1

	)

1158 
	#__REDIRFROM_X
(
funi
, 
t
) \

1159 
funi
 ## 
f128x
 ## 
t


	)

1160 #i
__HAVE_DISTINCT_FLOAT128X


1161 
	#__REDIRTO_X
(
funi
, 
t
) \

1162 
__
 ## 
funi
 ## 
f128x
 ## 
t
 ## 
_fe


	)

1166 
	~<bs/mh-fe.h
>

1167 #unde
_Mdoub_


1168 #unde
__MATH_DECLARING_DOUBLE


1169 #unde
__MATH_DECLARING_FLOATN


1170 #unde
__REDIRFROM_X


1171 #unde
__REDIRTO_X


1176 #i
	`__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

1179 #i
__FLT_EVAL_METHOD__
 == 2 || __FLT_EVAL_METHOD__ > 64

1180 
	#__MATH_EVAL_FMT2
(
x
, 
y
((x+ (y+ 0.0L)

	)

1181 #i
__FLT_EVAL_METHOD__
 == 1 || __FLT_EVAL_METHOD__ > 32

1182 
	#__MATH_EVAL_FMT2
(
x
, 
y
((x+ (y+ 0.0)

	)

1183 #i
__FLT_EVAL_METHOD__
 == 0 || __FLT_EVAL_METHOD__ == 32

1184 
	#__MATH_EVAL_FMT2
(
x
, 
y
((x+ (y+ 0.0f)

	)

1186 
	#__MATH_EVAL_FMT2
(
x
, 
y
((x+ (y))

	)

1191 #i!
defed
 
__lulus
 || (__lulu< 201103L && !defed 
__GNUC__
)

1192 
	#iqsig
(
x
, 
y
) \

1193 
	`__MATH_TG
 (
	`__MATH_EVAL_FMT2
 (
x
, 
y
), 
__iqsig
, ((x), (y)))

	)

1206 
me
<
tyme
> 
__iqsig_ty
;

1208 
me
<> 
__iqsig_ty
<>

1210 
	`__
 (
__x
, 
__y

	`throw
 ()

1212  
	`__iqsigf
 (
__x
, 
__y
);

1216 
me
<> 
__iqsig_ty
<>

1218 
	`__
 (
__x
, 
__y

	`throw
 ()

1220  
	`__iqsig
 (
__x
, 
__y
);

1224 
me
<> 
__iqsig_ty
<>

1226 
	`__
 (
__x
, 
__y

	`throw
 ()

1228 #ide
__NO_LONG_DOUBLE_MATH


1229  
	`__iqsigl
 (
__x
, 
__y
);

1231  
	`__iqsig
 (
__x
, 
__y
);

1236 #i
__HAVE_DISTINCT_FLOAT128


1237 
me
<> 
__iqsig_ty
<
_Flt128
>

1239 
	`__
 (
_Flt128
 
__x
, _Flt128 
__y

	`throw
 ()

1241  
	`__iqsigf128
 (
__x
, 
__y
);

1246 
me
<
tyme
 
_T1
,ym
_T2
>

1247 
le
 

1248 
	`iqsig
 (
_T1
 
__x
, 
_T2
 
__y

	`throw
 ()

1250 #i
__lulus
 >= 201103L

1251 
	`dety
 (
	t__MATH_EVAL_FMT2
 (
	t__x
, 
	t__y
)
	t_T3
;

1253 
	`__tyof
 (
	t__MATH_EVAL_FMT2
 (
	t__x
, 
	t__y
)
	t_T3
;

1255  
__iqsig_ty
<
_T3
>::
	`__
 (
__x
, 
__y
);

1258 
	}
}

1263 
__END_DECLS


	@/usr/include/stdio.h

23 #ide
_STDIO_H


24 
	#_STDIO_H
 1

	)

26 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

27 
	~<bs/libc-hd-t.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	~<bs/tys.h
>

36 
	~<bs/tys/__FILE.h
>

37 
	~<bs/tys/FILE.h
>

39 
	#_STDIO_USES_IOSTREAM


	)

41 
	~<bs/libio.h
>

43 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


44 #ifde
__GNUC__


45 #ide
_VA_LIST_DEFINED


46 
_G_va_li
 
	tva_li
;

47 
	#_VA_LIST_DEFINED


	)

50 
	~<dg.h
>

54 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


55 #ide
__off_t_defed


56 #ide
__USE_FILE_OFFSET64


57 
__off_t
 
	toff_t
;

59 
__off64_t
 
	toff_t
;

61 
	#__off_t_defed


	)

63 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


64 
__off64_t
 
	toff64_t
;

65 
	#__off64_t_defed


	)

69 #ifde
__USE_XOPEN2K8


70 #ide
__ssize_t_defed


71 
__ssize_t
 
	tssize_t
;

72 
	#__ssize_t_defed


	)

77 #ide
__USE_FILE_OFFSET64


78 
_G_os_t
 
	tos_t
;

80 
_G_os64_t
 
	tos_t
;

82 #ifde
__USE_LARGEFILE64


83 
_G_os64_t
 
	tos64_t
;

87 
	#_IOFBF
 0

	)

88 
	#_IOLBF
 1

	)

89 
	#_IONBF
 2

	)

93 #ide
BUFSIZ


94 
	#BUFSIZ
 
_IO_BUFSIZ


	)

100 #ide
EOF


101 
	#EOF
 (-1)

	)

107 
	#SEEK_SET
 0

	)

108 
	#SEEK_CUR
 1

	)

109 
	#SEEK_END
 2

	)

110 #ifde
__USE_GNU


111 
	#SEEK_DATA
 3

	)

112 
	#SEEK_HOLE
 4

	)

116 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


118 
	#P_tmpd
 "/tmp"

	)

131 
	~<bs/dio_lim.h
>

135 
_IO_FILE
 *
d
;

136 
_IO_FILE
 *
dout
;

137 
_IO_FILE
 *
dr
;

139 
	#d
 
d


	)

140 
	#dout
 
dout


	)

141 
	#dr
 
dr


	)

144 
	$move
 (cڡ *
__fame

__THROW
;

146 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

148 #ifde
__USE_ATFILE


150 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

151 cڡ *
__w

__THROW
;

158 #ide
__USE_FILE_OFFSET64


159 
FILE
 *
	$tmpfe
 (
__wur
;

161 #ifde
__REDIRECT


162 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

164 
	#tmpfe
 
tmpfe64


	)

168 #ifde
__USE_LARGEFILE64


169 
FILE
 *
	$tmpfe64
 (
__wur
;

173 *
	$tmam
 (*
__s

__THROW
 
__wur
;

175 #ifde
__USE_MISC


178 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

182 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


190 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

191 
__THROW
 
__ibu_mloc__
 
__wur
;

199 
	`fo
 (
FILE
 *
__am
);

204 
	`fush
 (
FILE
 *
__am
);

206 #ifde
__USE_MISC


213 
	`fush_uocked
 (
FILE
 *
__am
);

216 #ifde
__USE_GNU


223 
	`fol
 ();

227 #ide
__USE_FILE_OFFSET64


232 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

233 cڡ *
__ri
 
__modes

__wur
;

238 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

239 cڡ *
__ri
 
__modes
,

240 
FILE
 *
__ri
 
__am

__wur
;

242 #ifde
__REDIRECT


243 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

244 cڡ *
__ri
 
__modes
), 
fݒ64
)

245 
__wur
;

246 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

247 cڡ *
__ri
 
__modes
,

248 
FILE
 *
__ri
 
__am
), 
eݒ64
)

249 
__wur
;

251 
	#fݒ
 
fݒ64


	)

252 
	#eݒ
 
eݒ64


	)

255 #ifde
__USE_LARGEFILE64


256 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

257 cڡ *
__ri
 
__modes

__wur
;

258 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

259 cڡ *
__ri
 
__modes
,

260 
FILE
 *
__ri
 
__am

__wur
;

263 #ifdef 
__USE_POSIX


265 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

268 #ifdef 
__USE_GNU


271 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

272 cڡ *
__ri
 
__modes
,

273 
_IO_cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

276 #i
defed
 
__USE_XOPEN2K8
 || 
	`__GLIBC_USE
 (
LIB_EXT2
)

278 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

279 
__THROW
 
__wur
;

284 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

290 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

294 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

295 
__modes
, 
size_t
 
__n

__THROW
;

297 #ifdef 
__USE_MISC


300 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

301 
size_t
 
__size

__THROW
;

304 
	$ebuf
 (
FILE
 *
__am

__THROW
;

312 
	`rtf
 (
FILE
 *
__ri
 
__am
,

313 cڡ *
__ri
 
__fm
, ...);

318 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

320 
	$rtf
 (*
__ri
 
__s
,

321 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

327 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

328 
_G_va_li
 
__g
);

333 
	`vtf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
);

335 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

336 
_G_va_li
 
__g

__THROWNL
;

338 #i
defed
 
__USE_ISOC99
 || defed 
__USE_UNIX98


340 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

341 cڡ *
__ri
 
__fm
, ...)

342 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

344 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

345 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

346 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

349 #i
	`__GLIBC_USE
 (
LIB_EXT2
)

352 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

353 
_G_va_li
 
__g
)

354 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

355 
	$__artf
 (**
__ri
 
__r
,

356 cڡ *
__ri
 
__fmt
, ...)

357 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

358 
	$artf
 (**
__ri
 
__r
,

359 cڡ *
__ri
 
__fmt
, ...)

360 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

363 #ifde
__USE_XOPEN2K8


365 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

366 
_G_va_li
 
__g
)

367 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

368 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

369 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

377 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

378 cڡ *
__ri
 
__fm
, ...
__wur
;

383 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

385 
	$ssnf
 (cڡ *
__ri
 
__s
,

386 cڡ *
__ri
 
__fm
, ...
__THROW
;

388 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

389 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

390 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

391 #ifde
__REDIRECT


395 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

396 cڡ *
__ri
 
__fm
, ...),

397 
__isoc99_fsnf

__wur
;

398 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

399 
__isoc99_snf

__wur
;

400 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

401 cڡ *
__ri
 
__fm
, ...),

402 
__isoc99_ssnf
);

404 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

405 cڡ *
__ri
 
__fm
, ...
__wur
;

406 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

407 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

408 cڡ *
__ri
 
__fm
, ...
__THROW
;

409 
	#fsnf
 
__isoc99_fsnf


	)

410 
	#snf
 
__isoc99_snf


	)

411 
	#ssnf
 
__isoc99_ssnf


	)

415 #ifdef 
__USE_ISOC99


420 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

421 
_G_va_li
 
__g
)

422 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

428 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

429 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

432 
	$vssnf
 (cڡ *
__ri
 
__s
,

433 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

434 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

436 #i!
defed
 
__USE_GNU
 \

437 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

438 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

439 #ifde
__REDIRECT


443 
	`__REDIRECT
 (
vfsnf
,

444 (
FILE
 *
__ri
 
__s
,

445 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
),

446 
__isoc99_vfsnf
)

447 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

448 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

449 
_G_va_li
 
__g
), 
__isoc99_vsnf
)

450 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

451 
	`__REDIRECT_NTH
 (
vssnf
,

452 (cڡ *
__ri
 
__s
,

453 cڡ *
__ri
 
__fm
,

454 
_G_va_li
 
__g
), 
__isoc99_vssnf
)

455 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

457 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

458 cڡ *
__ri
 
__fm
,

459 
_G_va_li
 
__g

__wur
;

460 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

461 
_G_va_li
 
__g

__wur
;

462 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

463 cڡ *
__ri
 
__fm
,

464 
_G_va_li
 
__g

__THROW
;

465 
	#vfsnf
 
__isoc99_vfsnf


	)

466 
	#vsnf
 
__isoc99_vsnf


	)

467 
	#vssnf
 
__isoc99_vssnf


	)

477 
	`fgc
 (
FILE
 *
__am
);

478 
	`gc
 (
FILE
 *
__am
);

484 
	`gch
 ();

488 
	#gc
(
_

	`_IO_gc
 (_)

	)

490 #ifde
__USE_POSIX199506


495 
	`gc_uocked
 (
FILE
 *
__am
);

496 
	`gch_uocked
 ();

499 #ifde
__USE_MISC


506 
	`fgc_uocked
 (
FILE
 *
__am
);

517 
	`utc
 (
__c
, 
FILE
 *
__am
);

518 
	`putc
 (
__c
, 
FILE
 *
__am
);

524 
	`putch
 (
__c
);

528 
	#putc
(
_ch
, 
_

	`_IO_putc
 (_ch, _)

	)

530 #ifde
__USE_MISC


537 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

540 #ifde
__USE_POSIX199506


545 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

546 
	`putch_uocked
 (
__c
);

550 #i
defed
 
__USE_MISC
 \

551 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

553 
	`gw
 (
FILE
 *
__am
);

556 
	`putw
 (
__w
, 
FILE
 *
__am
);

564 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

565 
__wur
;

567 #i
	`__GLIBC_USE
 (
DEPRECATED_GETS
)

577 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

580 #ifde
__USE_GNU


587 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

588 
FILE
 *
__ri
 
__am

__wur
;

592 #i
defed
 
__USE_XOPEN2K8
 || 
	`__GLIBC_USE
 (
LIB_EXT2
)

603 
_IO_ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

604 
size_t
 *
__ri
 
__n
, 
__dim
,

605 
FILE
 *
__ri
 
__am

__wur
;

606 
_IO_ssize_t
 
	$gdim
 (**
__ri
 
__l
,

607 
size_t
 *
__ri
 
__n
, 
__dim
,

608 
FILE
 *
__ri
 
__am

__wur
;

616 
_IO_ssize_t
 
	$gle
 (**
__ri
 
__l
,

617 
size_t
 *
__ri
 
__n
,

618 
FILE
 *
__ri
 
__am

__wur
;

626 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

632 
	`puts
 (cڡ *
__s
);

639 
	`ungc
 (
__c
, 
FILE
 *
__am
);

646 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

647 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

652 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

653 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

655 #ifde
__USE_GNU


662 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

663 
FILE
 *
__ri
 
__am
);

666 #ifde
__USE_MISC


673 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

674 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

675 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

676 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

684 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

689 
	$l
 (
FILE
 *
__am

__wur
;

694 
	`wd
 (
FILE
 *
__am
);

701 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


702 #ide
__USE_FILE_OFFSET64


707 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

712 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

714 #ifde
__REDIRECT


715 
	`__REDIRECT
 (
feko
,

716 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

717 
feko64
);

718 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

720 
	#feko
 
feko64


	)

721 
	#lo
 
lo64


	)

726 #ide
__USE_FILE_OFFSET64


731 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

736 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

738 #ifde
__REDIRECT


739 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

740 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

741 
	`__REDIRECT
 (
fos
,

742 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

744 
	#fgpos
 
fgpos64


	)

745 
	#fos
 
fos64


	)

749 #ifde
__USE_LARGEFILE64


750 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

751 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

752 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

753 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

757 
	$
 (
FILE
 *
__am

__THROW
;

759 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

761 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

763 #ifde
__USE_MISC


765 
	$_uocked
 (
FILE
 *
__am

__THROW
;

766 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

767 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

775 
	`
 (cڡ *
__s
);

781 
	~<bs/sys_i.h
>

784 #ifdef 
__USE_POSIX


786 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

789 #ifde
__USE_MISC


791 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

795 #ifde
__USE_POSIX2


800 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

806 
	`po
 (
FILE
 *
__am
);

810 #ifdef 
__USE_POSIX


812 *
	$mid
 (*
__s

__THROW
;

816 #i(
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
|| defed 
__USE_GNU


818 *
	`curid
 (*
__s
);

822 #ifdef 
__USE_GNU


823 
oback
;

826 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

827 cڡ *
__ri
 
__fm
, ...)

828 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

829 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

830 cڡ *
__ri
 
__fm
,

831 
_G_va_li
 
__gs
)

832 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

836 #ifde
__USE_POSIX199506


840 
	$ockfe
 (
FILE
 *
__am

__THROW
;

844 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

847 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

850 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


853 
	~<bs/gt_posix.h
>

858 #ifde
__USE_EXTERN_INLINES


859 
	~<bs/dio.h
>

861 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


862 
	~<bs/dio2.h
>

864 #ifde
__LDBL_COMPAT


865 
	~<bs/dio-ldbl.h
>

868 
__END_DECLS


	@/usr/include/stdlib.h

22 #idef 
_STDLIB_H


24 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

25 
	~<bs/libc-hd-t.h
>

28 
	#__ed_size_t


	)

29 
	#__ed_wch_t


	)

30 
	#__ed_NULL


	)

31 
	~<ddef.h
>

33 
	g__BEGIN_DECLS


35 
	#_STDLIB_H
 1

	)

37 #i(
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
&& !defed 
_SYS_WAIT_H


39 
	~<bs/waags.h
>

40 
	~<bs/waus.h
>

43 
	#WEXITSTATUS
(
us

	`__WEXITSTATUS
 (us)

	)

44 
	#WTERMSIG
(
us

	`__WTERMSIG
 (us)

	)

45 
	#WSTOPSIG
(
us

	`__WSTOPSIG
 (us)

	)

46 
	#WIFEXITED
(
us

	`__WIFEXITED
 (us)

	)

47 
	#WIFSIGNALED
(
us

	`__WIFSIGNALED
 (us)

	)

48 
	#WIFSTOPPED
(
us

	`__WIFSTOPPED
 (us)

	)

49 #ifde
__WIFCONTINUED


50 
	#WIFCONTINUED
(
us

	`__WIFCONTINUED
 (us)

	)

55 
	~<bs/ߊ.h
>

60 
	mqu
;

61 
	mm
;

62 } 
	tdiv_t
;

65 #ide
__ldiv_t_defed


68 
	mqu
;

69 
	mm
;

70 } 
	tldiv_t
;

71 
	#__ldiv_t_defed
 1

	)

74 #i
defed
 
__USE_ISOC99
 && !defed 
__div_t_defed


76 
__exnsi__
 struct

78 
	mqu
;

79 
	mm
;

80 } 
	tdiv_t
;

81 
	#__div_t_defed
 1

	)

86 
	#RAND_MAX
 2147483647

	)

91 
	#EXIT_FAILURE
 1

	)

92 
	#EXIT_SUCCESS
 0

	)

96 
	#MB_CUR_MAX
 (
	`__y_g_mb_cur_max
 ())

	)

97 
size_t
 
	$__y_g_mb_cur_max
 (
__THROW
 
__wur
;

101 
	$of
 (cڡ *
__Ō
)

102 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

104 
	$oi
 (cڡ *
__Ō
)

105 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

107 
	$
 (cڡ *
__Ō
)

108 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

110 #ifde
__USE_ISOC99


112 
__exnsi__
 
	$l
 (cڡ *
__Ō
)

113 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

117 
	$od
 (cڡ *
__ri
 
__Ō
,

118 **
__ri
 
__dr
)

119 
__THROW
 
	`__nnu
 ((1));

121 #ifdef 
__USE_ISOC99


123 
	$of
 (cڡ *
__ri
 
__Ō
,

124 **
__ri
 
__dr

__THROW
 
	`__nnu
 ((1));

126 
	$d
 (cڡ *
__ri
 
__Ō
,

127 **
__ri
 
__dr
)

128 
__THROW
 
	`__nnu
 ((1));

133 #i
__HAVE_FLOAT16
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

134 
_Flt16
 
	$of16
 (cڡ *
__ri
 
__Ō
,

135 **
__ri
 
__dr
)

136 
__THROW
 
	`__nnu
 ((1));

139 #i
__HAVE_FLOAT32
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

140 
_Flt32
 
	$of32
 (cڡ *
__ri
 
__Ō
,

141 **
__ri
 
__dr
)

142 
__THROW
 
	`__nnu
 ((1));

145 #i
__HAVE_FLOAT64
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

146 
_Flt64
 
	$of64
 (cڡ *
__ri
 
__Ō
,

147 **
__ri
 
__dr
)

148 
__THROW
 
	`__nnu
 ((1));

151 #i
__HAVE_FLOAT128
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

152 
_Flt128
 
	$of128
 (cڡ *
__ri
 
__Ō
,

153 **
__ri
 
__dr
)

154 
__THROW
 
	`__nnu
 ((1));

157 #i
__HAVE_FLOAT32X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

158 
_Flt32x
 
	$of32x
 (cڡ *
__ri
 
__Ō
,

159 **
__ri
 
__dr
)

160 
__THROW
 
	`__nnu
 ((1));

163 #i
__HAVE_FLOAT64X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

164 
_Flt64x
 
	$of64x
 (cڡ *
__ri
 
__Ō
,

165 **
__ri
 
__dr
)

166 
__THROW
 
	`__nnu
 ((1));

169 #i
__HAVE_FLOAT128X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

170 
_Flt128x
 
	$of128x
 (cڡ *
__ri
 
__Ō
,

171 **
__ri
 
__dr
)

172 
__THROW
 
	`__nnu
 ((1));

176 
	$
 (cڡ *
__ri
 
__Ō
,

177 **
__ri
 
__dr
, 
__ba
)

178 
__THROW
 
	`__nnu
 ((1));

180 
	$oul
 (cڡ *
__ri
 
__Ō
,

181 **
__ri
 
__dr
, 
__ba
)

182 
__THROW
 
	`__nnu
 ((1));

184 #ifde
__USE_MISC


186 
__exnsi__


187 
	$oq
 (cڡ *
__ri
 
__Ō
,

188 **
__ri
 
__dr
, 
__ba
)

189 
__THROW
 
	`__nnu
 ((1));

191 
__exnsi__


192 
	$ouq
 (cڡ *
__ri
 
__Ō
,

193 **
__ri
 
__dr
, 
__ba
)

194 
__THROW
 
	`__nnu
 ((1));

197 #ifde
__USE_ISOC99


199 
__exnsi__


200 
	$l
 (cڡ *
__ri
 
__Ō
,

201 **
__ri
 
__dr
, 
__ba
)

202 
__THROW
 
	`__nnu
 ((1));

204 
__exnsi__


205 
	$ou
 (cڡ *
__ri
 
__Ō
,

206 **
__ri
 
__dr
, 
__ba
)

207 
__THROW
 
	`__nnu
 ((1));

211 #i
	`__GLIBC_USE
 (
IEC_60559_BFP_EXT
)

212 
	$romd
 (*
__de
, 
size_t
 
__size
, cڡ *
__fm
,

213 
__f
)

214 
__THROW
 
	`__nnu
 ((3));

216 
	$romf
 (*
__de
, 
size_t
 
__size
, cڡ *
__fm
,

217 
__f
)

218 
__THROW
 
	`__nnu
 ((3));

220 
	$roml
 (*
__de
, 
size_t
 
__size
, cڡ *
__fm
,

221 
__f
)

222 
__THROW
 
	`__nnu
 ((3));

225 #i
__HAVE_FLOAT16
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

226 
	$romf16
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

227 
_Flt16
 
__f
)

228 
__THROW
 
	`__nnu
 ((3));

231 #i
__HAVE_FLOAT32
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

232 
	$romf32
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

233 
_Flt32
 
__f
)

234 
__THROW
 
	`__nnu
 ((3));

237 #i
__HAVE_FLOAT64
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

238 
	$romf64
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

239 
_Flt64
 
__f
)

240 
__THROW
 
	`__nnu
 ((3));

243 #i
__HAVE_FLOAT128
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

244 
	$romf128
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

245 
_Flt128
 
__f
)

246 
__THROW
 
	`__nnu
 ((3));

249 #i
__HAVE_FLOAT32X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

250 
	$romf32x
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

251 
_Flt32x
 
__f
)

252 
__THROW
 
	`__nnu
 ((3));

255 #i
__HAVE_FLOAT64X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

256 
	$romf64x
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

257 
_Flt64x
 
__f
)

258 
__THROW
 
	`__nnu
 ((3));

261 #i
__HAVE_FLOAT128X
 && 
	`__GLIBC_USE
 (
IEC_60559_TYPES_EXT
)

262 
	$romf128x
 (*
__de
, 
size_t
 
__size
, cڡ * 
__fm
,

263 
_Flt128x
 
__f
)

264 
__THROW
 
	`__nnu
 ((3));

268 #ifde
__USE_GNU


272 
	~<bs/tys/lo_t.h
>

274 
	$_l
 (cڡ *
__ri
 
__Ō
,

275 **
__ri
 
__dr
, 
__ba
,

276 
lo_t
 
__loc

__THROW
 
	`__nnu
 ((1, 4));

278 
	$oul_l
 (cڡ *
__ri
 
__Ō
,

279 **
__ri
 
__dr
,

280 
__ba
, 
lo_t
 
__loc
)

281 
__THROW
 
	`__nnu
 ((1, 4));

283 
__exnsi__


284 
	$l_l
 (cڡ *
__ri
 
__Ō
,

285 **
__ri
 
__dr
, 
__ba
,

286 
lo_t
 
__loc
)

287 
__THROW
 
	`__nnu
 ((1, 4));

289 
__exnsi__


290 
	$ou_l
 (cڡ *
__ri
 
__Ō
,

291 **
__ri
 
__dr
,

292 
__ba
, 
lo_t
 
__loc
)

293 
__THROW
 
	`__nnu
 ((1, 4));

295 
	$od_l
 (cڡ *
__ri
 
__Ō
,

296 **
__ri
 
__dr
, 
lo_t
 
__loc
)

297 
__THROW
 
	`__nnu
 ((1, 3));

299 
	$of_l
 (cڡ *
__ri
 
__Ō
,

300 **
__ri
 
__dr
, 
lo_t
 
__loc
)

301 
__THROW
 
	`__nnu
 ((1, 3));

303 
	$d_l
 (cڡ *
__ri
 
__Ō
,

304 **
__ri
 
__dr
,

305 
lo_t
 
__loc
)

306 
__THROW
 
	`__nnu
 ((1, 3));

308 #i
__HAVE_FLOAT16


309 
_Flt16
 
	$of16_l
 (cڡ *
__ri
 
__Ō
,

310 **
__ri
 
__dr
,

311 
lo_t
 
__loc
)

312 
__THROW
 
	`__nnu
 ((1, 3));

315 #i
__HAVE_FLOAT32


316 
_Flt32
 
	$of32_l
 (cڡ *
__ri
 
__Ō
,

317 **
__ri
 
__dr
,

318 
lo_t
 
__loc
)

319 
__THROW
 
	`__nnu
 ((1, 3));

322 #i
__HAVE_FLOAT64


323 
_Flt64
 
	$of64_l
 (cڡ *
__ri
 
__Ō
,

324 **
__ri
 
__dr
,

325 
lo_t
 
__loc
)

326 
__THROW
 
	`__nnu
 ((1, 3));

329 #i
__HAVE_FLOAT128


330 
_Flt128
 
	$of128_l
 (cڡ *
__ri
 
__Ō
,

331 **
__ri
 
__dr
,

332 
lo_t
 
__loc
)

333 
__THROW
 
	`__nnu
 ((1, 3));

336 #i
__HAVE_FLOAT32X


337 
_Flt32x
 
	$of32x_l
 (cڡ *
__ri
 
__Ō
,

338 **
__ri
 
__dr
,

339 
lo_t
 
__loc
)

340 
__THROW
 
	`__nnu
 ((1, 3));

343 #i
__HAVE_FLOAT64X


344 
_Flt64x
 
	$of64x_l
 (cڡ *
__ri
 
__Ō
,

345 **
__ri
 
__dr
,

346 
lo_t
 
__loc
)

347 
__THROW
 
	`__nnu
 ((1, 3));

350 #i
__HAVE_FLOAT128X


351 
_Flt128x
 
	$of128x_l
 (cڡ *
__ri
 
__Ō
,

352 **
__ri
 
__dr
,

353 
lo_t
 
__loc
)

354 
__THROW
 
	`__nnu
 ((1, 3));

359 #ifde
__USE_EXTERN_INLINES


360 
__ex_le
 

361 
	`__NTH
 (
	$oi
 (cڡ *
__Ō
))

363  (
	`
 (
__Ō
, (**
NULL
, 10);

364 
	}
}

365 
__ex_le
 

366 
__NTH
 (
	$
 (cڡ *
__Ō
))

368  
	`
 (
__Ō
, (**
NULL
, 10);

369 
	}
}

371 #ifde
__USE_ISOC99


372 
__exnsi__
 
__ex_le
 

373 
__NTH
 (
	$l
 (cڡ *
__Ō
))

375  
	`l
 (
__Ō
, (**
NULL
, 10);

376 
	}
}

381 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED


385 *
	$l64a
 (
__n

__THROW
 
__wur
;

388 
	$a64l
 (cڡ *
__s
)

389 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

393 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED


394 
	~<sys/tys.h
>

401 
	$ndom
 (
__THROW
;

404 
	$dom
 (
__ed

__THROW
;

410 *
	$e
 (
__ed
, *
__ebuf
,

411 
size_t
 
__

__THROW
 
	`__nnu
 ((2));

415 *
	$te
 (*
__ebuf

__THROW
 
	`__nnu
 ((1));

418 #ifde
__USE_MISC


423 
	sndom_da


425 
t32_t
 *

;

426 
t32_t
 *

;

427 
t32_t
 *
e
;

428 
nd_ty
;

429 
nd_deg
;

430 
nd_p
;

431 
t32_t
 *
d_r
;

434 
	$ndom_r
 (
ndom_da
 *
__ri
 
__buf
,

435 
t32_t
 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

437 
	$dom_r
 (
__ed
, 
ndom_da
 *
__buf
)

438 
__THROW
 
	`__nnu
 ((2));

440 
	$e_r
 (
__ed
, *
__ri
 
__ebuf
,

441 
size_t
 
__
,

442 
ndom_da
 *
__ri
 
__buf
)

443 
__THROW
 
	`__nnu
 ((2, 4));

445 
	$te_r
 (*
__ri
 
__ebuf
,

446 
ndom_da
 *
__ri
 
__buf
)

447 
__THROW
 
	`__nnu
 ((1, 2));

453 
	$nd
 (
__THROW
;

455 
	$d
 (
__ed

__THROW
;

457 #ifde
__USE_POSIX199506


459 
	$nd_r
 (*
__ed

__THROW
;

463 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


467 
	$dnd48
 (
__THROW
;

468 
	$d48
 (
__xsubi
[3]
__THROW
 
	`__nnu
 ((1));

471 
	$̪d48
 (
__THROW
;

472 
	$Īd48
 (
__xsubi
[3])

473 
__THROW
 
	`__nnu
 ((1));

476 
	$mnd48
 (
__THROW
;

477 
	$jnd48
 (
__xsubi
[3])

478 
__THROW
 
	`__nnu
 ((1));

481 
	$d48
 (
__edv

__THROW
;

482 *
	$ed48
 (
__ed16v
[3])

483 
__THROW
 
	`__nnu
 ((1));

484 
	$lcg48
 (
__m
[7]
__THROW
 
	`__nnu
 ((1));

486 #ifde
__USE_MISC


490 
	sdnd48_da


492 
__x
[3];

493 
__d_x
[3];

494 
__c
;

495 
__
;

496 
__exnsi__
 
__a
;

501 
	$dnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

502 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

503 
	$d48_r
 (
__xsubi
[3],

504 
dnd48_da
 *
__ri
 
__bufr
,

505 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

508 
	$̪d48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

509 *
__ri
 
__su
)

510 
__THROW
 
	`__nnu
 ((1, 2));

511 
	$Īd48_r
 (
__xsubi
[3],

512 
dnd48_da
 *
__ri
 
__bufr
,

513 *
__ri
 
__su
)

514 
__THROW
 
	`__nnu
 ((1, 2));

517 
	$mnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

518 *
__ri
 
__su
)

519 
__THROW
 
	`__nnu
 ((1, 2));

520 
	$jnd48_r
 (
__xsubi
[3],

521 
dnd48_da
 *
__ri
 
__bufr
,

522 *
__ri
 
__su
)

523 
__THROW
 
	`__nnu
 ((1, 2));

526 
	$d48_r
 (
__edv
, 
dnd48_da
 *
__bufr
)

527 
__THROW
 
	`__nnu
 ((2));

529 
	$ed48_r
 (
__ed16v
[3],

530 
dnd48_da
 *
__bufr

__THROW
 
	`__nnu
 ((1, 2));

532 
	$lcg48_r
 (
__m
[7],

533 
dnd48_da
 *
__bufr
)

534 
__THROW
 
	`__nnu
 ((1, 2));

539 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

541 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

542 
__THROW
 
__ibu_mloc__
 
__wur
;

549 *
	$loc
 (*
__r
, 
size_t
 
__size
)

550 
__THROW
 
__ibu_wn_unud_su__
;

552 #ifde
__USE_GNU


558 *
	$loay
 (*
__r
, 
size_t
 
__nmemb
, size_
__size
)

559 
__THROW
 
__ibu_wn_unud_su__
;

563 
	$
 (*
__r

__THROW
;

565 #ifde
__USE_MISC


566 
	~<lo.h
>

569 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

570 || 
defed
 
__USE_MISC


572 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

575 #ifde
__USE_XOPEN2K


577 
	$posix_memign
 (**
__memr
, 
size_t
 
__ignmt
, size_
__size
)

578 
__THROW
 
	`__nnu
 ((1)
__wur
;

581 #ifde
__USE_ISOC11


583 *
	$igd_loc
 (
size_t
 
__ignmt
, size_
__size
)

584 
__THROW
 
__ibu_mloc__
 
	`__ibu_loc_size__
 ((2)
__wur
;

588 
	$abt
 (
__THROW
 
	`__ibu__
 ((
__nܑu__
));

592 
	$ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

594 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


596 #ifde
__lulus


597 "C++" 
	$_quick_ex
 ((*
__func
) ())

598 
__THROW
 
	`__asm
 ("_quick_ex"
	`__nnu
 ((1));

600 
	$_quick_ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

604 #ifdef 
__USE_MISC


607 
	$_ex
 ((*
__func
(
__us
, *
__g
), *__arg)

608 
__THROW
 
	`__nnu
 ((1));

614 
	$ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

616 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


620 
	$quick_ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

623 #ifde
__USE_ISOC99


626 
	$_Ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

631 *
	$gv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

633 #ifde
__USE_GNU


636 *
	$cu_gv
 (cڡ *
__me
)

637 
__THROW
 
	`__nnu
 ((1)
__wur
;

640 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


644 
	$punv
 (*
__rg

__THROW
 
	`__nnu
 ((1));

647 #ifde
__USE_XOPEN2K


650 
	$nv
 (cڡ *
__me
, cڡ *
__vue
, 
__a
)

651 
__THROW
 
	`__nnu
 ((2));

654 
	$unnv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

657 #ifdef 
__USE_MISC


661 
	$nv
 (
__THROW
;

665 #i
defed
 
__USE_MISC
 \

666 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
)

672 *
	$mkmp
 (*
__me

__THROW
 
	`__nnu
 ((1));

675 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


684 #ide
__USE_FILE_OFFSET64


685 
	$mkemp
 (*
__me

	`__nnu
 ((1)
__wur
;

687 #ifde
__REDIRECT


688 
	`__REDIRECT
 (
mkemp
, (*
__me
), 
mkemp64
)

689 
	`__nnu
 ((1)
__wur
;

691 
	#mkemp
 
mkemp64


	)

694 #ifde
__USE_LARGEFILE64


695 
	$mkemp64
 (*
__me

	`__nnu
 ((1)
__wur
;

699 #ifde
__USE_MISC


706 #ide
__USE_FILE_OFFSET64


707 
	$mkemps
 (*
__me
, 
__suffixn

	`__nnu
 ((1)
__wur
;

709 #ifde
__REDIRECT


710 
	`__REDIRECT
 (
mkemps
, (*
__me
, 
__suffixn
),

711 
mkemps64

	`__nnu
 ((1)
__wur
;

713 
	#mkemps
 
mkemps64


	)

716 #ifde
__USE_LARGEFILE64


717 
	$mkemps64
 (*
__me
, 
__suffixn
)

718 
	`__nnu
 ((1)
__wur
;

722 #ifde
__USE_XOPEN2K8


728 *
	$mkdmp
 (*
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

731 #ifde
__USE_GNU


738 #ide
__USE_FILE_OFFSET64


739 
	$mkoemp
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

741 #ifde
__REDIRECT


742 
	`__REDIRECT
 (
mkoemp
, (*
__me
, 
__ags
), 
mkoemp64
)

743 
	`__nnu
 ((1)
__wur
;

745 
	#mkoemp
 
mkoemp64


	)

748 #ifde
__USE_LARGEFILE64


749 
	$mkoemp64
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

758 #ide
__USE_FILE_OFFSET64


759 
	$mkoemps
 (*
__me
, 
__suffixn
, 
__ags
)

760 
	`__nnu
 ((1)
__wur
;

762 #ifde
__REDIRECT


763 
	`__REDIRECT
 (
mkoemps
, (*
__me
, 
__suffixn
,

764 
__ags
), 
mkoemps64
)

765 
	`__nnu
 ((1)
__wur
;

767 
	#mkoemps
 
mkoemps64


	)

770 #ifde
__USE_LARGEFILE64


771 
	$mkoemps64
 (*
__me
, 
__suffixn
, 
__ags
)

772 
	`__nnu
 ((1)
__wur
;

781 
	$syem
 (cڡ *
__commd

__wur
;

784 #ifdef 
__USE_GNU


787 *
	$nilize_fe_me
 (cڡ *
__me
)

788 
__THROW
 
	`__nnu
 ((1)
__wur
;

791 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED


797 *
	$th
 (cڡ *
__ri
 
__me
,

798 *
__ri
 
__sved

__THROW
 
__wur
;

803 #ide
__COMPAR_FN_T


804 
	#__COMPAR_FN_T


	)

805 (*
	t__comr__t
) (const *, const *);

807 #ifdef 
__USE_GNU


808 
__comr__t
 
	tcomris__t
;

811 #ifde
__USE_GNU


812 (*
	t__comr_d__t
) (const *, const *, *);

817 *
	$bch
 (cڡ *
__key
, cڡ *
__ba
,

818 
size_t
 
__nmemb
, size_
__size
, 
__comr__t
 
__comr
)

819 
	`__nnu
 ((1, 2, 5)
__wur
;

821 #ifde
__USE_EXTERN_INLINES


822 
	~<bs/dlib-bch.h
>

827 
	$qst
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

828 
__comr__t
 
__comr

	`__nnu
 ((1, 4));

829 #ifde
__USE_GNU


830 
	$qst_r
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

831 
__comr_d__t
 
__comr
, *
__g
)

832 
	`__nnu
 ((1, 4));

837 
	$abs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

838 
	$bs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

840 #ifde
__USE_ISOC99


841 
__exnsi__
 
	$abs
 (
__x
)

842 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

849 
div_t
 
	$div
 (
__num
, 
__dom
)

850 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

851 
ldiv_t
 
	$ldiv
 (
__num
, 
__dom
)

852 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

854 #ifde
__USE_ISOC99


855 
__exnsi__
 
div_t
 
	$div
 (
__num
,

856 
__dom
)

857 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

861 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

862 || 
defed
 
__USE_MISC


869 *
	$ecvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

870 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

875 *
	$fcvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

876 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

881 *
	$gcvt
 (
__vue
, 
__ndig
, *
__buf
)

882 
__THROW
 
	`__nnu
 ((3)
__wur
;

885 #ifde
__USE_MISC


887 *
	$qecvt
 (
__vue
, 
__ndig
,

888 *
__ri
 
__det
, *__ri 
__sign
)

889 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

890 *
	$qfcvt
 (
__vue
, 
__ndig
,

891 *
__ri
 
__det
, *__ri 
__sign
)

892 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

893 *
	$qgcvt
 (
__vue
, 
__ndig
, *
__buf
)

894 
__THROW
 
	`__nnu
 ((3)
__wur
;

899 
	$ecvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

900 *
__ri
 
__sign
, *__ri 
__buf
,

901 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

902 
	$fcvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

903 *
__ri
 
__sign
, *__ri 
__buf
,

904 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

906 
	$qecvt_r
 (
__vue
, 
__ndig
,

907 *
__ri
 
__det
, *__ri 
__sign
,

908 *
__ri
 
__buf
, 
size_t
 
__n
)

909 
__THROW
 
	`__nnu
 ((3, 4, 5));

910 
	$qfcvt_r
 (
__vue
, 
__ndig
,

911 *
__ri
 
__det
, *__ri 
__sign
,

912 *
__ri
 
__buf
, 
size_t
 
__n
)

913 
__THROW
 
	`__nnu
 ((3, 4, 5));

919 
	$mbn
 (cڡ *
__s
, 
size_t
 
__n

__THROW
;

922 
	$mbtowc
 (
wch_t
 *
__ri
 
__pwc
,

923 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

926 
	$womb
 (*
__s
, 
wch_t
 
__wch

__THROW
;

930 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__pwcs
,

931 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

933 
size_t
 
	$wcombs
 (*
__ri
 
__s
,

934 cڡ 
wch_t
 *
__ri
 
__pwcs
, 
size_t
 
__n
)

935 
__THROW
;

938 #ifde
__USE_MISC


943 
	$mch
 (cڡ *
__ڣ

__THROW
 
	`__nnu
 ((1)
__wur
;

947 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


954 
	$gsubt
 (**
__ri
 
__tip
,

955 *cڡ *
__ri
 
__toks
,

956 **
__ri
 
__vu
)

957 
__THROW
 
	`__nnu
 ((1, 2, 3)
__wur
;

961 #ifde
__USE_XOPEN


963 
	$tkey
 (cڡ *
__key

__THROW
 
	`__nnu
 ((1));

969 #ifde
__USE_XOPEN2KXSI


971 
	$posix_ݒ
 (
__oag

__wur
;

974 #ifde
__USE_XOPEN_EXTENDED


979 
	$g
 (
__fd

__THROW
;

983 
	$uock
 (
__fd

__THROW
;

988 *
	$ame
 (
__fd

__THROW
 
__wur
;

991 #ifde
__USE_GNU


995 
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

996 
__THROW
 
	`__nnu
 ((2));

999 
	`g
 ();

1002 #ifde
__USE_MISC


1006 
	$gldavg
 (
__ldavg
[], 
__m
)

1007 
__THROW
 
	`__nnu
 ((1));

1010 #i
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K


1013 
	$y
 (
__THROW
;

1016 
	~<bs/dlib-t.h
>

1019 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


1020 
	~<bs/dlib.h
>

1022 #ifde
__LDBL_COMPAT


1023 
	~<bs/dlib-ldbl.h
>

1026 
__END_DECLS


	@/usr/include/alloca.h

18 #idef 
_ALLOCA_H


19 
	#_ALLOCA_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

26 
	g__BEGIN_DECLS


29 #unde
lo


32 *
	$lo
 (
size_t
 
__size

__THROW
;

34 #ifdef 
__GNUC__


35 
	#lo
(
size

	`__but_lo
 (size)

	)

38 
__END_DECLS


	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

119 #unde
__USE_ISOC11


120 #unde
__USE_ISOC99


121 #unde
__USE_ISOC95


122 #unde
__USE_ISOCXX11


123 #unde
__USE_POSIX


124 #unde
__USE_POSIX2


125 #unde
__USE_POSIX199309


126 #unde
__USE_POSIX199506


127 #unde
__USE_XOPEN


128 #unde
__USE_XOPEN_EXTENDED


129 #unde
__USE_UNIX98


130 #unde
__USE_XOPEN2K


131 #unde
__USE_XOPEN2KXSI


132 #unde
__USE_XOPEN2K8


133 #unde
__USE_XOPEN2K8XSI


134 #unde
__USE_LARGEFILE


135 #unde
__USE_LARGEFILE64


136 #unde
__USE_FILE_OFFSET64


137 #unde
__USE_MISC


138 #unde
__USE_ATFILE


139 #unde
__USE_GNU


140 #unde
__USE_FORTIFY_LEVEL


141 #unde
__KERNEL_STRICT_NAMES


142 #unde
__GLIBC_USE_DEPRECATED_GETS


146 #ide
_LOOSE_KERNEL_NAMES


147 
	#__KERNEL_STRICT_NAMES


	)

157 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


158 
	#__GNUC_PREREQ
(
maj
, 
m
) \

159 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

161 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

168 #i
defed
 
__g_maj__
 && defed 
__g_m__


169 
	#__glibc_g_eq
(
maj
, 
m
) \

170 ((
__g_maj__
 << 16+ 
__g_m__
 >((
maj
<< 16+ (
m
))

	)

172 
	#__glibc_g_eq
(
maj
, 
m
0

	)

176 
	#__GLIBC_USE
(
F

__GLIBC_USE_
 ## 
	)
F

182 #i(
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE
) \

183 && !
defed
 
	g_DEFAULT_SOURCE


185 #unde
_DEFAULT_SOURCE


186 
	#_DEFAULT_SOURCE
 1

	)

190 #ifde
_GNU_SOURCE


191 #unde
_ISOC95_SOURCE


192 
	#_ISOC95_SOURCE
 1

	)

193 #unde
_ISOC99_SOURCE


194 
	#_ISOC99_SOURCE
 1

	)

195 #unde
_ISOC11_SOURCE


196 
	#_ISOC11_SOURCE
 1

	)

197 #unde
_POSIX_SOURCE


198 
	#_POSIX_SOURCE
 1

	)

199 #unde
_POSIX_C_SOURCE


200 
	#_POSIX_C_SOURCE
 200809L

	)

201 #unde
_XOPEN_SOURCE


202 
	#_XOPEN_SOURCE
 700

	)

203 #unde
_XOPEN_SOURCE_EXTENDED


204 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

205 #unde
_LARGEFILE64_SOURCE


206 
	#_LARGEFILE64_SOURCE
 1

	)

207 #unde
_DEFAULT_SOURCE


208 
	#_DEFAULT_SOURCE
 1

	)

209 #unde
_ATFILE_SOURCE


210 
	#_ATFILE_SOURCE
 1

	)

215 #i(
defed
 
_DEFAULT_SOURCE
 \

216 || (!
defed
 
	g__STRICT_ANSI__
 \

217 && !
defed
 
	g_ISOC99_SOURCE
 \

218 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

219 && !
defed
 
	g_XOPEN_SOURCE
))

220 #unde
_DEFAULT_SOURCE


221 
	#_DEFAULT_SOURCE
 1

	)

225 #i(
defed
 
_ISOC11_SOURCE
 \

226 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

227 
	#__USE_ISOC11
 1

	)

231 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

232 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

233 
	#__USE_ISOC99
 1

	)

237 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

238 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

239 
	#__USE_ISOC95
 1

	)

242 #ifde
__lulus


244 #i
__lulus
 >= 201703L

245 
	#__USE_ISOC11
 1

	)

249 #i
__lulus
 >201103L || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__


250 
	#__USE_ISOCXX11
 1

	)

251 
	#__USE_ISOC99
 1

	)

258 #ifde
_DEFAULT_SOURCE


259 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


260 
	#__USE_POSIX_IMPLICITLY
 1

	)

262 #unde
_POSIX_SOURCE


263 
	#_POSIX_SOURCE
 1

	)

264 #unde
_POSIX_C_SOURCE


265 
	#_POSIX_C_SOURCE
 200809L

	)

268 #i((!
defed
 
__STRICT_ANSI__
 \

269 || (
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) >= 500)) \

270 && !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

271 
	#_POSIX_SOURCE
 1

	)

272 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

273 
	#_POSIX_C_SOURCE
 2

	)

274 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

275 
	#_POSIX_C_SOURCE
 199506L

	)

276 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

277 
	#_POSIX_C_SOURCE
 200112L

	)

279 
	#_POSIX_C_SOURCE
 200809L

	)

281 
	#__USE_POSIX_IMPLICITLY
 1

	)

290 #i((!
defed
 
_POSIX_C_SOURCE
 || (_POSIX_C_SOURCE - 0) < 199506L) \

291 && (
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE
))

292 
	#_POSIX_SOURCE
 1

	)

293 #unde
_POSIX_C_SOURCE


294 
	#_POSIX_C_SOURCE
 199506L

	)

297 #i(
defed
 
_POSIX_SOURCE
 \

298 || (
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 1) \

299 || 
defed
 
_XOPEN_SOURCE
)

300 
	#__USE_POSIX
 1

	)

303 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


304 
	#__USE_POSIX2
 1

	)

307 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199309L

308 
	#__USE_POSIX199309
 1

	)

311 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199506L

312 
	#__USE_POSIX199506
 1

	)

315 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200112L

316 
	#__USE_XOPEN2K
 1

	)

317 #unde
__USE_ISOC95


318 
	#__USE_ISOC95
 1

	)

319 #unde
__USE_ISOC99


320 
	#__USE_ISOC99
 1

	)

323 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200809L

324 
	#__USE_XOPEN2K8
 1

	)

325 #unde
_ATFILE_SOURCE


326 
	#_ATFILE_SOURCE
 1

	)

329 #ifdef 
_XOPEN_SOURCE


330 
	#__USE_XOPEN
 1

	)

331 #i(
_XOPEN_SOURCE
 - 0) >= 500

332 
	#__USE_XOPEN_EXTENDED
 1

	)

333 
	#__USE_UNIX98
 1

	)

334 #unde
_LARGEFILE_SOURCE


335 
	#_LARGEFILE_SOURCE
 1

	)

336 #i(
_XOPEN_SOURCE
 - 0) >= 600

337 #i(
_XOPEN_SOURCE
 - 0) >= 700

338 
	#__USE_XOPEN2K8
 1

	)

339 
	#__USE_XOPEN2K8XSI
 1

	)

341 
	#__USE_XOPEN2K
 1

	)

342 
	#__USE_XOPEN2KXSI
 1

	)

343 #unde
__USE_ISOC95


344 
	#__USE_ISOC95
 1

	)

345 #unde
__USE_ISOC99


346 
	#__USE_ISOC99
 1

	)

349 #ifde
_XOPEN_SOURCE_EXTENDED


350 
	#__USE_XOPEN_EXTENDED
 1

	)

355 #ifde
_LARGEFILE_SOURCE


356 
	#__USE_LARGEFILE
 1

	)

359 #ifde
_LARGEFILE64_SOURCE


360 
	#__USE_LARGEFILE64
 1

	)

363 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

364 
	#__USE_FILE_OFFSET64
 1

	)

367 #i
defed
 
_DEFAULT_SOURCE


368 
	#__USE_MISC
 1

	)

371 #ifdef 
_ATFILE_SOURCE


372 
	#__USE_ATFILE
 1

	)

375 #ifdef 
_GNU_SOURCE


376 
	#__USE_GNU
 1

	)

379 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

380 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

381 #i
_FORTIFY_SOURCE
 > 1

382 
	#__USE_FORTIFY_LEVEL
 2

	)

384 
	#__USE_FORTIFY_LEVEL
 1

	)

387 
	#__USE_FORTIFY_LEVEL
 0

	)

394 #i
defed
 
__lulus
 ? __lulu>201402L : defed 
__USE_ISOC11


395 
	#__GLIBC_USE_DEPRECATED_GETS
 0

	)

397 
	#__GLIBC_USE_DEPRECATED_GETS
 1

	)

402 
	~<dc-edef.h
>

410 #unde
__GNU_LIBRARY__


411 
	#__GNU_LIBRARY__
 6

	)

415 
	#__GLIBC__
 2

	)

416 
	#__GLIBC_MINOR__
 27

	)

418 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

419 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

422 #ide
__ASSEMBLER__


423 #ide
_SYS_CDEFS_H


424 
	~<sys/cdefs.h
>

429 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


430 
	#__USE_LARGEFILE
 1

	)

431 
	#__USE_LARGEFILE64
 1

	)

437 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

438 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

439 && 
defed
 
	g__ex_le


440 
	#__USE_EXTERN_INLINES
 1

	)

448 
	~<gnu/ubs.h
>

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

58 
	#__STDC_ISO_10646__
 201706L

	)

61 
	#__STDC_NO_THREADS__
 1

	)

	@
1
.
1
/usr/include
176
3161
AMF-UE-NGAP-ID.c
AMFPointer.c
AMFRegionID.c
AMFSetID.c
BIT_STRING.c
BOOLEAN.c
CGI.c
CoreCPID.c
E-UTRA-ARFCN.c
E-UTRA-PCI.c
E-UTRA-TAC.c
E2SM-KPM-ActionDefinition-Format1.c
E2SM-KPM-ActionDefinition-Format2.c
E2SM-KPM-ActionDefinition-Format3.c
E2SM-KPM-ActionDefinition.c
E2SM-KPM-EventTriggerDefinition-Format1.c
E2SM-KPM-EventTriggerDefinition.c
E2SM-KPM-IndicationHeader-Format1.c
E2SM-KPM-IndicationHeader.c
E2SM-KPM-IndicationMessage-Format1.c
E2SM-KPM-IndicationMessage-Format2.c
E2SM-KPM-IndicationMessage.c
E2SM-KPM-RANfunction-Description.c
EN-GNB-ID.c
ENB-ID.c
ENB-UE-X2AP-ID-Extension.c
ENB-UE-X2AP-ID.c
EUTRA-CGI.c
EUTRACellIdentity.c
FiveGS-TAC.c
FiveQI.c
FreqBandNrItem.c
GNB-CU-CP-UE-E1AP-ID.c
GNB-CU-UE-F1AP-ID.c
GNB-CU-UP-ID.c
GNB-DU-ID.c
GNB-ID.c
GUAMI.c
GUMMEI.c
GlobalENB-ID.c
GlobalGNB-ID.c
GlobalNGRANNodeID.c
GlobalNgENB-ID.c
GlobalenGNB-ID.c
GranularityPeriod.c
GroupID.c
INTEGER.c
IndexToRFSP.c
Interface-MessageID.c
InterfaceID-E1.c
InterfaceID-F1.c
InterfaceID-NG.c
InterfaceID-S1.c
InterfaceID-W1.c
InterfaceID-X2.c
InterfaceID-Xn.c
InterfaceIdentifier.c
InterfaceType.c
LabelInfoItem.c
LabelInfoList.c
MME-Code.c
MME-Group-ID.c
MME-UE-S1AP-ID.c
MatchingCondItem.c
MatchingCondList.c
MatchingUEidItem.c
MatchingUEidList.c
MeasurementCondItem.c
MeasurementCondList.c
MeasurementCondUEidItem.c
MeasurementCondUEidList.c
MeasurementData.c
MeasurementDataItem.c
MeasurementInfo-Action-Item.c
MeasurementInfo-Action-List.c
MeasurementInfoItem.c
MeasurementInfoList.c
MeasurementLabel.c
MeasurementRecord.c
MeasurementRecordItem.c
MeasurementType.c
MeasurementTypeID.c
MeasurementTypeName.c
NG-RANnodeUEXnAPID.c
NGENB-CU-UE-W1AP-ID.c
NGENB-DU-ID.c
NR-ARFCN.c
NR-CGI.c
NR-PCI.c
NRCellIdentity.c
NRFrequencyBand-List.c
NRFrequencyBandItem.c
NRFrequencyInfo.c
NRFrequencyShift7p5khz.c
NULL.c
NativeEnumerated.c
NativeInteger.c
NativeReal.c
NgENB-ID.c
OCTET_STRING.c
OPEN_TYPE.c
PLMNIdentity.c
PrintableString.c
QCI.c
QoSID.c
QosFlowIdentifier.c
RANUEID.c
RANfunction-Name.c
REAL.c
RIC-EventTriggerStyle-Item.c
RIC-Format-Type.c
RIC-ReportStyle-Item.c
RIC-Style-Name.c
RIC-Style-Type.c
RRC-MessageID.c
RRCclass-LTE.c
RRCclass-NR.c
S-NSSAI.c
SD.c
SST.c
ServingCell-ARFCN.c
ServingCell-PCI.c
SubscriberProfileIDforRFP.c
SupportedSULBandList.c
SupportedSULFreqBandItem.c
TestCond-Expression.c
TestCond-Type.c
TestCond-Value.c
TestCondInfo.c
TimeStamp.c
UEID-EN-GNB.c
UEID-ENB.c
UEID-GNB-CU-CP-E1AP-ID-Item.c
UEID-GNB-CU-CP-E1AP-ID-List.c
UEID-GNB-CU-CP-F1AP-ID-Item.c
UEID-GNB-CU-F1AP-ID-List.c
UEID-GNB-CU-UP.c
UEID-GNB-DU.c
UEID-GNB.c
UEID-NG-ENB-DU.c
UEID-NG-ENB.c
UEID.c
asn_SEQUENCE_OF.c
asn_SET_OF.c
asn_application.c
asn_bit_data.c
asn_codecs_prim.c
asn_internal.c
asn_random_fill.c
ber_decoder.c
ber_tlv_length.c
ber_tlv_tag.c
constr_CHOICE.c
constr_SEQUENCE.c
constr_SEQUENCE_OF.c
constr_SET_OF.c
constr_TYPE.c
constraints.c
der_encoder.c
oer_decoder.c
oer_encoder.c
oer_support.c
per_decoder.c
per_encoder.c
per_opentype.c
per_support.c
xer_decoder.c
xer_encoder.c
xer_support.c
/usr/include/errno.h
/usr/include/math.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/alloca.h
/usr/include/features.h
/usr/include/stdc-predef.h
